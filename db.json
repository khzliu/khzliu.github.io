{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/README.md","path":"README.md","modified":1,"renderable":0},{"_id":"themes/pacman/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/pacman/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/pacman/source/img/author.jpg","path":"img/author.jpg","modified":1,"renderable":1},{"_id":"themes/pacman/source/img/logo.svg","path":"img/logo.svg","modified":1,"renderable":1},{"_id":"themes/pacman/source/img/pacman.jpg","path":"img/pacman.jpg","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/pacman/source/js/jquery-2.1.0.min.js","path":"js/jquery-2.1.0.min.js","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/pacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"14e7df4110bb5dee17947ea373453d8b4430a28f","modified":1467017517000},{"_id":"source/CNAME","hash":"b4bcf1032f1fcc8c2d28588b2651f07b9753745c","modified":1461776072000},{"_id":"source/README.md","hash":"6144e773e66a96a13b290c6b0d446c6ed3576571","modified":1461776072000},{"_id":"themes/pacman/LICENSE","hash":"0138565d68df6e5536667ad445232981ea808aec","modified":1461767867000},{"_id":"themes/pacman/_config.yml","hash":"bd06fe191d9873b141b9dcc29af25ab62dada7c7","modified":1466584120000},{"_id":"themes/pacman/README.md","hash":"d7efa5614e13f8fc7db5e9030e4cc2b27c2df171","modified":1461767867000},{"_id":"source/_drafts/HybridApp.md","hash":"894c8015c68321414adb11a7c0644431f5c1e1a5","modified":1466584327000},{"_id":"source/_drafts/.DS_Store","hash":"5a59ec67e946dddf8bdecc10d12464c0d1e1ed4e","modified":1466693544000},{"_id":"source/_drafts/iOS-camera.md","hash":"667fc9f6ca4bd93e411a018738aa63cca9858545","modified":1466584316000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1466584683000},{"_id":"source/_posts/blog-read.md","hash":"622e59a7c487fd1f6d36ad22565ebf4b0dab4453","modified":1467102209000},{"_id":"source/_posts/MVVM.md","hash":"2b7d264799b445d1f15908e5d94361bc10c48168","modified":1466698214000},{"_id":"source/_posts/cocoapods.md","hash":"7ae75ecd97e6e55ae28da854fc52983f803e9ea4","modified":1466583463000},{"_id":"source/_posts/first-blog.md","hash":"daea2b74575ec209df46ffc8276ee401da41cde1","modified":1463539391000},{"_id":"source/_posts/crash-log-analysis.md","hash":"963f1b6d67b8d0f058a09820d0756793d0b04b82","modified":1466583495000},{"_id":"source/_posts/hexo.md","hash":"f944dd66b140983af0fab1b7fcf05a68a7bfcfd0","modified":1466583508000},{"_id":"source/_posts/oc-struct.md","hash":"b8fe0082851c6f3cfc3786193270f2dc28b93e27","modified":1467007778000},{"_id":"source/_posts/interview-checklist.md","hash":"3a8813313fd9c82eb7338762962cd4dbc503c52e","modified":1467110018000},{"_id":"source/about/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1463565133000},{"_id":"source/about/index.md","hash":"98a75c4360444ec547f9c2789284573ea647091b","modified":1463628011000},{"_id":"source/works/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1463565152000},{"_id":"source/categories/index.md","hash":"4f801e7462a1f6455c074cc725158267fda5431b","modified":1463651638000},{"_id":"source/categories/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1463638572000},{"_id":"source/works/index.md","hash":"28e074a886f76752e913c3091bb12b0ca2113e65","modified":1463629167000},{"_id":"source/tags/index.md","hash":"b21f171d101b7dbdc1f632883fd36f33c8de07cd","modified":1463651661000},{"_id":"themes/pacman/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1461767867000},{"_id":"themes/pacman/.git/config","hash":"71ffd708d008fc1611b6c7168a533848e46a9705","modified":1461767867000},{"_id":"themes/pacman/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1461767675000},{"_id":"themes/pacman/.git/index","hash":"4d0bf60b70ef67e5cce7abc7e9dbd66507273e43","modified":1461767867000},{"_id":"themes/pacman/.git/packed-refs","hash":"e45d41cd8a82b23bb1e924b8f9212cfc77f36e07","modified":1461767867000},{"_id":"themes/pacman/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1461767867000},{"_id":"themes/pacman/layout/index.ejs","hash":"774f7e89d05e9a9b43970a873d5100ad5c9d21ba","modified":1461767867000},{"_id":"themes/pacman/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1461767867000},{"_id":"themes/pacman/layout/layout.ejs","hash":"87b543229bec7e77cc0ec68cfdd11f2f33df4a1b","modified":1461767867000},{"_id":"themes/pacman/layout/post.ejs","hash":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1461767867000},{"_id":"themes/pacman/layout/page.ejs","hash":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1461767867000},{"_id":"themes/pacman/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1461767867000},{"_id":"themes/pacman/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1461767867000},{"_id":"themes/pacman/languages/zh-CN.yml","hash":"991b90926686c0d10731a8f4ea61b96c3f087531","modified":1466584145000},{"_id":"themes/pacman/languages/default.yml","hash":"7e9594aa9551cd4841905b4b4d4fcabc2b40e447","modified":1466584139000},{"_id":"themes/pacman/languages/zh-TW.yml","hash":"48b652fa2eb73f9f7cd512472d0cb20057152aea","modified":1466584152000},{"_id":"source/_posts/MVVM/mvc.jpg","hash":"acb2916351c9048aef9376c9586557fcab3b99cb","modified":1466582621000},{"_id":"themes/pacman/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1461767675000},{"_id":"themes/pacman/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1461767675000},{"_id":"themes/pacman/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1461767675000},{"_id":"themes/pacman/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1461767675000},{"_id":"themes/pacman/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1461767675000},{"_id":"themes/pacman/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1461767675000},{"_id":"themes/pacman/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1461767675000},{"_id":"themes/pacman/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1461767675000},{"_id":"themes/pacman/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1461767675000},{"_id":"themes/pacman/.git/logs/HEAD","hash":"6b4e5891dbcd4b164f96b7b4aede55cf328ce4e6","modified":1461767867000},{"_id":"themes/pacman/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1461767675000},{"_id":"themes/pacman/layout/_widget/archive.ejs","hash":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1461767867000},{"_id":"themes/pacman/layout/_widget/category.ejs","hash":"9b4cc6be18aa6c5da4cf45913d5be83fc33081db","modified":1461767867000},{"_id":"themes/pacman/layout/_widget/links.ejs","hash":"3635a1a407fde93a3be58178b85f51ceb8b87f15","modified":1461767867000},{"_id":"themes/pacman/layout/_widget/tag.ejs","hash":"cc97db230f727c27519298166ad904358811fb53","modified":1461767867000},{"_id":"themes/pacman/layout/_widget/rss.ejs","hash":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1461767867000},{"_id":"themes/pacman/layout/_widget/tagcloud.ejs","hash":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1461767867000},{"_id":"themes/pacman/layout/_partial/categories.ejs","hash":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1461767867000},{"_id":"themes/pacman/layout/_partial/article.ejs","hash":"38837fc6a1a799e83b8a75db642b0daf1ff81828","modified":1461767867000},{"_id":"themes/pacman/layout/_partial/after_footer.ejs","hash":"af5d700c7e22e364216535142bc0adc798fac22f","modified":1461767867000},{"_id":"themes/pacman/layout/_partial/archive.ejs","hash":"a1ada891cbacf49b397cfa7dd921bdd0ae545a4e","modified":1461767867000},{"_id":"themes/pacman/layout/_partial/footer.ejs","hash":"ecb03b462d938af45bfa5d4aa656cbeb5225f940","modified":1461767867000},{"_id":"themes/pacman/layout/_partial/google_analytics.ejs","hash":"b6871f67c87c87acb5295ce4fb673b16a7296a01","modified":1461767867000},{"_id":"themes/pacman/layout/_partial/head.ejs","hash":"f21fc1b1c16498610a44a552d23059d338f34d2a","modified":1461767867000},{"_id":"themes/pacman/layout/_partial/header.ejs","hash":"515074e0e1449259cfb668217b21224f6e0adde5","modified":1461767867000},{"_id":"themes/pacman/layout/_partial/pagination.ejs","hash":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1461767867000},{"_id":"themes/pacman/layout/_partial/search.ejs","hash":"aed90406246cc43f60dda8cd6558e9eccee342a4","modified":1461767867000},{"_id":"themes/pacman/layout/_partial/sidebar.ejs","hash":"b5aeaab660a18b7a4da568f015e61260eb478916","modified":1461767867000},{"_id":"themes/pacman/layout/_partial/tags.ejs","hash":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1461767867000},{"_id":"themes/pacman/source/css/style.styl","hash":"b096cc43460e68004bbef41229f67420b5816637","modified":1461767867000},{"_id":"themes/pacman/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1461767867000},{"_id":"themes/pacman/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1461767867000},{"_id":"themes/pacman/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1461767867000},{"_id":"themes/pacman/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1461767867000},{"_id":"themes/pacman/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1461767867000},{"_id":"themes/pacman/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1461767867000},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1461767867000},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1461767867000},{"_id":"themes/pacman/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1461767867000},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1461767867000},{"_id":"themes/pacman/source/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1461767867000},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1461767867000},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1461767867000},{"_id":"themes/pacman/source/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1461767867000},{"_id":"themes/pacman/source/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1461767867000},{"_id":"themes/pacman/source/img/favicon.ico","hash":"fa2c03e9eb35f2f423a1c85c85c278649a857532","modified":1461767867000},{"_id":"themes/pacman/source/img/author.jpg","hash":"348503314ae352a8095d26e95df509e1b611a14b","modified":1461772854000},{"_id":"themes/pacman/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1466582589000},{"_id":"themes/pacman/source/img/logo.svg","hash":"cef3f0bb4bf3661dd3a58c81b9a7be79601a0bfb","modified":1461767867000},{"_id":"themes/pacman/source/img/pacman.jpg","hash":"7e873f2f40a52f8c679302b88bb0809a6abafe5c","modified":1461767867000},{"_id":"themes/pacman/source/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1461767867000},{"_id":"themes/pacman/source/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1461767867000},{"_id":"themes/pacman/source/js/jquery-2.1.0.min.js","hash":"98884258cbdb0d939fa2c5e74fc7ac9e56d8170f","modified":1461767867000},{"_id":"themes/pacman/.git/refs/heads/master","hash":"70324d8fb61c49f6ec262f392ff6cff3ac8f80ca","modified":1461767867000},{"_id":"themes/pacman/.git/objects/pack/pack-acad1edec8e846817639a2e00b10c2ac151c43e5.idx","hash":"4570ad6db0137731b3c73ecf74c2080c4917feaa","modified":1461767867000},{"_id":"themes/pacman/layout/_partial/post/article.ejs","hash":"ec5e8f66886dedf35b9a5746d11fe0dc4a7ab68f","modified":1461767867000},{"_id":"themes/pacman/layout/_partial/post/catetags.ejs","hash":"f6b107078094333b6567d4a97700f559159675e1","modified":1461767867000},{"_id":"themes/pacman/layout/_partial/post/comment.ejs","hash":"5c0afcd1fd1d7b4e8335f76bc181b8e72ffed38e","modified":1461767867000},{"_id":"themes/pacman/layout/_partial/post/footer.ejs","hash":"a9aeae612eb7085bbe74bd12086198320e6c3702","modified":1461767867000},{"_id":"themes/pacman/layout/_partial/post/header.ejs","hash":"73aa8a410cc80277930acaec23003c30eeac6d79","modified":1461767867000},{"_id":"themes/pacman/layout/_partial/post/gallery.ejs","hash":"7ca5b1db9439be61a8b77f6f7d857b56fdf1517f","modified":1461767867000},{"_id":"themes/pacman/layout/_partial/post/jiathis.ejs","hash":"adc047d2bbd031092df86f3be2866ea9c3b5f3c9","modified":1461767867000},{"_id":"themes/pacman/layout/_partial/post/pagination.ejs","hash":"dd9563aaa7094c7082a16e6c9cbc24b33aaef87c","modified":1461767867000},{"_id":"themes/pacman/source/css/_base/font.styl","hash":"75f264bc742888dbe192e8d19eda70705d13c709","modified":1461767867000},{"_id":"themes/pacman/source/css/_base/public.styl","hash":"29deec49b60533cc4196175345eaa4b2d611a97e","modified":1461767867000},{"_id":"themes/pacman/source/css/_base/code.styl","hash":"330209ebaebe69308e131fada85b9b619c85fbd9","modified":1463654472000},{"_id":"themes/pacman/source/css/_base/variable.styl","hash":"3640eedfb72d2bc5a5d75be5b0c9c7954f39229d","modified":1461767867000},{"_id":"themes/pacman/source/css/_partial/article.styl","hash":"82d7621920e221b7e52dfdb74cbcec718d0cc666","modified":1461767867000},{"_id":"themes/pacman/source/css/_partial/duoshuo.styl","hash":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1461767867000},{"_id":"themes/pacman/source/css/_partial/footer.styl","hash":"77c2e6251cea1f3970646f6fbe5d557ed4f98586","modified":1461767867000},{"_id":"themes/pacman/source/css/_partial/gallery.styl","hash":"a544a58fdb4c8dd8274159323abd1e38cb03215e","modified":1461767867000},{"_id":"themes/pacman/source/css/_partial/header.styl","hash":"d27d0057b86dc61a1ab8a9037ee43dfcc43766b3","modified":1461767867000},{"_id":"themes/pacman/source/css/_partial/helper.styl","hash":"52d4ee51b7087c2c2a7e7ded6f63270165d9de89","modified":1461767867000},{"_id":"themes/pacman/source/css/_partial/index.styl","hash":"0d219fc6fb76c0d4ffd1dc2a119969d78a157285","modified":1461767867000},{"_id":"themes/pacman/source/css/_partial/aside.styl","hash":"8fb8c2172883913b404f8e49e181103317486ecc","modified":1466584215000},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1461767867000},{"_id":"themes/pacman/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1461767867000},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1461767867000},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1461767867000},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1461767867000},{"_id":"themes/pacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1461767867000},{"_id":"themes/pacman/source/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1461767867000},{"_id":"themes/pacman/.git/logs/refs/heads/master","hash":"6b4e5891dbcd4b164f96b7b4aede55cf328ce4e6","modified":1461767867000},{"_id":"themes/pacman/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1461767867000},{"_id":"themes/pacman/.git/logs/refs/remotes/origin/HEAD","hash":"6b4e5891dbcd4b164f96b7b4aede55cf328ce4e6","modified":1461767867000},{"_id":"themes/pacman/.git/objects/pack/pack-acad1edec8e846817639a2e00b10c2ac151c43e5.pack","hash":"f5067b0b077a36c6d01b05f1f1341a67fdb7dbc7","modified":1461767867000},{"_id":"public/about/index.html","hash":"59e49f45b5bd7371560042bbe0121090fbf09ded","modified":1467110160936},{"_id":"public/categories/index.html","hash":"faa0a6d034090436380866c7831e51d7c6f34889","modified":1467110160936},{"_id":"public/works/index.html","hash":"fd655b03a2f38a8148366c7c70cef673644104e6","modified":1467110160937},{"_id":"public/tags/index.html","hash":"45d5d5599bf6ee00de2e1bea522173248c391e19","modified":1467110160937},{"_id":"public/2016/06/27/blog-read/index.html","hash":"861bcab3db5b25efb5ce401ec02a3272fffdba60","modified":1467110160937},{"_id":"public/2016/06/22/MVVM/index.html","hash":"5127a594287a3100acb23e42fa239d0b718b5b72","modified":1467110160937},{"_id":"public/2016/04/27/first-blog/index.html","hash":"ddd0c4a89b3bbc9dfac364576021fd7501fe532a","modified":1467110160937},{"_id":"public/archives/index.html","hash":"ebe88d21e39b6bc7c450a55f6ed2bad796e90005","modified":1467110160937},{"_id":"public/archives/2016/index.html","hash":"046fe07efafa15a7e67492767a47a92186a44267","modified":1467110160937},{"_id":"public/archives/2016/04/index.html","hash":"8e3fc4f09d0537e8b491bdaab635422bd9cfffe1","modified":1467110160937},{"_id":"public/archives/2016/05/index.html","hash":"7ce449aba284a36f51bb3255d5800cfd78e12014","modified":1467110160937},{"_id":"public/archives/2016/06/index.html","hash":"30e67e0f0dcf69c8b678cd6b10a7fc50b9ee789a","modified":1467110160937},{"_id":"public/categories/iOS/index.html","hash":"9b65222f13d44a46d2f4adbcd34fc92ddb04c05d","modified":1467110160937},{"_id":"public/categories/Xcode基础/index.html","hash":"6f1915b58f434b1305a65e0fa75676483d55ef8f","modified":1467110160937},{"_id":"public/categories/日常记事/index.html","hash":"44112286af7e98a803f435ece23f85c24cb5a5e2","modified":1467110160938},{"_id":"public/categories/Objective-C语言/index.html","hash":"46af8c4c8a2a4cef33c8fc58243351b6fd286dec","modified":1467110160938},{"_id":"public/index.html","hash":"d848ee1c83fc51cca8e0df6d0d9a873731e5191b","modified":1467110160938},{"_id":"public/tags/iOS/index.html","hash":"1398ef3a4e3140f2f6b95d863131e00d31a90e33","modified":1467110160938},{"_id":"public/tags/设计模式/index.html","hash":"5da4f37c6c79761e6bb1cb19c01bc3af6ace080a","modified":1467110160938},{"_id":"public/tags/Xcode/index.html","hash":"0ce85d237e22b539273c78ed641b55bc54fafafa","modified":1467110160938},{"_id":"public/tags/Hexo/index.html","hash":"4847f669fd94af7044f176cbf02871f696f9f1d7","modified":1467110160938},{"_id":"public/tags/面试/index.html","hash":"f58fac78ff77661224e8691691b6c9717e73a426","modified":1467110160938},{"_id":"public/tags/Objective-C/index.html","hash":"c6031a453074aca9a5bfcb1ca622f503e82c18ad","modified":1467110160938},{"_id":"public/2016/06/27/oc-struct/index.html","hash":"2339482bb1c48004afeaa05d493fbf48f07473c7","modified":1467110160939},{"_id":"public/2016/06/23/interview-checklist/index.html","hash":"6c97287c8997969e80a1d6c40b3893b0367612e3","modified":1467110160939},{"_id":"public/2016/05/25/cocoapods/index.html","hash":"dff304aa7765a4d367d1cf8ed308e1a034ef6af6","modified":1467110160939},{"_id":"public/2016/05/23/crash-log-analysis/index.html","hash":"1b071aa96101753b68b15ea3a641b967388eef4d","modified":1467110160939},{"_id":"public/2016/05/19/hexo/index.html","hash":"5e6452feb610fbd13e5691d48102185becea4249","modified":1467110160939},{"_id":"public/README.md","hash":"6144e773e66a96a13b290c6b0d446c6ed3576571","modified":1467110160948},{"_id":"public/CNAME","hash":"b4bcf1032f1fcc8c2d28588b2651f07b9753745c","modified":1467110160949},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1467110160949},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1467110160949},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1467110160949},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1467110160949},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1467110160949},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1467110160949},{"_id":"public/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1467110160949},{"_id":"public/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1467110160949},{"_id":"public/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1467110160949},{"_id":"public/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1467110160949},{"_id":"public/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1467110160949},{"_id":"public/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1467110160949},{"_id":"public/img/favicon.ico","hash":"fa2c03e9eb35f2f423a1c85c85c278649a857532","modified":1467110160950},{"_id":"public/img/author.jpg","hash":"348503314ae352a8095d26e95df509e1b611a14b","modified":1467110160950},{"_id":"public/img/logo.svg","hash":"cef3f0bb4bf3661dd3a58c81b9a7be79601a0bfb","modified":1467110160950},{"_id":"public/img/pacman.jpg","hash":"7e873f2f40a52f8c679302b88bb0809a6abafe5c","modified":1467110160950},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1467110160950},{"_id":"public/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1467110162004},{"_id":"public/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1467110162007},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1467110162021},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1467110162021},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1467110162021},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1467110162021},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1467110162021},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1467110162021},{"_id":"public/css/style.css","hash":"2448704e6a6702316c247736e089f917327ff4e4","modified":1467110162021},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1467110162021},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1467110162022},{"_id":"public/js/jquery-2.1.0.min.js","hash":"98884258cbdb0d939fa2c5e74fc7ac9e56d8170f","modified":1467110162022},{"_id":"public/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1467110162030}],"Category":[{"name":"iOS","_id":"cipzbicf90004siftqziesnbk"},{"name":"Xcode基础","_id":"cipzbicg5000fsiftpeqpxal6"},{"name":"日常记事","_id":"cipzbicgg000ksiftbtygv5mq"},{"name":"Objective-C语言","_id":"cipzbicgi000qsift4n4i4f4u"}],"Data":[],"Page":[{"title":"about","date":"2016-05-19T03:20:11.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-05-19 11:20:11\n---\n","updated":"2016-05-19T03:20:11.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cipzbicez0001siftlel38ydu","content":"","excerpt":"","more":""},{"layout":"categories","title":"categories","date":"2016-05-19T06:10:14.000Z","_content":"","source":"categories/index.md","raw":"---\nlayout: \"categories\"\ntitle: categories\ndate: 2016-05-19 14:10:14\n\n---\n","updated":"2016-05-19T09:53:58.000Z","path":"categories/index.html","comments":1,"_id":"cipzbicgw0014sift6uq4dqrv","content":"","excerpt":"","more":""},{"title":"works","date":"2016-05-19T03:39:27.000Z","_content":"","source":"works/index.md","raw":"---\ntitle: works\ndate: 2016-05-19 11:39:27\n---\n","updated":"2016-05-19T03:39:27.000Z","path":"works/index.html","comments":1,"layout":"page","_id":"cipzbicgy0015sift6fo1ta9i","content":"","excerpt":"","more":""},{"layout":"tags","title":"TagCloud","date":"2016-05-19T06:08:25.000Z","comments":0,"_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: TagCloud\ndate: 2016-05-19 14:08:25\ncomments: false\n\n---\n","updated":"2016-05-19T09:54:21.000Z","path":"tags/index.html","_id":"cipzbicgz0016siftr8eedfcz","content":"","excerpt":"","more":""}],"Post":[{"title":"基于UIWebview/WKWebview的移动开发框架","date":"2016-05-18T09:07:14.000Z","_content":"\n＃ 送我\n","source":"_drafts/HybridApp.md","raw":"---\ntitle: 基于UIWebview/WKWebview的移动开发框架\ndate: 2016-05-18 17:07:14\ncategories: iOS\ntags: [HybridApp,Webview,Javascript]\n\n\n---\n\n＃ 送我\n","slug":"HybridApp","published":0,"updated":"2016-06-22T08:32:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzbicet0000siftxzzmagtp","content":"<p>＃ 送我</p>\n","excerpt":"","more":"<p>＃ 送我</p>\n"},{"title":"推荐几个iOS大牛的Blog","date":"2016-06-27T09:29:32.000Z","ategories":"日常记事","_content":"\n## 几个国内比较牛的iOS技术大牛的博客\n\n* [OneV's Den](https://onevcat.com/)\n* [NSHipster](http://nshipster.cn/)\n* [唐巧的技术博客](http://blog.devtang.com/)\n* [sunnyxx的技术博客](http://blog.sunnyxx.com/)\n* [ibireme](http://blog.ibireme.com/)\n* [Chun Tips](http://chun.tips/)\n* [bang's blog](http://blog.cnbang.net/)\n* [庞海礁的个人空间](http://www.olinone.com/)\n* [南峰子的技术博客](http://southpeak.github.io/)\n\n\n\n\n\n\n\n### <font color=\"red\">持续更新中..</font>","source":"_posts/blog-read.md","raw":"---\ntitle: 推荐几个iOS大牛的Blog\ndate: 2016-06-27 17:29:32\ntags: [iOS]\nategories: 日常记事\n\n---\n\n## 几个国内比较牛的iOS技术大牛的博客\n\n* [OneV's Den](https://onevcat.com/)\n* [NSHipster](http://nshipster.cn/)\n* [唐巧的技术博客](http://blog.devtang.com/)\n* [sunnyxx的技术博客](http://blog.sunnyxx.com/)\n* [ibireme](http://blog.ibireme.com/)\n* [Chun Tips](http://chun.tips/)\n* [bang's blog](http://blog.cnbang.net/)\n* [庞海礁的个人空间](http://www.olinone.com/)\n* [南峰子的技术博客](http://southpeak.github.io/)\n\n\n\n\n\n\n\n### <font color=\"red\">持续更新中..</font>","slug":"blog-read","published":1,"updated":"2016-06-28T08:23:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzbicf10002sift3qvscxpg","content":"<h2 id=\"几个国内比较牛的iOS技术大牛的博客\"><a href=\"#几个国内比较牛的iOS技术大牛的博客\" class=\"headerlink\" title=\"几个国内比较牛的iOS技术大牛的博客\"></a>几个国内比较牛的iOS技术大牛的博客</h2><ul>\n<li><a href=\"https://onevcat.com/\" target=\"_blank\" rel=\"external\">OneV’s Den</a></li>\n<li><a href=\"http://nshipster.cn/\" target=\"_blank\" rel=\"external\">NSHipster</a></li>\n<li><a href=\"http://blog.devtang.com/\" target=\"_blank\" rel=\"external\">唐巧的技术博客</a></li>\n<li><a href=\"http://blog.sunnyxx.com/\" target=\"_blank\" rel=\"external\">sunnyxx的技术博客</a></li>\n<li><a href=\"http://blog.ibireme.com/\" target=\"_blank\" rel=\"external\">ibireme</a></li>\n<li><a href=\"http://chun.tips/\" target=\"_blank\" rel=\"external\">Chun Tips</a></li>\n<li><a href=\"http://blog.cnbang.net/\" target=\"_blank\" rel=\"external\">bang’s blog</a></li>\n<li><a href=\"http://www.olinone.com/\" target=\"_blank\" rel=\"external\">庞海礁的个人空间</a></li>\n<li><a href=\"http://southpeak.github.io/\" target=\"_blank\" rel=\"external\">南峰子的技术博客</a></li>\n</ul>\n<h3 id=\"持续更新中\"><a href=\"#持续更新中\" class=\"headerlink\" title=\"持续更新中..\"></a><font color=\"red\">持续更新中..</font></h3>","excerpt":"","more":"<h2 id=\"几个国内比较牛的iOS技术大牛的博客\"><a href=\"#几个国内比较牛的iOS技术大牛的博客\" class=\"headerlink\" title=\"几个国内比较牛的iOS技术大牛的博客\"></a>几个国内比较牛的iOS技术大牛的博客</h2><ul>\n<li><a href=\"https://onevcat.com/\">OneV’s Den</a></li>\n<li><a href=\"http://nshipster.cn/\">NSHipster</a></li>\n<li><a href=\"http://blog.devtang.com/\">唐巧的技术博客</a></li>\n<li><a href=\"http://blog.sunnyxx.com/\">sunnyxx的技术博客</a></li>\n<li><a href=\"http://blog.ibireme.com/\">ibireme</a></li>\n<li><a href=\"http://chun.tips/\">Chun Tips</a></li>\n<li><a href=\"http://blog.cnbang.net/\">bang’s blog</a></li>\n<li><a href=\"http://www.olinone.com/\">庞海礁的个人空间</a></li>\n<li><a href=\"http://southpeak.github.io/\">南峰子的技术博客</a></li>\n</ul>\n<h3 id=\"持续更新中\"><a href=\"#持续更新中\" class=\"headerlink\" title=\"持续更新中..\"></a><font color=\"red\">持续更新中..</font></h3>"},{"title":"iOS_camera","_content":"\n# 市面上的相机类App\n1. nice\n2. in\n3. Camera360/Camera360SDK\n\n\n# 相机类App的功能点\n1. 标签\n2. 贴图\n3. 滤镜\n4. 蒙板\n5. 编辑\n6. 涂鸦\n 马赛克的实现\n7. 特效\n8. 景深\n \n\n\n# 相机类App用到的技术点\n1. GPUImage\n2. Quartz 2D\n3. Core Graphics\n4. Core Image\n5. OpenGLES\n6. QuartzCore  \n7. OpenCV\n\n","source":"_drafts/iOS-camera.md","raw":"---\ntitle: iOS_camera\ntags:\n\n---\n\n# 市面上的相机类App\n1. nice\n2. in\n3. Camera360/Camera360SDK\n\n\n# 相机类App的功能点\n1. 标签\n2. 贴图\n3. 滤镜\n4. 蒙板\n5. 编辑\n6. 涂鸦\n 马赛克的实现\n7. 特效\n8. 景深\n \n\n\n# 相机类App用到的技术点\n1. GPUImage\n2. Quartz 2D\n3. Core Graphics\n4. Core Image\n5. OpenGLES\n6. QuartzCore  \n7. OpenCV\n\n","slug":"iOS-camera","published":0,"date":"2016-05-23T02:42:44.000Z","updated":"2016-06-22T08:31:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzbicfa0005sifts1lrppud","content":"<h1 id=\"市面上的相机类App\"><a href=\"#市面上的相机类App\" class=\"headerlink\" title=\"市面上的相机类App\"></a>市面上的相机类App</h1><ol>\n<li>nice</li>\n<li>in</li>\n<li>Camera360/Camera360SDK</li>\n</ol>\n<h1 id=\"相机类App的功能点\"><a href=\"#相机类App的功能点\" class=\"headerlink\" title=\"相机类App的功能点\"></a>相机类App的功能点</h1><ol>\n<li>标签</li>\n<li>贴图</li>\n<li>滤镜</li>\n<li>蒙板</li>\n<li>编辑</li>\n<li>涂鸦<br>马赛克的实现</li>\n<li>特效</li>\n<li>景深</li>\n</ol>\n<h1 id=\"相机类App用到的技术点\"><a href=\"#相机类App用到的技术点\" class=\"headerlink\" title=\"相机类App用到的技术点\"></a>相机类App用到的技术点</h1><ol>\n<li>GPUImage</li>\n<li>Quartz 2D</li>\n<li>Core Graphics</li>\n<li>Core Image</li>\n<li>OpenGLES</li>\n<li>QuartzCore  </li>\n<li>OpenCV</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"市面上的相机类App\"><a href=\"#市面上的相机类App\" class=\"headerlink\" title=\"市面上的相机类App\"></a>市面上的相机类App</h1><ol>\n<li>nice</li>\n<li>in</li>\n<li>Camera360/Camera360SDK</li>\n</ol>\n<h1 id=\"相机类App的功能点\"><a href=\"#相机类App的功能点\" class=\"headerlink\" title=\"相机类App的功能点\"></a>相机类App的功能点</h1><ol>\n<li>标签</li>\n<li>贴图</li>\n<li>滤镜</li>\n<li>蒙板</li>\n<li>编辑</li>\n<li>涂鸦<br>马赛克的实现</li>\n<li>特效</li>\n<li>景深</li>\n</ol>\n<h1 id=\"相机类App用到的技术点\"><a href=\"#相机类App用到的技术点\" class=\"headerlink\" title=\"相机类App用到的技术点\"></a>相机类App用到的技术点</h1><ol>\n<li>GPUImage</li>\n<li>Quartz 2D</li>\n<li>Core Graphics</li>\n<li>Core Image</li>\n<li>OpenGLES</li>\n<li>QuartzCore  </li>\n<li>OpenCV</li>\n</ol>\n"},{"title":"我对MVVM的理解","date":"2016-06-22T06:23:45.000Z","language":"zh-CN","_content":"# MVC\n先说MVC模式，在前端应用开发中MVC是一个最经典最常用的设计模式，也是被Apple封为神的设计模式。我个人项目应用也是最多的一种；在MVC中所有的对象被归类为一个model，一个view，或一个controller。Model持有数据，View显示与用户交互的界面，而View Controller调解Model和View之间的交互。如下图（盗图）：<br/>\n![MVC](http://7xoo3c.com1.z0.glb.clouddn.com/blogmvc.jpg \"MVC\")\n\n图中Controler起链接View和Model的作用，正式由于Controler所担责任的职责过大以至于Controler的任务过于庞大复杂，对问题的调试查找产生很大困难。\n\n# MVVM\nMVVM模式广泛应用在WPF项目开发中，使用此模式可以把UI和业务逻辑分离开，使UI设计人员和业务逻辑人员能够分工明确。它去除Controller中的逻辑层新增VM层，合并View和Controller层为View层，大大分担了Controller和View层中的业务逻辑负担。\n\n![MVC](http://7xoo3c.com1.z0.glb.clouddn.com/blog_mvvm.png \"MVC\")\n\n# 等过段时间理解透了再写！！！\n","source":"_posts/MVVM.md","raw":"---\ntitle: 我对MVVM的理解\ndate: 2016-06-22 14:23:45\ntags: [设计模式]\nlanguage: zh-CN\n\n---\n# MVC\n先说MVC模式，在前端应用开发中MVC是一个最经典最常用的设计模式，也是被Apple封为神的设计模式。我个人项目应用也是最多的一种；在MVC中所有的对象被归类为一个model，一个view，或一个controller。Model持有数据，View显示与用户交互的界面，而View Controller调解Model和View之间的交互。如下图（盗图）：<br/>\n![MVC](http://7xoo3c.com1.z0.glb.clouddn.com/blogmvc.jpg \"MVC\")\n\n图中Controler起链接View和Model的作用，正式由于Controler所担责任的职责过大以至于Controler的任务过于庞大复杂，对问题的调试查找产生很大困难。\n\n# MVVM\nMVVM模式广泛应用在WPF项目开发中，使用此模式可以把UI和业务逻辑分离开，使UI设计人员和业务逻辑人员能够分工明确。它去除Controller中的逻辑层新增VM层，合并View和Controller层为View层，大大分担了Controller和View层中的业务逻辑负担。\n\n![MVC](http://7xoo3c.com1.z0.glb.clouddn.com/blog_mvvm.png \"MVC\")\n\n# 等过段时间理解透了再写！！！\n","slug":"MVVM","published":1,"updated":"2016-06-23T16:10:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzbicfd0006siftbgti8q3a","content":"<h1 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h1><p>先说MVC模式，在前端应用开发中MVC是一个最经典最常用的设计模式，也是被Apple封为神的设计模式。我个人项目应用也是最多的一种；在MVC中所有的对象被归类为一个model，一个view，或一个controller。Model持有数据，View显示与用户交互的界面，而View Controller调解Model和View之间的交互。如下图（盗图）：<br><br><img src=\"http://7xoo3c.com1.z0.glb.clouddn.com/blogmvc.jpg\" alt=\"MVC\" title=\"MVC\"></p>\n<p>图中Controler起链接View和Model的作用，正式由于Controler所担责任的职责过大以至于Controler的任务过于庞大复杂，对问题的调试查找产生很大困难。</p>\n<h1 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h1><p>MVVM模式广泛应用在WPF项目开发中，使用此模式可以把UI和业务逻辑分离开，使UI设计人员和业务逻辑人员能够分工明确。它去除Controller中的逻辑层新增VM层，合并View和Controller层为View层，大大分担了Controller和View层中的业务逻辑负担。</p>\n<p><img src=\"http://7xoo3c.com1.z0.glb.clouddn.com/blog_mvvm.png\" alt=\"MVC\" title=\"MVC\"></p>\n<h1 id=\"等过段时间理解透了再写！！！\"><a href=\"#等过段时间理解透了再写！！！\" class=\"headerlink\" title=\"等过段时间理解透了再写！！！\"></a>等过段时间理解透了再写！！！</h1>","excerpt":"","more":"<h1 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h1><p>先说MVC模式，在前端应用开发中MVC是一个最经典最常用的设计模式，也是被Apple封为神的设计模式。我个人项目应用也是最多的一种；在MVC中所有的对象被归类为一个model，一个view，或一个controller。Model持有数据，View显示与用户交互的界面，而View Controller调解Model和View之间的交互。如下图（盗图）：<br/><br><img src=\"http://7xoo3c.com1.z0.glb.clouddn.com/blogmvc.jpg\" alt=\"MVC\" title=\"MVC\"></p>\n<p>图中Controler起链接View和Model的作用，正式由于Controler所担责任的职责过大以至于Controler的任务过于庞大复杂，对问题的调试查找产生很大困难。</p>\n<h1 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h1><p>MVVM模式广泛应用在WPF项目开发中，使用此模式可以把UI和业务逻辑分离开，使UI设计人员和业务逻辑人员能够分工明确。它去除Controller中的逻辑层新增VM层，合并View和Controller层为View层，大大分担了Controller和View层中的业务逻辑负担。</p>\n<p><img src=\"http://7xoo3c.com1.z0.glb.clouddn.com/blog_mvvm.png\" alt=\"MVC\" title=\"MVC\"></p>\n<h1 id=\"等过段时间理解透了再写！！！\"><a href=\"#等过段时间理解透了再写！！！\" class=\"headerlink\" title=\"等过段时间理解透了再写！！！\"></a>等过段时间理解透了再写！！！</h1>"},{"title":"使用cocoapods管理第三方库","language":"zh-CN","_content":"\n# CocoaPods简介\n[CocoaPods](https://cocoapods.org/)是一个负责管理iOS项目中第三方开源库的工具。CocoaPods的项目源码在[Github](https://github.com/CocoaPods/CocoaPods)上管理。该项目开始于2011年8月12日，在这两年多的时间里，它持续保持活跃更新。开发iOS项目不可避免地要使用第三方开源库，CocoaPods的出现使得我们可以节省设置和更新第三方开源库的时间。\n# CocoaPods安装\nCocoapod的安装网上的例子一大堆，这里及时简单列举几个步骤以便日后使用。\n## 安装Ruby环境 \nMac OS 自带Ruby环境，所以只需要升级一下Ruby版本就可以了<br/>\n终端输入如下命令（把Ruby镜像指向taobao，避免被墙，你懂得）<br/>\n淘宝已经关闭HTTP协议的景象服务，改为HTTPS协议。<br/>\n淘宝ruby地址：`https://ruby.taobao.org/` <br/>\n\n\n\tgem sources --remove https://rubygems.org/ \n\tgem sources -a https://ruby.taobao.org/ \n\tgem sources -l  （用来检查使用替换镜像位置成功）\n\t\n## 安装cocoapods\n下载安装CocoaPods,终端输入：\n\t\n\tsudo gem install cocoapods \n\t\n如果网速可以的话（没有被墙），几分钟就下载安装完成了。\n# CocoaPods使用\n我们在桌面新建一个项目，名字叫`PodTest`, Xcode会生成 `PodTest`,`PodTest.xcodeproj`和`PodTestTests`三个文件夹。<br/>\n终端中，cd到项目总目录（注意：包含`PodTest`文件夹、`PodTest.xcodeproj`、`PodTestTest`的那个总目录）\n\n\tcd /Users/xxx/Desktop/PodTest\n\n<font color=\"red\">注意：`xxx` 代表的是你的账户名。</font>\n\n建立`Podfile`（配置文件）\n接着上一步，终端输入 \n\t\n\tvim Podfile\n\t\n开始编辑`Podfile`文件内容如下：\n\n\tplatform :ios, '7.0'\n\n\ttarget \"PodTest\" do\n\tpod \"Masonry\", \"~> 1.0.0\"\n\tpod \"GPUImage\", \"~> 0.1.7\"\n\tpod \"MBProgressHUD\", \"~> 0.9.2\" \n\tend\n\n激动人心的时刻到了：确定终端cd到项目总目录，然后输入 pod install，等待一会，大约3分钟。\n\t\n\tpod install\n\t\n完成之后你代码cocoapods给你创建好的WorkSpace就可以了。<br/>\n<br/>\n<font color=\"red\">注意：</font>现在打开项目不是点击 `PodTest.xodeproj` 了，而是点击 `PodTest.xcworkspace`\n\n如果你想要下载其它库，但是你又不知道这个库的版本好 可以输入：\n\t\n\tpod search xxxx\n\t\n# cocoapods常见错误\n\nOS X 10.11 安装Cocoapods 出现问题的解决方法:\n\n今天尝试用 Cocoapods安装个第三方库.. 输入`pod install`， 发现 `command not find`。 WTF！\n\n估计是升级10.11后Cocoapods被干掉了。\n\n我输入 `sudo gem install cocoa pods` 之后，出现如下问题：\n\n\tERROR:  While executing gem ... (Gem::DependencyError)\n\t    Unable to resolve dependencies: cocoapods requires cocoapods-core (= 0.33.1), claide (~> 0.6.1), cocoapods-downloader (~> 0.6.1), cocoapods-plugins (~> 0.2.0), cocoapods-try (~> 0.3.0), cocoapods-trunk (~> 0.1.1), nap (~> 0.7)\n\n解决方法：\n\n\tsudo gem update --system\n  \n但是出现了另一个错误：\n\n\tERROR:  While executing gem ... (Errno::EPERM)\n\t    Operation not permitted - /usr/bin/xcodeproj\n\n在Stackoverflow上找到了解决方法：\n\n在终端中输入：\n\n\tsudo nvram boot-args=\"rootless=0\"; sudo reboot\n然后你的电脑会重启\n之后再输入 \n\n\tsudo gem install cocoapods -V \n就可以了\n不放心的话输入\n\n\tpod --version\n\t0.37.2 //显示出版本就说明成功了\n\n但是之后我`pod install`的时候又花式出错\n\n\t[!] Unable to add a source with url `https://github.com/CocoaPods/Specs.git` named `master`.\n\tYou can try adding it manually in `~/.cocoapods/repos` or via `pod repo add`.\n\n我尝试按提示的方法\n\n\tpod repo add master https://github.com/CocoaPods/Specs.git\n\n然而还是有错..\n\n\t[!] /usr/bin/git clone http://git.oschina.net/akuandev/Specs.git master\n\t\n\txcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun\n\n最后的解决方法：\n\n\tsudo xcode-select -switch /Applications/Xcode-beta.app/Contents/Developers\n\n后面的地址你可以打开Xcode显示包内容，找到那个文件夹拖到终端里面比较不容易错。\n\n\tCocoaPods 0.38.0.beta.2 is available.\n\tTo update use: `gem install cocoapods --pre`\n\t[!] This is a test version we'd love you to try.\n\t\n\tFor more information see http://blog.cocoapods.org\n\tand the CHANGELOG for this version http://git.io/BaH8pQ.\n\t\n\t\n\tCocoaPods 0.38.0.beta.2 is available.\n\tTo update use: `gem install cocoapods --pre`\n\t[!] This is a test version we'd love you to try.\n\t\n\tFor more information see http://blog.cocoapods.org\n\tand the CHANGELOG for this version http://git.io/BaH8pQ.\n\n最后终于修成正果..\n\n参考：\n> http://blog.csdn.net/showhilllee/article/details/38398119/\n> http://www.myexception.cn/operating-system/1962318.html","source":"_posts/cocoapods.md","raw":"---\ntitle: 使用cocoapods管理第三方库\ntags: [iOS]\ncategories: iOS\nlanguage: zh-CN\n\n---\n\n# CocoaPods简介\n[CocoaPods](https://cocoapods.org/)是一个负责管理iOS项目中第三方开源库的工具。CocoaPods的项目源码在[Github](https://github.com/CocoaPods/CocoaPods)上管理。该项目开始于2011年8月12日，在这两年多的时间里，它持续保持活跃更新。开发iOS项目不可避免地要使用第三方开源库，CocoaPods的出现使得我们可以节省设置和更新第三方开源库的时间。\n# CocoaPods安装\nCocoapod的安装网上的例子一大堆，这里及时简单列举几个步骤以便日后使用。\n## 安装Ruby环境 \nMac OS 自带Ruby环境，所以只需要升级一下Ruby版本就可以了<br/>\n终端输入如下命令（把Ruby镜像指向taobao，避免被墙，你懂得）<br/>\n淘宝已经关闭HTTP协议的景象服务，改为HTTPS协议。<br/>\n淘宝ruby地址：`https://ruby.taobao.org/` <br/>\n\n\n\tgem sources --remove https://rubygems.org/ \n\tgem sources -a https://ruby.taobao.org/ \n\tgem sources -l  （用来检查使用替换镜像位置成功）\n\t\n## 安装cocoapods\n下载安装CocoaPods,终端输入：\n\t\n\tsudo gem install cocoapods \n\t\n如果网速可以的话（没有被墙），几分钟就下载安装完成了。\n# CocoaPods使用\n我们在桌面新建一个项目，名字叫`PodTest`, Xcode会生成 `PodTest`,`PodTest.xcodeproj`和`PodTestTests`三个文件夹。<br/>\n终端中，cd到项目总目录（注意：包含`PodTest`文件夹、`PodTest.xcodeproj`、`PodTestTest`的那个总目录）\n\n\tcd /Users/xxx/Desktop/PodTest\n\n<font color=\"red\">注意：`xxx` 代表的是你的账户名。</font>\n\n建立`Podfile`（配置文件）\n接着上一步，终端输入 \n\t\n\tvim Podfile\n\t\n开始编辑`Podfile`文件内容如下：\n\n\tplatform :ios, '7.0'\n\n\ttarget \"PodTest\" do\n\tpod \"Masonry\", \"~> 1.0.0\"\n\tpod \"GPUImage\", \"~> 0.1.7\"\n\tpod \"MBProgressHUD\", \"~> 0.9.2\" \n\tend\n\n激动人心的时刻到了：确定终端cd到项目总目录，然后输入 pod install，等待一会，大约3分钟。\n\t\n\tpod install\n\t\n完成之后你代码cocoapods给你创建好的WorkSpace就可以了。<br/>\n<br/>\n<font color=\"red\">注意：</font>现在打开项目不是点击 `PodTest.xodeproj` 了，而是点击 `PodTest.xcworkspace`\n\n如果你想要下载其它库，但是你又不知道这个库的版本好 可以输入：\n\t\n\tpod search xxxx\n\t\n# cocoapods常见错误\n\nOS X 10.11 安装Cocoapods 出现问题的解决方法:\n\n今天尝试用 Cocoapods安装个第三方库.. 输入`pod install`， 发现 `command not find`。 WTF！\n\n估计是升级10.11后Cocoapods被干掉了。\n\n我输入 `sudo gem install cocoa pods` 之后，出现如下问题：\n\n\tERROR:  While executing gem ... (Gem::DependencyError)\n\t    Unable to resolve dependencies: cocoapods requires cocoapods-core (= 0.33.1), claide (~> 0.6.1), cocoapods-downloader (~> 0.6.1), cocoapods-plugins (~> 0.2.0), cocoapods-try (~> 0.3.0), cocoapods-trunk (~> 0.1.1), nap (~> 0.7)\n\n解决方法：\n\n\tsudo gem update --system\n  \n但是出现了另一个错误：\n\n\tERROR:  While executing gem ... (Errno::EPERM)\n\t    Operation not permitted - /usr/bin/xcodeproj\n\n在Stackoverflow上找到了解决方法：\n\n在终端中输入：\n\n\tsudo nvram boot-args=\"rootless=0\"; sudo reboot\n然后你的电脑会重启\n之后再输入 \n\n\tsudo gem install cocoapods -V \n就可以了\n不放心的话输入\n\n\tpod --version\n\t0.37.2 //显示出版本就说明成功了\n\n但是之后我`pod install`的时候又花式出错\n\n\t[!] Unable to add a source with url `https://github.com/CocoaPods/Specs.git` named `master`.\n\tYou can try adding it manually in `~/.cocoapods/repos` or via `pod repo add`.\n\n我尝试按提示的方法\n\n\tpod repo add master https://github.com/CocoaPods/Specs.git\n\n然而还是有错..\n\n\t[!] /usr/bin/git clone http://git.oschina.net/akuandev/Specs.git master\n\t\n\txcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun\n\n最后的解决方法：\n\n\tsudo xcode-select -switch /Applications/Xcode-beta.app/Contents/Developers\n\n后面的地址你可以打开Xcode显示包内容，找到那个文件夹拖到终端里面比较不容易错。\n\n\tCocoaPods 0.38.0.beta.2 is available.\n\tTo update use: `gem install cocoapods --pre`\n\t[!] This is a test version we'd love you to try.\n\t\n\tFor more information see http://blog.cocoapods.org\n\tand the CHANGELOG for this version http://git.io/BaH8pQ.\n\t\n\t\n\tCocoaPods 0.38.0.beta.2 is available.\n\tTo update use: `gem install cocoapods --pre`\n\t[!] This is a test version we'd love you to try.\n\t\n\tFor more information see http://blog.cocoapods.org\n\tand the CHANGELOG for this version http://git.io/BaH8pQ.\n\n最后终于修成正果..\n\n参考：\n> http://blog.csdn.net/showhilllee/article/details/38398119/\n> http://www.myexception.cn/operating-system/1962318.html","slug":"cocoapods","published":1,"date":"2016-05-25T09:22:42.000Z","updated":"2016-06-22T08:17:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzbicfh0008sift9ixn1k36","content":"<h1 id=\"CocoaPods简介\"><a href=\"#CocoaPods简介\" class=\"headerlink\" title=\"CocoaPods简介\"></a>CocoaPods简介</h1><p><a href=\"https://cocoapods.org/\" target=\"_blank\" rel=\"external\">CocoaPods</a>是一个负责管理iOS项目中第三方开源库的工具。CocoaPods的项目源码在<a href=\"https://github.com/CocoaPods/CocoaPods\" target=\"_blank\" rel=\"external\">Github</a>上管理。该项目开始于2011年8月12日，在这两年多的时间里，它持续保持活跃更新。开发iOS项目不可避免地要使用第三方开源库，CocoaPods的出现使得我们可以节省设置和更新第三方开源库的时间。</p>\n<h1 id=\"CocoaPods安装\"><a href=\"#CocoaPods安装\" class=\"headerlink\" title=\"CocoaPods安装\"></a>CocoaPods安装</h1><p>Cocoapod的安装网上的例子一大堆，这里及时简单列举几个步骤以便日后使用。</p>\n<h2 id=\"安装Ruby环境\"><a href=\"#安装Ruby环境\" class=\"headerlink\" title=\"安装Ruby环境\"></a>安装Ruby环境</h2><p>Mac OS 自带Ruby环境，所以只需要升级一下Ruby版本就可以了<br><br>终端输入如下命令（把Ruby镜像指向taobao，避免被墙，你懂得）<br><br>淘宝已经关闭HTTP协议的景象服务，改为HTTPS协议。<br><br>淘宝ruby地址：<code>https://ruby.taobao.org/</code> <br></p>\n<pre><code>gem sources --remove https://rubygems.org/ \ngem sources -a https://ruby.taobao.org/ \ngem sources -l  （用来检查使用替换镜像位置成功）\n</code></pre><h2 id=\"安装cocoapods\"><a href=\"#安装cocoapods\" class=\"headerlink\" title=\"安装cocoapods\"></a>安装cocoapods</h2><p>下载安装CocoaPods,终端输入：</p>\n<pre><code>sudo gem install cocoapods \n</code></pre><p>如果网速可以的话（没有被墙），几分钟就下载安装完成了。</p>\n<h1 id=\"CocoaPods使用\"><a href=\"#CocoaPods使用\" class=\"headerlink\" title=\"CocoaPods使用\"></a>CocoaPods使用</h1><p>我们在桌面新建一个项目，名字叫<code>PodTest</code>, Xcode会生成 <code>PodTest</code>,<code>PodTest.xcodeproj</code>和<code>PodTestTests</code>三个文件夹。<br><br>终端中，cd到项目总目录（注意：包含<code>PodTest</code>文件夹、<code>PodTest.xcodeproj</code>、<code>PodTestTest</code>的那个总目录）</p>\n<pre><code>cd /Users/xxx/Desktop/PodTest\n</code></pre><font color=\"red\">注意：<code>xxx</code> 代表的是你的账户名。</font>\n\n<p>建立<code>Podfile</code>（配置文件）<br>接着上一步，终端输入 </p>\n<pre><code>vim Podfile\n</code></pre><p>开始编辑<code>Podfile</code>文件内容如下：</p>\n<pre><code>platform :ios, &apos;7.0&apos;\n\ntarget &quot;PodTest&quot; do\npod &quot;Masonry&quot;, &quot;~&gt; 1.0.0&quot;\npod &quot;GPUImage&quot;, &quot;~&gt; 0.1.7&quot;\npod &quot;MBProgressHUD&quot;, &quot;~&gt; 0.9.2&quot; \nend\n</code></pre><p>激动人心的时刻到了：确定终端cd到项目总目录，然后输入 pod install，等待一会，大约3分钟。</p>\n<pre><code>pod install\n</code></pre><p>完成之后你代码cocoapods给你创建好的WorkSpace就可以了。<br><br><br></p>\n<p><font color=\"red\">注意：</font>现在打开项目不是点击 <code>PodTest.xodeproj</code> 了，而是点击 <code>PodTest.xcworkspace</code></p>\n<p>如果你想要下载其它库，但是你又不知道这个库的版本好 可以输入：</p>\n<pre><code>pod search xxxx\n</code></pre><h1 id=\"cocoapods常见错误\"><a href=\"#cocoapods常见错误\" class=\"headerlink\" title=\"cocoapods常见错误\"></a>cocoapods常见错误</h1><p>OS X 10.11 安装Cocoapods 出现问题的解决方法:</p>\n<p>今天尝试用 Cocoapods安装个第三方库.. 输入<code>pod install</code>， 发现 <code>command not find</code>。 WTF！</p>\n<p>估计是升级10.11后Cocoapods被干掉了。</p>\n<p>我输入 <code>sudo gem install cocoa pods</code> 之后，出现如下问题：</p>\n<pre><code>ERROR:  While executing gem ... (Gem::DependencyError)\n    Unable to resolve dependencies: cocoapods requires cocoapods-core (= 0.33.1), claide (~&gt; 0.6.1), cocoapods-downloader (~&gt; 0.6.1), cocoapods-plugins (~&gt; 0.2.0), cocoapods-try (~&gt; 0.3.0), cocoapods-trunk (~&gt; 0.1.1), nap (~&gt; 0.7)\n</code></pre><p>解决方法：</p>\n<pre><code>sudo gem update --system\n</code></pre><p>但是出现了另一个错误：</p>\n<pre><code>ERROR:  While executing gem ... (Errno::EPERM)\n    Operation not permitted - /usr/bin/xcodeproj\n</code></pre><p>在Stackoverflow上找到了解决方法：</p>\n<p>在终端中输入：</p>\n<pre><code>sudo nvram boot-args=&quot;rootless=0&quot;; sudo reboot\n</code></pre><p>然后你的电脑会重启<br>之后再输入 </p>\n<pre><code>sudo gem install cocoapods -V \n</code></pre><p>就可以了<br>不放心的话输入</p>\n<pre><code>pod --version\n0.37.2 //显示出版本就说明成功了\n</code></pre><p>但是之后我<code>pod install</code>的时候又花式出错</p>\n<pre><code>[!] Unable to add a source with url `https://github.com/CocoaPods/Specs.git` named `master`.\nYou can try adding it manually in `~/.cocoapods/repos` or via `pod repo add`.\n</code></pre><p>我尝试按提示的方法</p>\n<pre><code>pod repo add master https://github.com/CocoaPods/Specs.git\n</code></pre><p>然而还是有错..</p>\n<pre><code>[!] /usr/bin/git clone http://git.oschina.net/akuandev/Specs.git master\n\nxcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun\n</code></pre><p>最后的解决方法：</p>\n<pre><code>sudo xcode-select -switch /Applications/Xcode-beta.app/Contents/Developers\n</code></pre><p>后面的地址你可以打开Xcode显示包内容，找到那个文件夹拖到终端里面比较不容易错。</p>\n<pre><code>CocoaPods 0.38.0.beta.2 is available.\nTo update use: `gem install cocoapods --pre`\n[!] This is a test version we&apos;d love you to try.\n\nFor more information see http://blog.cocoapods.org\nand the CHANGELOG for this version http://git.io/BaH8pQ.\n\n\nCocoaPods 0.38.0.beta.2 is available.\nTo update use: `gem install cocoapods --pre`\n[!] This is a test version we&apos;d love you to try.\n\nFor more information see http://blog.cocoapods.org\nand the CHANGELOG for this version http://git.io/BaH8pQ.\n</code></pre><p>最后终于修成正果..</p>\n<p>参考：</p>\n<blockquote>\n<p><a href=\"http://blog.csdn.net/showhilllee/article/details/38398119/\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/showhilllee/article/details/38398119/</a><br><a href=\"http://www.myexception.cn/operating-system/1962318.html\" target=\"_blank\" rel=\"external\">http://www.myexception.cn/operating-system/1962318.html</a></p>\n</blockquote>\n","excerpt":"","more":"<h1 id=\"CocoaPods简介\"><a href=\"#CocoaPods简介\" class=\"headerlink\" title=\"CocoaPods简介\"></a>CocoaPods简介</h1><p><a href=\"https://cocoapods.org/\">CocoaPods</a>是一个负责管理iOS项目中第三方开源库的工具。CocoaPods的项目源码在<a href=\"https://github.com/CocoaPods/CocoaPods\">Github</a>上管理。该项目开始于2011年8月12日，在这两年多的时间里，它持续保持活跃更新。开发iOS项目不可避免地要使用第三方开源库，CocoaPods的出现使得我们可以节省设置和更新第三方开源库的时间。</p>\n<h1 id=\"CocoaPods安装\"><a href=\"#CocoaPods安装\" class=\"headerlink\" title=\"CocoaPods安装\"></a>CocoaPods安装</h1><p>Cocoapod的安装网上的例子一大堆，这里及时简单列举几个步骤以便日后使用。</p>\n<h2 id=\"安装Ruby环境\"><a href=\"#安装Ruby环境\" class=\"headerlink\" title=\"安装Ruby环境\"></a>安装Ruby环境</h2><p>Mac OS 自带Ruby环境，所以只需要升级一下Ruby版本就可以了<br/><br>终端输入如下命令（把Ruby镜像指向taobao，避免被墙，你懂得）<br/><br>淘宝已经关闭HTTP协议的景象服务，改为HTTPS协议。<br/><br>淘宝ruby地址：<code>https://ruby.taobao.org/</code> <br/></p>\n<pre><code>gem sources --remove https://rubygems.org/ \ngem sources -a https://ruby.taobao.org/ \ngem sources -l  （用来检查使用替换镜像位置成功）\n</code></pre><h2 id=\"安装cocoapods\"><a href=\"#安装cocoapods\" class=\"headerlink\" title=\"安装cocoapods\"></a>安装cocoapods</h2><p>下载安装CocoaPods,终端输入：</p>\n<pre><code>sudo gem install cocoapods \n</code></pre><p>如果网速可以的话（没有被墙），几分钟就下载安装完成了。</p>\n<h1 id=\"CocoaPods使用\"><a href=\"#CocoaPods使用\" class=\"headerlink\" title=\"CocoaPods使用\"></a>CocoaPods使用</h1><p>我们在桌面新建一个项目，名字叫<code>PodTest</code>, Xcode会生成 <code>PodTest</code>,<code>PodTest.xcodeproj</code>和<code>PodTestTests</code>三个文件夹。<br/><br>终端中，cd到项目总目录（注意：包含<code>PodTest</code>文件夹、<code>PodTest.xcodeproj</code>、<code>PodTestTest</code>的那个总目录）</p>\n<pre><code>cd /Users/xxx/Desktop/PodTest\n</code></pre><font color=\"red\">注意：<code>xxx</code> 代表的是你的账户名。</font>\n\n<p>建立<code>Podfile</code>（配置文件）<br>接着上一步，终端输入 </p>\n<pre><code>vim Podfile\n</code></pre><p>开始编辑<code>Podfile</code>文件内容如下：</p>\n<pre><code>platform :ios, &apos;7.0&apos;\n\ntarget &quot;PodTest&quot; do\npod &quot;Masonry&quot;, &quot;~&gt; 1.0.0&quot;\npod &quot;GPUImage&quot;, &quot;~&gt; 0.1.7&quot;\npod &quot;MBProgressHUD&quot;, &quot;~&gt; 0.9.2&quot; \nend\n</code></pre><p>激动人心的时刻到了：确定终端cd到项目总目录，然后输入 pod install，等待一会，大约3分钟。</p>\n<pre><code>pod install\n</code></pre><p>完成之后你代码cocoapods给你创建好的WorkSpace就可以了。<br/><br><br/></p>\n<p><font color=\"red\">注意：</font>现在打开项目不是点击 <code>PodTest.xodeproj</code> 了，而是点击 <code>PodTest.xcworkspace</code></p>\n<p>如果你想要下载其它库，但是你又不知道这个库的版本好 可以输入：</p>\n<pre><code>pod search xxxx\n</code></pre><h1 id=\"cocoapods常见错误\"><a href=\"#cocoapods常见错误\" class=\"headerlink\" title=\"cocoapods常见错误\"></a>cocoapods常见错误</h1><p>OS X 10.11 安装Cocoapods 出现问题的解决方法:</p>\n<p>今天尝试用 Cocoapods安装个第三方库.. 输入<code>pod install</code>， 发现 <code>command not find</code>。 WTF！</p>\n<p>估计是升级10.11后Cocoapods被干掉了。</p>\n<p>我输入 <code>sudo gem install cocoa pods</code> 之后，出现如下问题：</p>\n<pre><code>ERROR:  While executing gem ... (Gem::DependencyError)\n    Unable to resolve dependencies: cocoapods requires cocoapods-core (= 0.33.1), claide (~&gt; 0.6.1), cocoapods-downloader (~&gt; 0.6.1), cocoapods-plugins (~&gt; 0.2.0), cocoapods-try (~&gt; 0.3.0), cocoapods-trunk (~&gt; 0.1.1), nap (~&gt; 0.7)\n</code></pre><p>解决方法：</p>\n<pre><code>sudo gem update --system\n</code></pre><p>但是出现了另一个错误：</p>\n<pre><code>ERROR:  While executing gem ... (Errno::EPERM)\n    Operation not permitted - /usr/bin/xcodeproj\n</code></pre><p>在Stackoverflow上找到了解决方法：</p>\n<p>在终端中输入：</p>\n<pre><code>sudo nvram boot-args=&quot;rootless=0&quot;; sudo reboot\n</code></pre><p>然后你的电脑会重启<br>之后再输入 </p>\n<pre><code>sudo gem install cocoapods -V \n</code></pre><p>就可以了<br>不放心的话输入</p>\n<pre><code>pod --version\n0.37.2 //显示出版本就说明成功了\n</code></pre><p>但是之后我<code>pod install</code>的时候又花式出错</p>\n<pre><code>[!] Unable to add a source with url `https://github.com/CocoaPods/Specs.git` named `master`.\nYou can try adding it manually in `~/.cocoapods/repos` or via `pod repo add`.\n</code></pre><p>我尝试按提示的方法</p>\n<pre><code>pod repo add master https://github.com/CocoaPods/Specs.git\n</code></pre><p>然而还是有错..</p>\n<pre><code>[!] /usr/bin/git clone http://git.oschina.net/akuandev/Specs.git master\n\nxcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun\n</code></pre><p>最后的解决方法：</p>\n<pre><code>sudo xcode-select -switch /Applications/Xcode-beta.app/Contents/Developers\n</code></pre><p>后面的地址你可以打开Xcode显示包内容，找到那个文件夹拖到终端里面比较不容易错。</p>\n<pre><code>CocoaPods 0.38.0.beta.2 is available.\nTo update use: `gem install cocoapods --pre`\n[!] This is a test version we&apos;d love you to try.\n\nFor more information see http://blog.cocoapods.org\nand the CHANGELOG for this version http://git.io/BaH8pQ.\n\n\nCocoaPods 0.38.0.beta.2 is available.\nTo update use: `gem install cocoapods --pre`\n[!] This is a test version we&apos;d love you to try.\n\nFor more information see http://blog.cocoapods.org\nand the CHANGELOG for this version http://git.io/BaH8pQ.\n</code></pre><p>最后终于修成正果..</p>\n<p>参考：</p>\n<blockquote>\n<p><a href=\"http://blog.csdn.net/showhilllee/article/details/38398119/\">http://blog.csdn.net/showhilllee/article/details/38398119/</a><br><a href=\"http://www.myexception.cn/operating-system/1962318.html\">http://www.myexception.cn/operating-system/1962318.html</a></p>\n</blockquote>\n"},{"title":"开通博客了","date":"2016-04-27T15:56:36.000Z","_content":"我的博客开通了，对于写博客我之前是没有一点好感的，最主要的是因为自己太懒了，同时也认为写博客应该是那些大牛们做的事情，自己这么菜，写出来的东西肯定会误人子弟，但是工作三年之后，我发现并不是这样；博客只是自己学习和与别人交流的平台<br/>\n<br/>\n这是我写博客的初衷：<br/>\n\n1. 记录一下自己在学习过程中遇到的容易出错的知识点，避免再次碰壁\n2. 写博客提高一下自己对知识点的总结能力，总不能会但是讲不出来吧\n3. 贴出自己的对某点的理解，好让大牛改卷啊\n4. 也希望对自己的一些提升吧\n\n     ","source":"_posts/first-blog.md","raw":"---\ntitle: 开通博客了\ndate: 2016-04-27 23:56:36\ntags:\n---\n我的博客开通了，对于写博客我之前是没有一点好感的，最主要的是因为自己太懒了，同时也认为写博客应该是那些大牛们做的事情，自己这么菜，写出来的东西肯定会误人子弟，但是工作三年之后，我发现并不是这样；博客只是自己学习和与别人交流的平台<br/>\n<br/>\n这是我写博客的初衷：<br/>\n\n1. 记录一下自己在学习过程中遇到的容易出错的知识点，避免再次碰壁\n2. 写博客提高一下自己对知识点的总结能力，总不能会但是讲不出来吧\n3. 贴出自己的对某点的理解，好让大牛改卷啊\n4. 也希望对自己的一些提升吧\n\n     ","slug":"first-blog","published":1,"updated":"2016-05-18T02:43:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzbicfl0009siftauzrbv9o","content":"<p>我的博客开通了，对于写博客我之前是没有一点好感的，最主要的是因为自己太懒了，同时也认为写博客应该是那些大牛们做的事情，自己这么菜，写出来的东西肯定会误人子弟，但是工作三年之后，我发现并不是这样；博客只是自己学习和与别人交流的平台<br><br><br><br>这是我写博客的初衷：<br></p>\n<ol>\n<li>记录一下自己在学习过程中遇到的容易出错的知识点，避免再次碰壁</li>\n<li>写博客提高一下自己对知识点的总结能力，总不能会但是讲不出来吧</li>\n<li>贴出自己的对某点的理解，好让大牛改卷啊</li>\n<li>也希望对自己的一些提升吧</li>\n</ol>\n","excerpt":"","more":"<p>我的博客开通了，对于写博客我之前是没有一点好感的，最主要的是因为自己太懒了，同时也认为写博客应该是那些大牛们做的事情，自己这么菜，写出来的东西肯定会误人子弟，但是工作三年之后，我发现并不是这样；博客只是自己学习和与别人交流的平台<br/><br><br/><br>这是我写博客的初衷：<br/></p>\n<ol>\n<li>记录一下自己在学习过程中遇到的容易出错的知识点，避免再次碰壁</li>\n<li>写博客提高一下自己对知识点的总结能力，总不能会但是讲不出来吧</li>\n<li>贴出自己的对某点的理解，好让大牛改卷啊</li>\n<li>也希望对自己的一些提升吧</li>\n</ol>\n"},{"title":"通过dSYM分析crash Log","language":"zh-CN","_content":"\n在项目开发过程中，对于已经上线的App有时会莫名其秒的Crash，切这些Crash在Xcode上是无法复现，导致了我们无法通过Xcode进行调试。还好Device能够记录这些crash日志，我们可用通过Xcode导出这些日志，但是这些日志记录的内容却令人头疼了，我们根据日志的内容（全是些地址信息）无法定位到代码的哪一行产生的错误，我们就需要dSYM文件来帮我们定位分析Crash log了。<br/>\n\n### 使用步骤\n#### 1. 导出错误日志 \n通过Xcode的Organizer查看设备的Logs，并把你要查看的Log导出到文件夹reportAnalysis,命名app.crash <br/>\n#### 2. 导出App的可执行文件\n找到该App当前版本的ipa文件，解压后得到Payload文件夹，并把xxx.app复制到reportAnalysis<br/>\n#### 3. 导出App对应build版本的dSYM文件\ndSYM文件可通过Xcode的Organizer找到对应build版本，右键_show in finder_，并显示该版本的b包内容，文件夹dSYMs内就是该App的dSYM文件，把xxx.app.dSYM文件拷贝到reportAnalysis<br/>\n#### 4. 确定dSYM，app和Crash文件的关系\n每一个xx.app, xxx.app.dSYM文件都拥有相应的uuid，crash文件也有uuid,只有三者uuid一至才表明之三者可以解析出正确的日志文件。\n查看xx.app文件的uuid的方法，在terminal中输入命令：\n\n\tdwarfdump --uuid xxx.app/xxx (xxx工程名)\n\n查看xx.app.dSYM文件的uuid的方法，在terminal中输入命令：\n\n\tdwarfdump --uuid xxx.app.dSYM (xxx工程名) \n\n\n而.crash的uuid位于，crash日志中的Binary Images:中的第一行。如：\n\n\tarmv7 <8bdeaf1a0b233ac199728c2a0ebb4165> \n\n对应的<a style=\"color:#F00\">xxx.app.dSYM</a>文件以及<a style=\"color:#F00\">xxx.app</a>文件以及<a style=\"color:#F00\">xxx.crash</a>文件拷贝到同一文件夹中，如：\n\n\t~/Desktop/reportAnalysis\n\t\n#### 5. 通过symbolicatecrash分析crash文件\nXcode有自带的symbolicatecrash工具,可以通过dSYM文件将crash文件中的16进制地址转换成可读的函数地址。symbolicatecrash工具位于:\n\n\t/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKit.framework/Versions/A/Resources/symbolicatecrash(Xcode 4.5)\n\n\t/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKitBase.framework/Versions/A/Resources/symbolicatecrash(Xcode 5.0,Xcode 6.0)\n\n\t/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash(Xcode 7.0)\n\n该文件是隐藏文件，可以通过如下命令查找并拷贝到系统目录下，并建立快捷方式。\n\n\n###### 5.1 打开终端，进入到symbolicatecrash工具所在的文件夹目录\n\n\tcd /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKitBase.framework/Versions/A/Resources/\n\n<br/>\n\n###### 5.2 查找确认是否存在symbolicatecrash\n\n\tls -al | grep symbolicatecrash\n\n###### 5.3 将symbolicatecrash工具拷贝到/usr/bin目录下或者讲symbolicatecrash拷贝到reportAnalysis文件夹内\n\n\tsudo cp symbolicatecrash /usr/bin/symbolicatecrash\nor\n\n\tsudo cp symbolicatecrash ~/Desktop/reportAnalysis\n\n###### 5.4 设置DEVELOPER_DIR系统变量\n\n\tcd ~/\n\t\n\tvi .bash_profile\n\n并输入如下内容\n\n\texport DEVELOPER_DIR=\"/Applications/Xcode.app/Contents/Developer\"\n\n保存并退出\n\n\tsource .bash_profile\n\n###### 5.5 重启终端，确认是否已正确设置DEVELOPER_DIR系统变量\n\n\techo $DEVELOPER_DIR\n\n查看输出结果是否为/Applications/Xcode.app/Contents/Developer\n\n###### 5.6 查看PATH系统变量是否存在如下路径/usr/bin\n\n\techo $PATH\n\n###### 5.7 如果PATH不存在如下路径/usr/bin，可在~/.bash_profile中添加如下代码\n\n\texport PATH=\"/usr/bin:$PATH\"\n\n保存并退出\n\n\tsource .bash_profile\n\n###### 5.8 上述准备工作完成后，进入dSYM和crash文件对应的文件夹目录，如\n\n\tcd ~/Desktop/DebugLog\n\n###### 5.9 执行如下命令，即可正确解析crash文件\n\n\tsymbolicatecrash xxx.crash xxx.app.dSYM > test.txt\n\n<a style=\"color:#F00\">注意：symbolicatecrash的参数顺序，否则会报类似如下错误:</a>\n\n\tUse of uninitialized value $data in substitution (s///) at /usr/bin/symbolicatecrash line 678.<br/>\n\tUse of uninitialized value $data in substitution (s///) at /usr/bin/symbolicatecrash line 681.<br/>\n\tUse of uninitialized value $data in substitution (s///) at /usr/bin/symbolicatecrash line 685.<br/>\n\tUse of uninitialized value in pattern match (m//) at /usr/bin/symbolicatecrash line 404.<br/>\n\tUse of uninitialized value in scalar assignment at /usr/bin/symbolicatecrash line 418.<br/>\n\tNo crash report version in XXX.app.dSYM/ at /usr/bin/symbolicatecrash line 954.\n\n\n> 参考：http://blog.csdn.net/hjy_x/article/details/20929095","source":"_posts/crash-log-analysis.md","raw":"---\ntitle: 通过dSYM分析crash Log\ntags: [Xcode]\ncategories: Xcode基础\nlanguage: zh-CN\n\n\n---\n\n在项目开发过程中，对于已经上线的App有时会莫名其秒的Crash，切这些Crash在Xcode上是无法复现，导致了我们无法通过Xcode进行调试。还好Device能够记录这些crash日志，我们可用通过Xcode导出这些日志，但是这些日志记录的内容却令人头疼了，我们根据日志的内容（全是些地址信息）无法定位到代码的哪一行产生的错误，我们就需要dSYM文件来帮我们定位分析Crash log了。<br/>\n\n### 使用步骤\n#### 1. 导出错误日志 \n通过Xcode的Organizer查看设备的Logs，并把你要查看的Log导出到文件夹reportAnalysis,命名app.crash <br/>\n#### 2. 导出App的可执行文件\n找到该App当前版本的ipa文件，解压后得到Payload文件夹，并把xxx.app复制到reportAnalysis<br/>\n#### 3. 导出App对应build版本的dSYM文件\ndSYM文件可通过Xcode的Organizer找到对应build版本，右键_show in finder_，并显示该版本的b包内容，文件夹dSYMs内就是该App的dSYM文件，把xxx.app.dSYM文件拷贝到reportAnalysis<br/>\n#### 4. 确定dSYM，app和Crash文件的关系\n每一个xx.app, xxx.app.dSYM文件都拥有相应的uuid，crash文件也有uuid,只有三者uuid一至才表明之三者可以解析出正确的日志文件。\n查看xx.app文件的uuid的方法，在terminal中输入命令：\n\n\tdwarfdump --uuid xxx.app/xxx (xxx工程名)\n\n查看xx.app.dSYM文件的uuid的方法，在terminal中输入命令：\n\n\tdwarfdump --uuid xxx.app.dSYM (xxx工程名) \n\n\n而.crash的uuid位于，crash日志中的Binary Images:中的第一行。如：\n\n\tarmv7 <8bdeaf1a0b233ac199728c2a0ebb4165> \n\n对应的<a style=\"color:#F00\">xxx.app.dSYM</a>文件以及<a style=\"color:#F00\">xxx.app</a>文件以及<a style=\"color:#F00\">xxx.crash</a>文件拷贝到同一文件夹中，如：\n\n\t~/Desktop/reportAnalysis\n\t\n#### 5. 通过symbolicatecrash分析crash文件\nXcode有自带的symbolicatecrash工具,可以通过dSYM文件将crash文件中的16进制地址转换成可读的函数地址。symbolicatecrash工具位于:\n\n\t/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKit.framework/Versions/A/Resources/symbolicatecrash(Xcode 4.5)\n\n\t/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKitBase.framework/Versions/A/Resources/symbolicatecrash(Xcode 5.0,Xcode 6.0)\n\n\t/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash(Xcode 7.0)\n\n该文件是隐藏文件，可以通过如下命令查找并拷贝到系统目录下，并建立快捷方式。\n\n\n###### 5.1 打开终端，进入到symbolicatecrash工具所在的文件夹目录\n\n\tcd /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKitBase.framework/Versions/A/Resources/\n\n<br/>\n\n###### 5.2 查找确认是否存在symbolicatecrash\n\n\tls -al | grep symbolicatecrash\n\n###### 5.3 将symbolicatecrash工具拷贝到/usr/bin目录下或者讲symbolicatecrash拷贝到reportAnalysis文件夹内\n\n\tsudo cp symbolicatecrash /usr/bin/symbolicatecrash\nor\n\n\tsudo cp symbolicatecrash ~/Desktop/reportAnalysis\n\n###### 5.4 设置DEVELOPER_DIR系统变量\n\n\tcd ~/\n\t\n\tvi .bash_profile\n\n并输入如下内容\n\n\texport DEVELOPER_DIR=\"/Applications/Xcode.app/Contents/Developer\"\n\n保存并退出\n\n\tsource .bash_profile\n\n###### 5.5 重启终端，确认是否已正确设置DEVELOPER_DIR系统变量\n\n\techo $DEVELOPER_DIR\n\n查看输出结果是否为/Applications/Xcode.app/Contents/Developer\n\n###### 5.6 查看PATH系统变量是否存在如下路径/usr/bin\n\n\techo $PATH\n\n###### 5.7 如果PATH不存在如下路径/usr/bin，可在~/.bash_profile中添加如下代码\n\n\texport PATH=\"/usr/bin:$PATH\"\n\n保存并退出\n\n\tsource .bash_profile\n\n###### 5.8 上述准备工作完成后，进入dSYM和crash文件对应的文件夹目录，如\n\n\tcd ~/Desktop/DebugLog\n\n###### 5.9 执行如下命令，即可正确解析crash文件\n\n\tsymbolicatecrash xxx.crash xxx.app.dSYM > test.txt\n\n<a style=\"color:#F00\">注意：symbolicatecrash的参数顺序，否则会报类似如下错误:</a>\n\n\tUse of uninitialized value $data in substitution (s///) at /usr/bin/symbolicatecrash line 678.<br/>\n\tUse of uninitialized value $data in substitution (s///) at /usr/bin/symbolicatecrash line 681.<br/>\n\tUse of uninitialized value $data in substitution (s///) at /usr/bin/symbolicatecrash line 685.<br/>\n\tUse of uninitialized value in pattern match (m//) at /usr/bin/symbolicatecrash line 404.<br/>\n\tUse of uninitialized value in scalar assignment at /usr/bin/symbolicatecrash line 418.<br/>\n\tNo crash report version in XXX.app.dSYM/ at /usr/bin/symbolicatecrash line 954.\n\n\n> 参考：http://blog.csdn.net/hjy_x/article/details/20929095","slug":"crash-log-analysis","published":1,"date":"2016-05-23T09:31:15.000Z","updated":"2016-06-22T08:18:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzbicfr000bsift194donsm","content":"<p>在项目开发过程中，对于已经上线的App有时会莫名其秒的Crash，切这些Crash在Xcode上是无法复现，导致了我们无法通过Xcode进行调试。还好Device能够记录这些crash日志，我们可用通过Xcode导出这些日志，但是这些日志记录的内容却令人头疼了，我们根据日志的内容（全是些地址信息）无法定位到代码的哪一行产生的错误，我们就需要dSYM文件来帮我们定位分析Crash log了。<br></p>\n<h3 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h3><h4 id=\"1-导出错误日志\"><a href=\"#1-导出错误日志\" class=\"headerlink\" title=\"1. 导出错误日志\"></a>1. 导出错误日志</h4><p>通过Xcode的Organizer查看设备的Logs，并把你要查看的Log导出到文件夹reportAnalysis,命名app.crash <br></p>\n<h4 id=\"2-导出App的可执行文件\"><a href=\"#2-导出App的可执行文件\" class=\"headerlink\" title=\"2. 导出App的可执行文件\"></a>2. 导出App的可执行文件</h4><p>找到该App当前版本的ipa文件，解压后得到Payload文件夹，并把xxx.app复制到reportAnalysis<br></p>\n<h4 id=\"3-导出App对应build版本的dSYM文件\"><a href=\"#3-导出App对应build版本的dSYM文件\" class=\"headerlink\" title=\"3. 导出App对应build版本的dSYM文件\"></a>3. 导出App对应build版本的dSYM文件</h4><p>dSYM文件可通过Xcode的Organizer找到对应build版本，右键<em>show in finder</em>，并显示该版本的b包内容，文件夹dSYMs内就是该App的dSYM文件，把xxx.app.dSYM文件拷贝到reportAnalysis<br></p>\n<h4 id=\"4-确定dSYM，app和Crash文件的关系\"><a href=\"#4-确定dSYM，app和Crash文件的关系\" class=\"headerlink\" title=\"4. 确定dSYM，app和Crash文件的关系\"></a>4. 确定dSYM，app和Crash文件的关系</h4><p>每一个xx.app, xxx.app.dSYM文件都拥有相应的uuid，crash文件也有uuid,只有三者uuid一至才表明之三者可以解析出正确的日志文件。<br>查看xx.app文件的uuid的方法，在terminal中输入命令：</p>\n<pre><code>dwarfdump --uuid xxx.app/xxx (xxx工程名)\n</code></pre><p>查看xx.app.dSYM文件的uuid的方法，在terminal中输入命令：</p>\n<pre><code>dwarfdump --uuid xxx.app.dSYM (xxx工程名) \n</code></pre><p>而.crash的uuid位于，crash日志中的Binary Images:中的第一行。如：</p>\n<pre><code>armv7 &lt;8bdeaf1a0b233ac199728c2a0ebb4165&gt; \n</code></pre><p>对应的<a style=\"color:#F00\">xxx.app.dSYM</a>文件以及<a style=\"color:#F00\">xxx.app</a>文件以及<a style=\"color:#F00\">xxx.crash</a>文件拷贝到同一文件夹中，如：</p>\n<pre><code>~/Desktop/reportAnalysis\n</code></pre><h4 id=\"5-通过symbolicatecrash分析crash文件\"><a href=\"#5-通过symbolicatecrash分析crash文件\" class=\"headerlink\" title=\"5. 通过symbolicatecrash分析crash文件\"></a>5. 通过symbolicatecrash分析crash文件</h4><p>Xcode有自带的symbolicatecrash工具,可以通过dSYM文件将crash文件中的16进制地址转换成可读的函数地址。symbolicatecrash工具位于:</p>\n<pre><code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKit.framework/Versions/A/Resources/symbolicatecrash(Xcode 4.5)\n\n/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKitBase.framework/Versions/A/Resources/symbolicatecrash(Xcode 5.0,Xcode 6.0)\n\n/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash(Xcode 7.0)\n</code></pre><p>该文件是隐藏文件，可以通过如下命令查找并拷贝到系统目录下，并建立快捷方式。</p>\n<h6 id=\"5-1-打开终端，进入到symbolicatecrash工具所在的文件夹目录\"><a href=\"#5-1-打开终端，进入到symbolicatecrash工具所在的文件夹目录\" class=\"headerlink\" title=\"5.1 打开终端，进入到symbolicatecrash工具所在的文件夹目录\"></a>5.1 打开终端，进入到symbolicatecrash工具所在的文件夹目录</h6><pre><code>cd /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKitBase.framework/Versions/A/Resources/\n</code></pre><p><br></p>\n<h6 id=\"5-2-查找确认是否存在symbolicatecrash\"><a href=\"#5-2-查找确认是否存在symbolicatecrash\" class=\"headerlink\" title=\"5.2 查找确认是否存在symbolicatecrash\"></a>5.2 查找确认是否存在symbolicatecrash</h6><pre><code>ls -al | grep symbolicatecrash\n</code></pre><h6 id=\"5-3-将symbolicatecrash工具拷贝到-usr-bin目录下或者讲symbolicatecrash拷贝到reportAnalysis文件夹内\"><a href=\"#5-3-将symbolicatecrash工具拷贝到-usr-bin目录下或者讲symbolicatecrash拷贝到reportAnalysis文件夹内\" class=\"headerlink\" title=\"5.3 将symbolicatecrash工具拷贝到/usr/bin目录下或者讲symbolicatecrash拷贝到reportAnalysis文件夹内\"></a>5.3 将symbolicatecrash工具拷贝到/usr/bin目录下或者讲symbolicatecrash拷贝到reportAnalysis文件夹内</h6><pre><code>sudo cp symbolicatecrash /usr/bin/symbolicatecrash\n</code></pre><p>or</p>\n<pre><code>sudo cp symbolicatecrash ~/Desktop/reportAnalysis\n</code></pre><h6 id=\"5-4-设置DEVELOPER-DIR系统变量\"><a href=\"#5-4-设置DEVELOPER-DIR系统变量\" class=\"headerlink\" title=\"5.4 设置DEVELOPER_DIR系统变量\"></a>5.4 设置DEVELOPER_DIR系统变量</h6><pre><code>cd ~/\n\nvi .bash_profile\n</code></pre><p>并输入如下内容</p>\n<pre><code>export DEVELOPER_DIR=&quot;/Applications/Xcode.app/Contents/Developer&quot;\n</code></pre><p>保存并退出</p>\n<pre><code>source .bash_profile\n</code></pre><h6 id=\"5-5-重启终端，确认是否已正确设置DEVELOPER-DIR系统变量\"><a href=\"#5-5-重启终端，确认是否已正确设置DEVELOPER-DIR系统变量\" class=\"headerlink\" title=\"5.5 重启终端，确认是否已正确设置DEVELOPER_DIR系统变量\"></a>5.5 重启终端，确认是否已正确设置DEVELOPER_DIR系统变量</h6><pre><code>echo $DEVELOPER_DIR\n</code></pre><p>查看输出结果是否为/Applications/Xcode.app/Contents/Developer</p>\n<h6 id=\"5-6-查看PATH系统变量是否存在如下路径-usr-bin\"><a href=\"#5-6-查看PATH系统变量是否存在如下路径-usr-bin\" class=\"headerlink\" title=\"5.6 查看PATH系统变量是否存在如下路径/usr/bin\"></a>5.6 查看PATH系统变量是否存在如下路径/usr/bin</h6><pre><code>echo $PATH\n</code></pre><h6 id=\"5-7-如果PATH不存在如下路径-usr-bin，可在-bash-profile中添加如下代码\"><a href=\"#5-7-如果PATH不存在如下路径-usr-bin，可在-bash-profile中添加如下代码\" class=\"headerlink\" title=\"5.7 如果PATH不存在如下路径/usr/bin，可在~/.bash_profile中添加如下代码\"></a>5.7 如果PATH不存在如下路径/usr/bin，可在~/.bash_profile中添加如下代码</h6><pre><code>export PATH=&quot;/usr/bin:$PATH&quot;\n</code></pre><p>保存并退出</p>\n<pre><code>source .bash_profile\n</code></pre><h6 id=\"5-8-上述准备工作完成后，进入dSYM和crash文件对应的文件夹目录，如\"><a href=\"#5-8-上述准备工作完成后，进入dSYM和crash文件对应的文件夹目录，如\" class=\"headerlink\" title=\"5.8 上述准备工作完成后，进入dSYM和crash文件对应的文件夹目录，如\"></a>5.8 上述准备工作完成后，进入dSYM和crash文件对应的文件夹目录，如</h6><pre><code>cd ~/Desktop/DebugLog\n</code></pre><h6 id=\"5-9-执行如下命令，即可正确解析crash文件\"><a href=\"#5-9-执行如下命令，即可正确解析crash文件\" class=\"headerlink\" title=\"5.9 执行如下命令，即可正确解析crash文件\"></a>5.9 执行如下命令，即可正确解析crash文件</h6><pre><code>symbolicatecrash xxx.crash xxx.app.dSYM &gt; test.txt\n</code></pre><p><a style=\"color:#F00\">注意：symbolicatecrash的参数顺序，否则会报类似如下错误:</a></p>\n<pre><code>Use of uninitialized value $data in substitution (s///) at /usr/bin/symbolicatecrash line 678.&lt;br/&gt;\nUse of uninitialized value $data in substitution (s///) at /usr/bin/symbolicatecrash line 681.&lt;br/&gt;\nUse of uninitialized value $data in substitution (s///) at /usr/bin/symbolicatecrash line 685.&lt;br/&gt;\nUse of uninitialized value in pattern match (m//) at /usr/bin/symbolicatecrash line 404.&lt;br/&gt;\nUse of uninitialized value in scalar assignment at /usr/bin/symbolicatecrash line 418.&lt;br/&gt;\nNo crash report version in XXX.app.dSYM/ at /usr/bin/symbolicatecrash line 954.\n</code></pre><blockquote>\n<p>参考：<a href=\"http://blog.csdn.net/hjy_x/article/details/20929095\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/hjy_x/article/details/20929095</a></p>\n</blockquote>\n","excerpt":"","more":"<p>在项目开发过程中，对于已经上线的App有时会莫名其秒的Crash，切这些Crash在Xcode上是无法复现，导致了我们无法通过Xcode进行调试。还好Device能够记录这些crash日志，我们可用通过Xcode导出这些日志，但是这些日志记录的内容却令人头疼了，我们根据日志的内容（全是些地址信息）无法定位到代码的哪一行产生的错误，我们就需要dSYM文件来帮我们定位分析Crash log了。<br/></p>\n<h3 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h3><h4 id=\"1-导出错误日志\"><a href=\"#1-导出错误日志\" class=\"headerlink\" title=\"1. 导出错误日志\"></a>1. 导出错误日志</h4><p>通过Xcode的Organizer查看设备的Logs，并把你要查看的Log导出到文件夹reportAnalysis,命名app.crash <br/></p>\n<h4 id=\"2-导出App的可执行文件\"><a href=\"#2-导出App的可执行文件\" class=\"headerlink\" title=\"2. 导出App的可执行文件\"></a>2. 导出App的可执行文件</h4><p>找到该App当前版本的ipa文件，解压后得到Payload文件夹，并把xxx.app复制到reportAnalysis<br/></p>\n<h4 id=\"3-导出App对应build版本的dSYM文件\"><a href=\"#3-导出App对应build版本的dSYM文件\" class=\"headerlink\" title=\"3. 导出App对应build版本的dSYM文件\"></a>3. 导出App对应build版本的dSYM文件</h4><p>dSYM文件可通过Xcode的Organizer找到对应build版本，右键<em>show in finder</em>，并显示该版本的b包内容，文件夹dSYMs内就是该App的dSYM文件，把xxx.app.dSYM文件拷贝到reportAnalysis<br/></p>\n<h4 id=\"4-确定dSYM，app和Crash文件的关系\"><a href=\"#4-确定dSYM，app和Crash文件的关系\" class=\"headerlink\" title=\"4. 确定dSYM，app和Crash文件的关系\"></a>4. 确定dSYM，app和Crash文件的关系</h4><p>每一个xx.app, xxx.app.dSYM文件都拥有相应的uuid，crash文件也有uuid,只有三者uuid一至才表明之三者可以解析出正确的日志文件。<br>查看xx.app文件的uuid的方法，在terminal中输入命令：</p>\n<pre><code>dwarfdump --uuid xxx.app/xxx (xxx工程名)\n</code></pre><p>查看xx.app.dSYM文件的uuid的方法，在terminal中输入命令：</p>\n<pre><code>dwarfdump --uuid xxx.app.dSYM (xxx工程名) \n</code></pre><p>而.crash的uuid位于，crash日志中的Binary Images:中的第一行。如：</p>\n<pre><code>armv7 &lt;8bdeaf1a0b233ac199728c2a0ebb4165&gt; \n</code></pre><p>对应的<a style=\"color:#F00\">xxx.app.dSYM</a>文件以及<a style=\"color:#F00\">xxx.app</a>文件以及<a style=\"color:#F00\">xxx.crash</a>文件拷贝到同一文件夹中，如：</p>\n<pre><code>~/Desktop/reportAnalysis\n</code></pre><h4 id=\"5-通过symbolicatecrash分析crash文件\"><a href=\"#5-通过symbolicatecrash分析crash文件\" class=\"headerlink\" title=\"5. 通过symbolicatecrash分析crash文件\"></a>5. 通过symbolicatecrash分析crash文件</h4><p>Xcode有自带的symbolicatecrash工具,可以通过dSYM文件将crash文件中的16进制地址转换成可读的函数地址。symbolicatecrash工具位于:</p>\n<pre><code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKit.framework/Versions/A/Resources/symbolicatecrash(Xcode 4.5)\n\n/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKitBase.framework/Versions/A/Resources/symbolicatecrash(Xcode 5.0,Xcode 6.0)\n\n/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash(Xcode 7.0)\n</code></pre><p>该文件是隐藏文件，可以通过如下命令查找并拷贝到系统目录下，并建立快捷方式。</p>\n<h6 id=\"5-1-打开终端，进入到symbolicatecrash工具所在的文件夹目录\"><a href=\"#5-1-打开终端，进入到symbolicatecrash工具所在的文件夹目录\" class=\"headerlink\" title=\"5.1 打开终端，进入到symbolicatecrash工具所在的文件夹目录\"></a>5.1 打开终端，进入到symbolicatecrash工具所在的文件夹目录</h6><pre><code>cd /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKitBase.framework/Versions/A/Resources/\n</code></pre><p><br/></p>\n<h6 id=\"5-2-查找确认是否存在symbolicatecrash\"><a href=\"#5-2-查找确认是否存在symbolicatecrash\" class=\"headerlink\" title=\"5.2 查找确认是否存在symbolicatecrash\"></a>5.2 查找确认是否存在symbolicatecrash</h6><pre><code>ls -al | grep symbolicatecrash\n</code></pre><h6 id=\"5-3-将symbolicatecrash工具拷贝到-usr-bin目录下或者讲symbolicatecrash拷贝到reportAnalysis文件夹内\"><a href=\"#5-3-将symbolicatecrash工具拷贝到-usr-bin目录下或者讲symbolicatecrash拷贝到reportAnalysis文件夹内\" class=\"headerlink\" title=\"5.3 将symbolicatecrash工具拷贝到/usr/bin目录下或者讲symbolicatecrash拷贝到reportAnalysis文件夹内\"></a>5.3 将symbolicatecrash工具拷贝到/usr/bin目录下或者讲symbolicatecrash拷贝到reportAnalysis文件夹内</h6><pre><code>sudo cp symbolicatecrash /usr/bin/symbolicatecrash\n</code></pre><p>or</p>\n<pre><code>sudo cp symbolicatecrash ~/Desktop/reportAnalysis\n</code></pre><h6 id=\"5-4-设置DEVELOPER-DIR系统变量\"><a href=\"#5-4-设置DEVELOPER-DIR系统变量\" class=\"headerlink\" title=\"5.4 设置DEVELOPER_DIR系统变量\"></a>5.4 设置DEVELOPER_DIR系统变量</h6><pre><code>cd ~/\n\nvi .bash_profile\n</code></pre><p>并输入如下内容</p>\n<pre><code>export DEVELOPER_DIR=&quot;/Applications/Xcode.app/Contents/Developer&quot;\n</code></pre><p>保存并退出</p>\n<pre><code>source .bash_profile\n</code></pre><h6 id=\"5-5-重启终端，确认是否已正确设置DEVELOPER-DIR系统变量\"><a href=\"#5-5-重启终端，确认是否已正确设置DEVELOPER-DIR系统变量\" class=\"headerlink\" title=\"5.5 重启终端，确认是否已正确设置DEVELOPER_DIR系统变量\"></a>5.5 重启终端，确认是否已正确设置DEVELOPER_DIR系统变量</h6><pre><code>echo $DEVELOPER_DIR\n</code></pre><p>查看输出结果是否为/Applications/Xcode.app/Contents/Developer</p>\n<h6 id=\"5-6-查看PATH系统变量是否存在如下路径-usr-bin\"><a href=\"#5-6-查看PATH系统变量是否存在如下路径-usr-bin\" class=\"headerlink\" title=\"5.6 查看PATH系统变量是否存在如下路径/usr/bin\"></a>5.6 查看PATH系统变量是否存在如下路径/usr/bin</h6><pre><code>echo $PATH\n</code></pre><h6 id=\"5-7-如果PATH不存在如下路径-usr-bin，可在-bash-profile中添加如下代码\"><a href=\"#5-7-如果PATH不存在如下路径-usr-bin，可在-bash-profile中添加如下代码\" class=\"headerlink\" title=\"5.7 如果PATH不存在如下路径/usr/bin，可在~/.bash_profile中添加如下代码\"></a>5.7 如果PATH不存在如下路径/usr/bin，可在~/.bash_profile中添加如下代码</h6><pre><code>export PATH=&quot;/usr/bin:$PATH&quot;\n</code></pre><p>保存并退出</p>\n<pre><code>source .bash_profile\n</code></pre><h6 id=\"5-8-上述准备工作完成后，进入dSYM和crash文件对应的文件夹目录，如\"><a href=\"#5-8-上述准备工作完成后，进入dSYM和crash文件对应的文件夹目录，如\" class=\"headerlink\" title=\"5.8 上述准备工作完成后，进入dSYM和crash文件对应的文件夹目录，如\"></a>5.8 上述准备工作完成后，进入dSYM和crash文件对应的文件夹目录，如</h6><pre><code>cd ~/Desktop/DebugLog\n</code></pre><h6 id=\"5-9-执行如下命令，即可正确解析crash文件\"><a href=\"#5-9-执行如下命令，即可正确解析crash文件\" class=\"headerlink\" title=\"5.9 执行如下命令，即可正确解析crash文件\"></a>5.9 执行如下命令，即可正确解析crash文件</h6><pre><code>symbolicatecrash xxx.crash xxx.app.dSYM &gt; test.txt\n</code></pre><p><a style=\"color:#F00\">注意：symbolicatecrash的参数顺序，否则会报类似如下错误:</a></p>\n<pre><code>Use of uninitialized value $data in substitution (s///) at /usr/bin/symbolicatecrash line 678.&lt;br/&gt;\nUse of uninitialized value $data in substitution (s///) at /usr/bin/symbolicatecrash line 681.&lt;br/&gt;\nUse of uninitialized value $data in substitution (s///) at /usr/bin/symbolicatecrash line 685.&lt;br/&gt;\nUse of uninitialized value in pattern match (m//) at /usr/bin/symbolicatecrash line 404.&lt;br/&gt;\nUse of uninitialized value in scalar assignment at /usr/bin/symbolicatecrash line 418.&lt;br/&gt;\nNo crash report version in XXX.app.dSYM/ at /usr/bin/symbolicatecrash line 954.\n</code></pre><blockquote>\n<p>参考：<a href=\"http://blog.csdn.net/hjy_x/article/details/20929095\">http://blog.csdn.net/hjy_x/article/details/20929095</a></p>\n</blockquote>\n"},{"title":"Hexo 配置说明","date":"2016-05-19T04:16:49.000Z","language":"zh-CN","_content":"\n# Hexo的配置\n### 目录和文件\n\n1. scaffolds：模板文件夹，新建文章时，Hexo 会根据 scaffold 来建立文件。Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径。新建文件的默认布局是post，可以在配置文件中更改布局。用draft布局生成的文件会被保存到 source/_drafts 文件夹。 \n2. source：资源文件夹是存放用户资源的地方。 \n3. source/_post：文件箱。（低版本的hexo还会存在一个_draft，这是草稿箱）除 posts 文件夹之外，开头命名为 (下划线)的文件/ 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去 \n4. themes：主题 文件夹。Hexo 会根据主题来生成静态页面。 \n5. themes/landscape：默认的皮肤文件夹 \n6. _config.yml：全局的配置文件，每次更改要重启服务。\n<br/><br/>低版本的Hexo还会生成scripts文件夹，里面用于保存扩展Hexo的脚本文件。<br/>\n\n### 全局配置\n可以在_config.yml 中修改：<br/>\n```{bash}\n\n\t# Hexo Configuration\n\t## Docs: http://hexo.io/docs/configuration.html\n\t## Source: https://github.com/hexojs/hexo/\n\t# Site 站点配置\n\ttitle: Hexo-demo  #网站标题\n\tsubtitle: hexo is simple and easy to study   #网站副标题\n\tdescription: this is hexo-demo #网栈描述\n\tauthor: pomy #你的名字\n\tlanguage:  zh-CN #网站使用的语言\n\ttimezone: Asia/Shanghai  #网站时区\n\t\n\t# URL #可以不用配置\n\t## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\n\turl: http://yoursite.com #网址，搜索时会在搜索引擎中显示\n\troot: /  #网站根目录\n\tpermalink: :year/:month/:day/:title/ #永久链接格式\n\tpermalink_defaults: #永久链接中各部分的默认值\n\t\n\t# Directory 目录配置\n\tsource_dir: source #资源文件夹，这个文件夹用来存放内容\n\tpublic_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件\n\ttag_dir: tags #标签文件夹\n\tarchive_dir: archives #归档文件夹\n\tcategory_dir: categories #分类文件夹\n\tcode_dir: downloads/code #Include code 文件夹\n\ti18n_dir: :lang   #国际化文件夹\n\tskip_render:      #跳过指定文件的渲染，您可使用 glob 来配置路径\n\t\n\t# Writing 写作配置\n\tnew_post_name: :title.md # 新文章的文件名称\n\tdefault_layout: post   #默认布局\n\ttitlecase: false # Transform title into titlecase\n\texternal_link: true # Open external links in new tab\n\tfilename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写\n\trender_drafts: false #显示草稿\n\tpost_asset_folder: false #是否启动资源文件夹\n\trelative_link: false #把链接改为与根目录的相对位址\n\tfuture: true  \n\thighlight:  \n\t#代码块的设置\n\tenable: true\n\tline_number: true\n\tauto_detect: true\n\ttab_replace:\n\t\n\t# Category & Tag 分类 & 标签\n\tdefault_category: uncategorized #默认分类\n\tcategory_map:   #分类别名   \n\ttag_map:        #标签别名\n\t\n\t# Date / Time format  时间和日期\n\t## Hexo uses Moment.js to parse and display date\n\t## You can customize the date format as defined in\n\t## http://momentjs.com/docs/#/displaying/format/\n\tdate_format: YYYY-MM-DD\n\ttime_format: HH:mm:ss\n\t\n\t# Pagination 分页\n\t## Set per_page to 0 to disable pagination\n\tper_page: 10 #每页显示的文章量 (0 = 关闭分页功能)\n\tpagination_dir: page #分页目录\n\t\n\t# Extensions 扩展\n\t## Plugins: http://hexo.io/plugins/ 插件\n\t## Themes: http://hexo.io/themes/  主题\n\ttheme: landscape #当前主题名称\n\t\n\t# Deployment #部署到github\n\t## Docs: http://hexo.io/docs/deployment.html\n\tdeploy:\n\t  type:\n```\n\n一般主题下有一个 languages 文件夹，用于对应 language 配置项。 比如在 ejs 中有：<br/>\n\n\t\"<%= __('tags') %>：\n\t\nlanguage 的配置项是 zh-CN，则会在languages 文件夹下找到 zh-CN.yml 文件中对应的项来解释。<br/>\n修改全局配置时，注意缩进，同时注意冒号后面要有一个空格。<br/>\n\n\n### 主题配置\n主题的配置文件在`/themes/主题文件夹/_config.yml`，一般包括导航配置(menu)，内容配置(content)，评论插件，图片效果(fancybox)和边栏(sidebar)。<br/>\n\nHexo提高了大量的主题，可以在全局配置文件中更改主题：<br/>\n\n\t# Extensions 扩展\n\t## Plugins: http://hexo.io/plugins/ 插件\n\t## Themes: http://hexo.io/themes/  主题\n\ttheme: 你的主题名称\n\n\n#### 基本使用\n\n写文章 \n通过new命令新建一篇文章：\n\t\n\t$ hexo new [layout] <title>\n\t//same as\n\thexo n\n\t\n其中layout是可选参数，默认值为post。\n\n如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，需用引号括起来。\nHexo提供的layout在scaffolds目录下，也可以在此目录下自建layout文件。新建的文件则会保存到source/_post目录下。\n\n\n然后启动服务器，便能看到刚刚发表的文章\n\n发表的文章会全部显示，如果文章很长，就只要显示文章的摘要就行了。在需要显示摘要的地方添加如下代码即可：\n\t\n\t以上是摘要\n\t<!--more-->\n\t以下是余下全文\n\n\n原文：http://www.ido321.com/1650.html","source":"_posts/hexo.md","raw":"---\ntitle: Hexo 配置说明\ndate: 2016-05-19 12:16:49\ntags: [Hexo]\nlanguage: zh-CN\n\n\n---\n\n# Hexo的配置\n### 目录和文件\n\n1. scaffolds：模板文件夹，新建文章时，Hexo 会根据 scaffold 来建立文件。Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径。新建文件的默认布局是post，可以在配置文件中更改布局。用draft布局生成的文件会被保存到 source/_drafts 文件夹。 \n2. source：资源文件夹是存放用户资源的地方。 \n3. source/_post：文件箱。（低版本的hexo还会存在一个_draft，这是草稿箱）除 posts 文件夹之外，开头命名为 (下划线)的文件/ 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去 \n4. themes：主题 文件夹。Hexo 会根据主题来生成静态页面。 \n5. themes/landscape：默认的皮肤文件夹 \n6. _config.yml：全局的配置文件，每次更改要重启服务。\n<br/><br/>低版本的Hexo还会生成scripts文件夹，里面用于保存扩展Hexo的脚本文件。<br/>\n\n### 全局配置\n可以在_config.yml 中修改：<br/>\n```{bash}\n\n\t# Hexo Configuration\n\t## Docs: http://hexo.io/docs/configuration.html\n\t## Source: https://github.com/hexojs/hexo/\n\t# Site 站点配置\n\ttitle: Hexo-demo  #网站标题\n\tsubtitle: hexo is simple and easy to study   #网站副标题\n\tdescription: this is hexo-demo #网栈描述\n\tauthor: pomy #你的名字\n\tlanguage:  zh-CN #网站使用的语言\n\ttimezone: Asia/Shanghai  #网站时区\n\t\n\t# URL #可以不用配置\n\t## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\n\turl: http://yoursite.com #网址，搜索时会在搜索引擎中显示\n\troot: /  #网站根目录\n\tpermalink: :year/:month/:day/:title/ #永久链接格式\n\tpermalink_defaults: #永久链接中各部分的默认值\n\t\n\t# Directory 目录配置\n\tsource_dir: source #资源文件夹，这个文件夹用来存放内容\n\tpublic_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件\n\ttag_dir: tags #标签文件夹\n\tarchive_dir: archives #归档文件夹\n\tcategory_dir: categories #分类文件夹\n\tcode_dir: downloads/code #Include code 文件夹\n\ti18n_dir: :lang   #国际化文件夹\n\tskip_render:      #跳过指定文件的渲染，您可使用 glob 来配置路径\n\t\n\t# Writing 写作配置\n\tnew_post_name: :title.md # 新文章的文件名称\n\tdefault_layout: post   #默认布局\n\ttitlecase: false # Transform title into titlecase\n\texternal_link: true # Open external links in new tab\n\tfilename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写\n\trender_drafts: false #显示草稿\n\tpost_asset_folder: false #是否启动资源文件夹\n\trelative_link: false #把链接改为与根目录的相对位址\n\tfuture: true  \n\thighlight:  \n\t#代码块的设置\n\tenable: true\n\tline_number: true\n\tauto_detect: true\n\ttab_replace:\n\t\n\t# Category & Tag 分类 & 标签\n\tdefault_category: uncategorized #默认分类\n\tcategory_map:   #分类别名   \n\ttag_map:        #标签别名\n\t\n\t# Date / Time format  时间和日期\n\t## Hexo uses Moment.js to parse and display date\n\t## You can customize the date format as defined in\n\t## http://momentjs.com/docs/#/displaying/format/\n\tdate_format: YYYY-MM-DD\n\ttime_format: HH:mm:ss\n\t\n\t# Pagination 分页\n\t## Set per_page to 0 to disable pagination\n\tper_page: 10 #每页显示的文章量 (0 = 关闭分页功能)\n\tpagination_dir: page #分页目录\n\t\n\t# Extensions 扩展\n\t## Plugins: http://hexo.io/plugins/ 插件\n\t## Themes: http://hexo.io/themes/  主题\n\ttheme: landscape #当前主题名称\n\t\n\t# Deployment #部署到github\n\t## Docs: http://hexo.io/docs/deployment.html\n\tdeploy:\n\t  type:\n```\n\n一般主题下有一个 languages 文件夹，用于对应 language 配置项。 比如在 ejs 中有：<br/>\n\n\t\"<%= __('tags') %>：\n\t\nlanguage 的配置项是 zh-CN，则会在languages 文件夹下找到 zh-CN.yml 文件中对应的项来解释。<br/>\n修改全局配置时，注意缩进，同时注意冒号后面要有一个空格。<br/>\n\n\n### 主题配置\n主题的配置文件在`/themes/主题文件夹/_config.yml`，一般包括导航配置(menu)，内容配置(content)，评论插件，图片效果(fancybox)和边栏(sidebar)。<br/>\n\nHexo提高了大量的主题，可以在全局配置文件中更改主题：<br/>\n\n\t# Extensions 扩展\n\t## Plugins: http://hexo.io/plugins/ 插件\n\t## Themes: http://hexo.io/themes/  主题\n\ttheme: 你的主题名称\n\n\n#### 基本使用\n\n写文章 \n通过new命令新建一篇文章：\n\t\n\t$ hexo new [layout] <title>\n\t//same as\n\thexo n\n\t\n其中layout是可选参数，默认值为post。\n\n如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，需用引号括起来。\nHexo提供的layout在scaffolds目录下，也可以在此目录下自建layout文件。新建的文件则会保存到source/_post目录下。\n\n\n然后启动服务器，便能看到刚刚发表的文章\n\n发表的文章会全部显示，如果文章很长，就只要显示文章的摘要就行了。在需要显示摘要的地方添加如下代码即可：\n\t\n\t以上是摘要\n\t<!--more-->\n\t以下是余下全文\n\n\n原文：http://www.ido321.com/1650.html","slug":"hexo","published":1,"updated":"2016-06-22T08:18:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzbicfz000esiftc173l0xy","content":"<h1 id=\"Hexo的配置\"><a href=\"#Hexo的配置\" class=\"headerlink\" title=\"Hexo的配置\"></a>Hexo的配置</h1><h3 id=\"目录和文件\"><a href=\"#目录和文件\" class=\"headerlink\" title=\"目录和文件\"></a>目录和文件</h3><ol>\n<li>scaffolds：模板文件夹，新建文章时，Hexo 会根据 scaffold 来建立文件。Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径。新建文件的默认布局是post，可以在配置文件中更改布局。用draft布局生成的文件会被保存到 source/_drafts 文件夹。 </li>\n<li>source：资源文件夹是存放用户资源的地方。 </li>\n<li>source/_post：文件箱。（低版本的hexo还会存在一个_draft，这是草稿箱）除 posts 文件夹之外，开头命名为 (下划线)的文件/ 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去 </li>\n<li>themes：主题 文件夹。Hexo 会根据主题来生成静态页面。 </li>\n<li>themes/landscape：默认的皮肤文件夹 </li>\n<li>_config.yml：全局的配置文件，每次更改要重启服务。<br><br><br>低版本的Hexo还会生成scripts文件夹，里面用于保存扩展Hexo的脚本文件。<br></li>\n</ol>\n<h3 id=\"全局配置\"><a href=\"#全局配置\" class=\"headerlink\" title=\"全局配置\"></a>全局配置</h3><p>可以在_config.yml 中修改：<br><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># Hexo Configuration</span><br><span class=\"line\">## Docs: http://hexo.io/docs/configuration.html</span><br><span class=\"line\">## Source: https://github.com/hexojs/hexo/</span><br><span class=\"line\"># Site 站点配置</span><br><span class=\"line\">title: Hexo-demo  #网站标题</span><br><span class=\"line\">subtitle: hexo is simple and easy to study   #网站副标题</span><br><span class=\"line\">description: this is hexo-demo #网栈描述</span><br><span class=\"line\">author: pomy #你的名字</span><br><span class=\"line\">language:  zh-CN #网站使用的语言</span><br><span class=\"line\">timezone: Asia/Shanghai  #网站时区</span><br><span class=\"line\"></span><br><span class=\"line\"># URL #可以不用配置</span><br><span class=\"line\">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class=\"line\">url: http://yoursite.com #网址，搜索时会在搜索引擎中显示</span><br><span class=\"line\">root: /  #网站根目录</span><br><span class=\"line\">permalink: :year/:month/:day/:title/ #永久链接格式</span><br><span class=\"line\">permalink_defaults: #永久链接中各部分的默认值</span><br><span class=\"line\"></span><br><span class=\"line\"># Directory 目录配置</span><br><span class=\"line\">source_dir: source #资源文件夹，这个文件夹用来存放内容</span><br><span class=\"line\">public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件</span><br><span class=\"line\">tag_dir: tags #标签文件夹</span><br><span class=\"line\">archive_dir: archives #归档文件夹</span><br><span class=\"line\">category_dir: categories #分类文件夹</span><br><span class=\"line\">code_dir: downloads/code #Include code 文件夹</span><br><span class=\"line\">i18n_dir: :lang   #国际化文件夹</span><br><span class=\"line\">skip_render:      #跳过指定文件的渲染，您可使用 glob 来配置路径</span><br><span class=\"line\"></span><br><span class=\"line\"># Writing 写作配置</span><br><span class=\"line\">new_post_name: :title.md # 新文章的文件名称</span><br><span class=\"line\">default_layout: post   #默认布局</span><br><span class=\"line\">titlecase: false # Transform title into titlecase</span><br><span class=\"line\">external_link: true # Open external links in new tab</span><br><span class=\"line\">filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写</span><br><span class=\"line\">render_drafts: false #显示草稿</span><br><span class=\"line\">post_asset_folder: false #是否启动资源文件夹</span><br><span class=\"line\">relative_link: false #把链接改为与根目录的相对位址</span><br><span class=\"line\">future: true  </span><br><span class=\"line\">highlight:  </span><br><span class=\"line\">#代码块的设置</span><br><span class=\"line\">enable: true</span><br><span class=\"line\">line_number: true</span><br><span class=\"line\">auto_detect: true</span><br><span class=\"line\">tab_replace:</span><br><span class=\"line\"></span><br><span class=\"line\"># Category &amp; Tag 分类 &amp; 标签</span><br><span class=\"line\">default_category: uncategorized #默认分类</span><br><span class=\"line\">category_map:   #分类别名   </span><br><span class=\"line\">tag_map:        #标签别名</span><br><span class=\"line\"></span><br><span class=\"line\"># Date / Time format  时间和日期</span><br><span class=\"line\">## Hexo uses Moment.js to parse and display date</span><br><span class=\"line\">## You can customize the date format as defined in</span><br><span class=\"line\">## http://momentjs.com/docs/#/displaying/format/</span><br><span class=\"line\">date_format: YYYY-MM-DD</span><br><span class=\"line\">time_format: HH:mm:ss</span><br><span class=\"line\"></span><br><span class=\"line\"># Pagination 分页</span><br><span class=\"line\">## Set per_page to 0 to disable pagination</span><br><span class=\"line\">per_page: 10 #每页显示的文章量 (0 = 关闭分页功能)</span><br><span class=\"line\">pagination_dir: page #分页目录</span><br><span class=\"line\"></span><br><span class=\"line\"># Extensions 扩展</span><br><span class=\"line\">## Plugins: http://hexo.io/plugins/ 插件</span><br><span class=\"line\">## Themes: http://hexo.io/themes/  主题</span><br><span class=\"line\">theme: landscape #当前主题名称</span><br><span class=\"line\"></span><br><span class=\"line\"># Deployment #部署到github</span><br><span class=\"line\">## Docs: http://hexo.io/docs/deployment.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type:</span><br></pre></td></tr></table></figure></p>\n<p>一般主题下有一个 languages 文件夹，用于对应 language 配置项。 比如在 ejs 中有：<br></p>\n<pre><code>&quot;&lt;%= __(&apos;tags&apos;) %&gt;：\n</code></pre><p>language 的配置项是 zh-CN，则会在languages 文件夹下找到 zh-CN.yml 文件中对应的项来解释。<br><br>修改全局配置时，注意缩进，同时注意冒号后面要有一个空格。<br></p>\n<h3 id=\"主题配置\"><a href=\"#主题配置\" class=\"headerlink\" title=\"主题配置\"></a>主题配置</h3><p>主题的配置文件在<code>/themes/主题文件夹/_config.yml</code>，一般包括导航配置(menu)，内容配置(content)，评论插件，图片效果(fancybox)和边栏(sidebar)。<br></p>\n<p>Hexo提高了大量的主题，可以在全局配置文件中更改主题：<br></p>\n<pre><code># Extensions 扩展\n## Plugins: http://hexo.io/plugins/ 插件\n## Themes: http://hexo.io/themes/  主题\ntheme: 你的主题名称\n</code></pre><h4 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h4><p>写文章<br>通过new命令新建一篇文章：</p>\n<pre><code>$ hexo new [layout] &lt;title&gt;\n//same as\nhexo n\n</code></pre><p>其中layout是可选参数，默认值为post。</p>\n<p>如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，需用引号括起来。<br>Hexo提供的layout在scaffolds目录下，也可以在此目录下自建layout文件。新建的文件则会保存到source/_post目录下。</p>\n<p>然后启动服务器，便能看到刚刚发表的文章</p>\n<p>发表的文章会全部显示，如果文章很长，就只要显示文章的摘要就行了。在需要显示摘要的地方添加如下代码即可：</p>\n<pre><code>以上是摘要\n&lt;!--more--&gt;\n以下是余下全文\n</code></pre><p>原文：<a href=\"http://www.ido321.com/1650.html\" target=\"_blank\" rel=\"external\">http://www.ido321.com/1650.html</a></p>\n","excerpt":"","more":"<h1 id=\"Hexo的配置\"><a href=\"#Hexo的配置\" class=\"headerlink\" title=\"Hexo的配置\"></a>Hexo的配置</h1><h3 id=\"目录和文件\"><a href=\"#目录和文件\" class=\"headerlink\" title=\"目录和文件\"></a>目录和文件</h3><ol>\n<li>scaffolds：模板文件夹，新建文章时，Hexo 会根据 scaffold 来建立文件。Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径。新建文件的默认布局是post，可以在配置文件中更改布局。用draft布局生成的文件会被保存到 source/_drafts 文件夹。 </li>\n<li>source：资源文件夹是存放用户资源的地方。 </li>\n<li>source/_post：文件箱。（低版本的hexo还会存在一个_draft，这是草稿箱）除 posts 文件夹之外，开头命名为 (下划线)的文件/ 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去 </li>\n<li>themes：主题 文件夹。Hexo 会根据主题来生成静态页面。 </li>\n<li>themes/landscape：默认的皮肤文件夹 </li>\n<li>_config.yml：全局的配置文件，每次更改要重启服务。<br><br/><br/>低版本的Hexo还会生成scripts文件夹，里面用于保存扩展Hexo的脚本文件。<br/></li>\n</ol>\n<h3 id=\"全局配置\"><a href=\"#全局配置\" class=\"headerlink\" title=\"全局配置\"></a>全局配置</h3><p>可以在_config.yml 中修改：<br/><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># Hexo Configuration</span><br><span class=\"line\">## Docs: http://hexo.io/docs/configuration.html</span><br><span class=\"line\">## Source: https://github.com/hexojs/hexo/</span><br><span class=\"line\"># Site 站点配置</span><br><span class=\"line\">title: Hexo-demo  #网站标题</span><br><span class=\"line\">subtitle: hexo is simple and easy to study   #网站副标题</span><br><span class=\"line\">description: this is hexo-demo #网栈描述</span><br><span class=\"line\">author: pomy #你的名字</span><br><span class=\"line\">language:  zh-CN #网站使用的语言</span><br><span class=\"line\">timezone: Asia/Shanghai  #网站时区</span><br><span class=\"line\"></span><br><span class=\"line\"># URL #可以不用配置</span><br><span class=\"line\">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class=\"line\">url: http://yoursite.com #网址，搜索时会在搜索引擎中显示</span><br><span class=\"line\">root: /  #网站根目录</span><br><span class=\"line\">permalink: :year/:month/:day/:title/ #永久链接格式</span><br><span class=\"line\">permalink_defaults: #永久链接中各部分的默认值</span><br><span class=\"line\"></span><br><span class=\"line\"># Directory 目录配置</span><br><span class=\"line\">source_dir: source #资源文件夹，这个文件夹用来存放内容</span><br><span class=\"line\">public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件</span><br><span class=\"line\">tag_dir: tags #标签文件夹</span><br><span class=\"line\">archive_dir: archives #归档文件夹</span><br><span class=\"line\">category_dir: categories #分类文件夹</span><br><span class=\"line\">code_dir: downloads/code #Include code 文件夹</span><br><span class=\"line\">i18n_dir: :lang   #国际化文件夹</span><br><span class=\"line\">skip_render:      #跳过指定文件的渲染，您可使用 glob 来配置路径</span><br><span class=\"line\"></span><br><span class=\"line\"># Writing 写作配置</span><br><span class=\"line\">new_post_name: :title.md # 新文章的文件名称</span><br><span class=\"line\">default_layout: post   #默认布局</span><br><span class=\"line\">titlecase: false # Transform title into titlecase</span><br><span class=\"line\">external_link: true # Open external links in new tab</span><br><span class=\"line\">filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写</span><br><span class=\"line\">render_drafts: false #显示草稿</span><br><span class=\"line\">post_asset_folder: false #是否启动资源文件夹</span><br><span class=\"line\">relative_link: false #把链接改为与根目录的相对位址</span><br><span class=\"line\">future: true  </span><br><span class=\"line\">highlight:  </span><br><span class=\"line\">#代码块的设置</span><br><span class=\"line\">enable: true</span><br><span class=\"line\">line_number: true</span><br><span class=\"line\">auto_detect: true</span><br><span class=\"line\">tab_replace:</span><br><span class=\"line\"></span><br><span class=\"line\"># Category &amp; Tag 分类 &amp; 标签</span><br><span class=\"line\">default_category: uncategorized #默认分类</span><br><span class=\"line\">category_map:   #分类别名   </span><br><span class=\"line\">tag_map:        #标签别名</span><br><span class=\"line\"></span><br><span class=\"line\"># Date / Time format  时间和日期</span><br><span class=\"line\">## Hexo uses Moment.js to parse and display date</span><br><span class=\"line\">## You can customize the date format as defined in</span><br><span class=\"line\">## http://momentjs.com/docs/#/displaying/format/</span><br><span class=\"line\">date_format: YYYY-MM-DD</span><br><span class=\"line\">time_format: HH:mm:ss</span><br><span class=\"line\"></span><br><span class=\"line\"># Pagination 分页</span><br><span class=\"line\">## Set per_page to 0 to disable pagination</span><br><span class=\"line\">per_page: 10 #每页显示的文章量 (0 = 关闭分页功能)</span><br><span class=\"line\">pagination_dir: page #分页目录</span><br><span class=\"line\"></span><br><span class=\"line\"># Extensions 扩展</span><br><span class=\"line\">## Plugins: http://hexo.io/plugins/ 插件</span><br><span class=\"line\">## Themes: http://hexo.io/themes/  主题</span><br><span class=\"line\">theme: landscape #当前主题名称</span><br><span class=\"line\"></span><br><span class=\"line\"># Deployment #部署到github</span><br><span class=\"line\">## Docs: http://hexo.io/docs/deployment.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type:</span><br></pre></td></tr></table></figure></p>\n<p>一般主题下有一个 languages 文件夹，用于对应 language 配置项。 比如在 ejs 中有：<br/></p>\n<pre><code>&quot;&lt;%= __(&apos;tags&apos;) %&gt;：\n</code></pre><p>language 的配置项是 zh-CN，则会在languages 文件夹下找到 zh-CN.yml 文件中对应的项来解释。<br/><br>修改全局配置时，注意缩进，同时注意冒号后面要有一个空格。<br/></p>\n<h3 id=\"主题配置\"><a href=\"#主题配置\" class=\"headerlink\" title=\"主题配置\"></a>主题配置</h3><p>主题的配置文件在<code>/themes/主题文件夹/_config.yml</code>，一般包括导航配置(menu)，内容配置(content)，评论插件，图片效果(fancybox)和边栏(sidebar)。<br/></p>\n<p>Hexo提高了大量的主题，可以在全局配置文件中更改主题：<br/></p>\n<pre><code># Extensions 扩展\n## Plugins: http://hexo.io/plugins/ 插件\n## Themes: http://hexo.io/themes/  主题\ntheme: 你的主题名称\n</code></pre><h4 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h4><p>写文章<br>通过new命令新建一篇文章：</p>\n<pre><code>$ hexo new [layout] &lt;title&gt;\n//same as\nhexo n\n</code></pre><p>其中layout是可选参数，默认值为post。</p>\n<p>如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，需用引号括起来。<br>Hexo提供的layout在scaffolds目录下，也可以在此目录下自建layout文件。新建的文件则会保存到source/_post目录下。</p>\n<p>然后启动服务器，便能看到刚刚发表的文章</p>\n<p>发表的文章会全部显示，如果文章很长，就只要显示文章的摘要就行了。在需要显示摘要的地方添加如下代码即可：</p>\n<pre><code>以上是摘要\n&lt;!--more--&gt;\n以下是余下全文\n</code></pre><p>原文：<a href=\"http://www.ido321.com/1650.html\">http://www.ido321.com/1650.html</a></p>\n"},{"title":"iOS面试题总结","date":"2016-06-23T14:52:03.000Z","_content":"\n# 常见的iOS面试题\n由于空闲时间比较喜欢在网上看一些大牛的技术blog，今天刚好看到大牛sunnyxx的一个关于他面试别人时提到的一些常见问题（[原文地址](http://blog.sunnyxx.com/2015/07/04/ios-interview/)），所以自己也就试着回答了一遍，也算时对自己的一次面试吧，通过自己面试时间也发现了一些自己不足的一面，所以今天记录下来，加深一下印象吧。<br/>\n\n<font color=\"red\"><strong>另外这里有一份 [详细答案](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md) 分析的很到位</strong></font>\n\n### [※]@property中有哪些属性关键字？\n在@property 中的关键词个人总结分为三类：RC语意修饰符，线程安全修饰符，读写属性修饰符。\n#### RC语意修饰符\n这类修饰符主要为了在ARC或者MRC下一个属性的内存管理方法，共如下几种：<br/>\n`assign`： 简单的赋值，不会改变引用计数，共享内存；一般用于基本类型（c/c++：int float等，OC:NSInteger,BOOL等）<br/>\n`retain`： 处理简单赋值外会对赋值对象的引用计数加1操作，用于OC对象；<br/>\n`copy`：处理简单赋值，但是赋值对象引用计数不变，被赋值对象引用计数为1，也就是新生成一个与被赋值对象一样的数据（非绝对 如NSArray对象）<br/>\n`unsafe_unretained`：简单赋值，与assign相似，多用于修饰OC对象，只是表显该对象是不安全的（当赋值对象变为nil的时候会引起crash 野指针问题）<br/>\n`strong`：ARC中简单赋值，与非ARC下的retain相同作用<br/>\n`weak`：ARC中简单赋值，与非ARC下的assign对应，但是又有不同，weak多用于修饰OC对象，且当改对象的引用计数为0的时候，改对象会被修改成nil，而assign则不会，好处时能有效的防止野指针<br/>\n\n#### 线程安全修饰符\n这类修饰符主要是指定属性赋值操作的线程安全性<br/>\n`atomic`：线程安全的，多线程访问情况下只有一个线程能访问他，影响访问速度<br/>\n`nonatomic`：非线程安全的，多线程可同时读写，容易造成混乱，但读写速度快<br/>\n\n#### 读写属性修饰符\n这类修饰符主要控制属性的读写权限<br/>\n`readonly`: 编译器只会对该属性生成get方法<br/>\n`readwrite`: 编译器能生成get/set方法，默认此属性<br/>\n另外get方法可以在修饰符最后指定，比如：`@property(getter = isGirl) BOOL girl`\n\n### [*]怎么用 copy 关键字？\n1. NSString，NSArray，NSDictionary类型属性常用，因为它们有NSMutableString,NSMutableArray,NSMutableDictionary类型属性，当我们不想外界干扰我们正在操作的这类型属性的时候，我们会把她们设置成copy。\n2. 在使用block的时候我们用copy，在MRC时代，block是创建在栈上的，所以当我们把block进行赋值时不进行copy操作的话，block内的变量会因为栈的pop而造成野指针，从而引起crash。当然在ARC下，block会自动进行copy，但是作为程序员团队协作开发，能明确让别人看到block是经过copy到堆上的对象则更加具有易读性。\n### [*]这个写法会出什么问题： @property (copy) NSMutableArray *array;\n1. 把NSMutableArray 属性设置成copy，无论赋值对象是NSArray还是NSMutableArray赋值后array指向的是NSArray对象，但我们往往会因为array的声明NSMutableArray＊ 而把它当成一个可变对象来操作，一旦调用了array的[array removeAtIndex:n],等不属于NSArray的方法后会引起Crash。\n2. 属性修饰符没有加nonatomic，那么array会被编译器默认设置为atomic，atomic表示该属性是原则性操作，每次setter都会加锁来确保它的原子性，这将耗费大量运算。\n\n### [*]如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？\n\n想要自己的类能够使用copy修饰符则必须让自己的类实现NSCopying协议，如果自己的类像NSString那样大小有可变版本和不可变版本，那么就是实现NSCopying协议和NSMutalbeCopying协议。\n\n具体步骤：\n1. 声明该类遵从NSCopying协议。\n2. 在该类中实现下面方法,并且注意对象copy是否需要深拷贝操作。\n\t\n\t- (id)copyWithZone:(NSZone *)zone;\n\t\n至于重写带copy关键字的setter的话一般如下：\n\n\t- (void)setCustomClass:(CustomClass *)customClass\n\t{\n\t\t_customClass = [customClass copy];\n\t}\n但是由于遵循NSCopying协议的类一般都是用作只读属性，所以我们就不去实现setter方法，而是在类initializer的时候对其进行初始化。例如：\n\t\n\t- (instancetype)initWithCustomClass:(CustomClass *)cClass\n\t{\n\t\tif(self == [super init]){\n\t\t\t_cClass = [cClass copy];\n\t\t}\n\t\treturn self;\n\t}\n\t\n\n### [*]@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的?\n<font color=\"red\" size=\"5px\"><strong>此为盗取答案：</strong></font>\n#### @property 的本质是什么？\n> @property = (ivar + getter + setter)\n> “属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。\n\n“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 Objective-C 2.0 的一部分。 而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。 正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:\n\n> 编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。 所以你也可以这么说：\n> @property = getter + setter;\n\n#### ivar、getter、setter 是如何生成并添加到这个类中的?\n\n> “自动合成”( autosynthesis)\n> 完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字.\n\n\t@implementation Person\n\t@synthesize firstName = _myFirstName;\n\t@synthesize lastName = _myLastName;\n\t@end\n\t\n> 我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西\n\n> 1. OBJC_IVAR_$类名$属性名称 ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，\n> 2. 表示该变量距离存放对象的内存区域的起始地址有多远。\n> 3. setter 与 getter 方法对应的实现函数\n> 4. ivar_list ：成员变量列表\n> 5. method_list ：方法列表\n> 6. prop_list ：属性列表\n> \n> 也就是说我们每次在增加一个属性,系统都会在 ivar_list 中添加一个成员变量的描述,在 method_list 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.\n\n### [*]@protocol 和 category 中如何使用 @property ?\n\n`@property`是封装数据的方式，我们一般不再`@protocol`和`category`中使用`@property`，而是在`class_continuation分类`中, 查看OC源码我们知道objc_struct结构中，成员变量的偏移量是放到`ivar_list`中的，是指针加偏移量来进行寻址操作的,OC把实例变量当作一种存储偏移量所用的“特殊变量”，并交由“类对象”来管理，偏移量会在运行时进行查找，如果类的定义变了，那么存储的偏移量也就变了，这样的话，无论何时访问实例变量，总能使用正确的偏移量，也就是说这些偏移量是是在编译时期生成的，所以不能在运行时期向类内加入实例变量。这和方法列表`method_list`不同的是，方法列表中结构中存的不是偏移量，而是方法指针的指针，也就是说每个方法我们可以修改其实现为任意实现地址。<br/>\n虽然我们不能通过在`@protocol`和`category`中添加实例变量，但是我们可以通过`@property`+`@dynamic`+`关联`来达到新增实例相同的结果。\n\n> 参考资料：https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html\n\n\n\n1. 在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性\n2. category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 \ncategory 增加属性的实现,需要借助于运行时的两个函数：\n\n\tobjc_setAssociatedObject\n\tobjc_getAssociatedObject\n\nRuntime给我们提供了这两个方法来达到这个目的，这些关联是通过一个`AssociationsManager`实例维护一个哈西列表`AssociationsHashMap`实现的。\n\n### [※]weak属性需要在dealloc中置nil么？\n不需要，因为被weak修饰符修饰的属性当其引用计数为0的时候，自动引用计数器会自动把属性设置为nil\n\n### [※※]@synthesize和@dynamic分别有什么作用？\n\n`@synthesize`: 该修饰符告诉编译器在编译期自动为该属性生成getter/setter方法，并可指明该属性对应的成员变量。\n`@dynamic`: 告诉编译器，不自动生成getter/setter方法，避免编译期间产生警告,然后由自己实现存取方法或存取方法在运行时动态创建绑定：主要使用在CoreData的实现NSManagedObject子类时使用，由Core Data框架在程序运行的时动态生成子类属性\n### [※※※]ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？\n内存管理默认`strong`,  原子性默认`atomic`,读写性默认`readwrite`;\n### [※※※]用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？\n对源头是NSMutableString的字符串，strong仅仅是指针引用，增加了引用计数器，这样源头改变的时候，用这种strong方式声明的变量（无论被赋值的变量是可变的还是不可变的），它也会跟着改变;而copy声明的变量，它不会跟着源头改变，它实际上是深拷贝的“备份”。<br/>\n对源头是NSString的字符串，无论是strong声明的变量还是copy声明的变量，当第二次源头的字符串重新指向其它的地方的时候，它还是指向原来的最初的那个位置（因为常量字符串分配在一个常量内存区），也就是说其实二者都是指针引用，也就是浅拷贝。<br/>\n\n而对于NSMutableArray和NSMutableDictionary情况是和NSMutableString是一样的，strong情况下是传引用，并且引用计数加1，copy情况下是产生一个深拷贝“备份”，并且这个备份变成了一个不可变的NSArray或NSDictionary<br/>\n对于NSArray和NSDictionary在strong情况下传引用，并且引用计数加1，copy情况下是产生一个深拷贝“备份”，并且这个备份变成了一个不可变的NSArray或NSDictionary。<br/>\n\n对于NSString，NSArray，NSDictionary我们经常用copy关键字是因为这些类型的对象不可变，我们只需要使用其一个备份就可以。另外，NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份，所以我们也会用copy修饰符。<br/>\n如果改用strong关键字修饰的话，试图去修改这些不可改变大小的对象而参数数据混乱（更改了一个原不想修改的数据）。\n### [※※※]@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？\n> 引用答案的一句话：` 实例变量 == 成员变量 == ivar `\n\n`@synthesize` 合成变量的规则是绑定成员属性getter/setter方法到某个成员变量，这个过程叫自动合成，你可以指定成员变量，也可以不指定，如果不指定，则这个成员变量的名字与属性名字相同，在没有`@synthesize`绑定情况下系统会自动生成一个“_属性名”的一个成员变量，并绑定getter/setter方法到“_属性名”成员变量。如果已经存在“_属性名”，则编译器不会再自动合成新变量。\n\n例如.h文件,用`@property`声明了一个FooClass类型的成员属性 `foo`：<br/>\n\t\n\tclass FooLcass : NSObject\n\t{\n\t\tFooClass* _foo; //实例变量\n\t}\n\n\t@property (strong, nonatomic) FooClass* foo; //成员属性\n\t\n在.m代码如下：\n\n\t@synthesize foo = _foo;\n\n\n### [※※]什么情况下不会autosynthesis（自动合成）?\n1. 同时重写了 setter 和 getter 时\n2. 重写了只读属性的 getter 时\n3. 使用了 @dynamic 时\n4. 在 @protocol 中定义的所有属性\n5. 在 category 中定义的所有属性\n6. 重载的属性当你在子类中重载了父类中的属性，你必须 使用 @synthesize 来手动合成ivar。\n\n### [※※※※※]在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？\n\n1. 手动合成ivar（手动管理property，不使用自动合成autosynthesis）\n2. 重载父类的属性 当子类重载了父类的属性石，必须手动指定ivar\n3. 以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字\n\n### [※※]objc中向一个nil对象发送消息将会发生什么？\n之前理解如果objc是nil，那么向nil对象发生消息将什么也不会发生（对象方法没有正常执行并且也没有引起crash），这些虽然从表象上看是正确的，但是在运行时Runtime中却发生了一系列变化。首先Runtime会动态转化方法调用为消息发送，调用objc_msgSend(receiver,selecter,argv,...),objc_msgSend是不会返回值，他只是起到消息转发的作用，整个过程就是objc_Send根据reciver找到该实例对象的类对象，然后从该类对象的方法列表objc_method_list中找到对应的IMP，然后把参数传给IMP进行方法调用，最后把IMP函数指针指定的方法只需结果返回。由于receiver参数是nil，也就是该类对象的isa指针指向为nil(0)，objc_msgSend也就返回nil(0).\n\n另外附上objc的一个结构定义\n\n\t// runtime.h（类在runtime中的定义）\n\t// http://weibo.com/luohanchenyilong/\n\t// https://github.com/ChenYilong\n\t\n\tstruct objc_class {\n\t  Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object\n\t  #if !__OBJC2__\n\t  Class super_class OBJC2_UNAVAILABLE; // 父类\n\t  const char *name OBJC2_UNAVAILABLE; // 类名\n\t  long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0\n\t  long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识\n\t  long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小\n\t  struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表\n\t  struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表\n\t  struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。\n\t  struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表\n\t  #endif\n\t  } OBJC2_UNAVAILABLE;\n### [※※※]objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？\n\nRuntime运行原理就如上描述一致，消息发生会被转发objc_msgSend((id)obj,@selecter(foo));除此之外对于“边界情况”，如果消息是发给父类的例如：[super foo]那么消息会被转发objc_msgSendSuper((id)obj,@selecter(foo));如果foo消息返回的是结构体，那么消息转换会变成objc_msgSend_stret((id)obj,@selecter(foo));如果foo消息返回的是浮点型数据，那么消息转换成objc_msgSend_fpret((id)obj,@selecter(foo));\n这些转换都是在动态编译的时候进行转换的。\n\n\n### [※※※]什么时候会报unrecognized selector的异常？\n\n“unrecognized selecter”中文翻译就是无法识别的方法，当实例对象或者类对象发送一个该对象objc_method_list/objc_protocol_list没有对应方法的时候，NSObject就是抛出异常。<br/>\n在Runtime抛出异常之间还可做很多事情来处理这种异常，这要依赖于NSObject的消息转发机制。<br/>\n首先在Class中的缓存查找IMP（没缓存则初始化缓存），如果没找到，则向父类的Class查找。如果一直查找到根类仍旧没有实现，则用_objc_msgForward函数指针代替IMP。最后，执行这个IMP。<br/>\n_objc_msgForward是用于消息转发的。这个函数的实现并没有在objc-runtime的开源代码里面，而是在Foundation框架里面实现的。__CFInitialize这个方法会调用objc_setForwardHandler函数来注册一个实现。<br/>\n_objc_msgForward消息转发做了如下几件事：\n\n征询接受者看其是否能动态添加方法，以处理当前这个“未知的选择子”（这叫动态方法解析）即调用：\n\n\t+ (BOOL)resolveInstanceMethod:(SEL)selecter;//实例对象的处理方法\n\t+ (BOOL)resolveClassMethod:(SEL)selecter;//类对象的处理方法\t\n该方法的参数就是哪个未知的选择子，我们可以在这里处理哪些没有被objc_msgSend找到的方法。<br/>\n假如在这个阶段还是没有处理这个未知的SEL，那么该SEL会被转发到备用接受者\n\t\n\t- (id)forwardingTargetForSelecter:(SEL)selecter;\n\t\n这个方法返回指定的能够处理该消息的实例对象或者类对象。<br/>\n如果没有备用接收者，那么就启用完整的转发机制，就是把尚未处理的那条消息的全部信息（选择子，目标，参数）封装成NSInvocation对象，并触发NSinvocation对象，让“消息派发系统”把消息指派给目标对象。即调用:\n\t\n\t- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;//获取方法签名信息\n\t- (void)forwardInvocation:(NSInvocation*)invocaton;\n\t\n消息派发系统依照类的继承关系逐一寻找能够处理该NSInvacation的对象，直到NSObject，如果最后调用了NSObject类方法，那么该方法还会继续调用`doesNotRecognizeSelecter:`以抛出异常。\n\n最后陪一个能够理解的图：\n![消息转发机制流程图](http://7xoo3c.com1.z0.glb.clouddn.com/blogmethod_forwarding.png \"消息转发机制流程图\")\n\n\n### [※※※※]一个objc对象如何进行内存布局？（考虑有父类的情况）\n* 一个objc对象的存储空间中保存着该对象的所有实例变量和该对象所有父类的所有实例变量\n* 每个对象都有一个isa指针，这个指针指向该objc对象的类对象，此类对象在Runtime环境中只有一份儿，并且和其它类对象有着相同的结构，此类对象中存储的是：\n\ntypedef struct objc_class *Class;\n\t\n\t/*\n\t  这是由编译器为每个类产生的数据结构,这个结构定义了一个类.\n\t  这个结构是通过编译器在执行时产生,在运行时发送消息时使用.\n\t  因此,一些成员改变了类型.\n\t  编译器产生\"char* const\"类型的字符串指针替代了下面的成员变量\"super_class\"\n\t*/\n\tstruct objc_class {\n\t  struct objc_class*  class_pointer;    /* 指向元类的指针. */\n\t  struct objc_class*  super_class;      /* 指向父类的指针. 对于NSObject来说是NULL.*/\n\t  const char*         name;             /* 类的名称. */\n\t  long                version;          /* 未知. */\n\t  unsigned long       info;             /* 比特蒙板.  参考下面类的蒙板定义. */\n\t  long                instance_size;    /* 类的字节数.包含类的定义和所有父类的定义 */\n\t#ifdef _WIN64\n\t  long pad;\n\t#endif\n\t  struct objc_ivar_list* ivars;         /* 指向类中定义的实例变量的列表结构. NULL代表没有实例变量.不包括父类的变量. */\n\t  struct objc_method_list*  methods;    /* 链接类中定义的实例方法. */\n\t  struct sarray *    dtable;            /* 指向实例方法分配表. */\n\t  struct objc_class* subclass_list;     /* 父类列表 */\n\t  struct objc_class* sibling_class;\n\t  struct objc_protocol_list *protocols; /* 要实现的原型列表 */\n\t  void* gc_object_type;\n\t};\n\n该类也有一个isa指针，它指向该类的元类，元类的作用类似于类作用于类对象，保存了该类的类方法信息。\n\n引用网上常列举的一张图：\n![内存布局图](http://7xoo3c.com1.z0.glb.clouddn.com/blogmeta_calss.png \"类内存布局图\")\n\n### [※※※※]一个objc对象的isa的指针指向什么？有什么作用？\n1. 实例对象的isa指向该实例的类对象，类对象的isa指向该类的元类，元类的isa指向自己。\n2. 类对象保存着该类的成员列表信息，方法列表信息等。元类保存着该类对象的类方法列表。\n\n\n### [※※※※]下面的代码输出什么？\n\n\t@implementation Son : Father\n\t- (id)init\n\t{\n\t    self = [super init];\n\t    if (self) {\n\t        NSLog(@\"%@\", NSStringFromClass([self class]));\n\t        NSLog(@\"%@\", NSStringFromClass([super class]));\n\t    }\n\t    return self;\n\t}\n\t@end\n\t\n都输出：Son，答案：http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1)%5Bnil%5D-self-and-super/\n\n\t2014-11-05 11:06:18.060 Test[8566:568584] NSStringFromClass([self class]) = Son\n\t2014-11-05 11:06:18.061 Test[8566:568584] NSStringFromClass([super class]) = Son\n\n解惑：这个题目主要是考察关于objc中对 self 和 super 的理解。\n\nself 是类的隐藏参数，指向当前调用方法的这个类的实例。而 super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者。上面的例子不管调用[self class]还是[super class]，接受消息的对象都是当前 Son ＊xxx 这个对象。而不同的是，super是告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。\n\n当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法。\n\n真的是这样吗？继续看：\n\n使用clang重写命令:\n\n\t$ clang -rewrite-objc test.m\n发现上述代码被转化为:\n\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_0, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(\"class\"))));\n\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_1, NSStringFromClass(((Class (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){ (id)self, (id)class_getSuperclass(objc_getClass(\"Son\")) }, sel_registerName(\"class\"))));\n    \n从上面的代码中，我们可以发现在调用`[self class]`时，会转化成`objc_msgSend`函数。看下函数定义：\n\n\tid objc_msgSend(id self, SEL op, ...)\n我们把`self`做为第一个参数传递进去。\n\n而在调用`[super class]`时，会转化成`objc_msgSendSuper`函数。看下函数定义:\n\n\tid objc_msgSendSuper(struct objc_super *super, SEL op, ...)\n第一个参数是`objc_super`这样一个结构体，其定义如下:\n\n\tstruct objc_super {\n\t   __unsafe_unretained id receiver;\n\t   __unsafe_unretained Class super_class;\n\t};\n结构体有两个成员，第一个成员是`receiver`, 类似于上面的`objc_msgSend`函数第一个参数`self`。第二个成员是记录当前类的父类是什么。\n\n所以，当调用`[self class]`时，实际先调用的是`objc_msgSend`函数，第一个参数是`Son`当前的这个实例，然后在`Son`这个类里面去找 `- (Class)class`这个方法，没有，去父类 Father里找，也没有，最后在 NSObject类中发现这个方法。而 `- (Class)class`的实现就是返回self的类别，故上述输出结果为 Son。\n\nobjc Runtime开源代码对- (Class)class方法的实现:\n\n\t- (Class)class {\n\t    return object_getClass(self);\n\t}\n而当调用`[super class]`时，会转换成`objc_msgSendSuper`函数。第一步先构造`objc_super`结构体，结构体第一个成员就是 self 。第二个成员是 `(id)class_getSuperclass(objc_getClass(“Son”)) `, 实际该函数输出结果为 Father。第二步是去 Father这个类里去找`- (Class)class`，没有，然后去NSObject类去找，找到了。最后内部是使用` objc_msgSend(objc_super->receiver, @selector(class))`去调用，此时已经和`[self class]`调用相同了，故上述输出结果仍然返回 `Son`。\n\n> 参考：http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1)%5Bnil%5D-self-and-super/\n\t\n### [*]runtime 如何实现 weak 属性?\n\n`weak`修饰符是ARC下引入的修饰符，其和`assign`表示相同，表示`nonowning relationship`(非拥有关系)，对于被`weak`修饰的对象，当其所引用的对象的引用计数为0的时候，该对象就为被值为nil。这个过程是依靠Runtime来实现的，当Runtime载入并注册类，会对内存布局，把类中每个被`weak`修饰的属性加入多一个与该类相关的哈希表结构中，此结构以该对象的地址为key，当该对象的引用计数为0的时候，就会调用dealloc方法，该方法会检索此哈希表，找到所有key为该地址的所有对象，并把它们设值成nil。\n\n### [※※※※]runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）\n\n我们看一下`@selector(methodName:)`返回一个`SEL`类型:\n\n\ttypedef struct objc_selector *SEL;\n\t\n\tstruct objc_selector\n\t{\n\t  void *sel_id;\n\t  const char *sel_types;\n\t};\n\t\n上面的结构是在网上搜索到的，但是我在objc/runtime.h中没有找到objc_selector的定义。\n\n> https://sourceware.org/svn/gcc/tags/stack-last-merge/libobjc/objc/objc.h\n\n这里指明了objc.h是GCC中的一个文件`This file is part of GCC.`。\n\nObjective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL。所以在Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行。相同的方法只能对应一个SEL。这也就导致Objective-C在处理相同方法名且参数个数相同但类型不同的方法方面的能力很差。如在某个类中定义以下两个方法：\n\t\n\t- (void)setWidth:(int)width;\n\t\n\t- (void)setWidth:(double)width;\n这样的定义被认为是一种编译错误，所以我们不能像C++, C#那样。而是需要像下面这样来声明：\n\n\t-(void)setWidthIntValue:(int)width;\n\t\n\t-(void)setWidthDoubleValue:(double)width;\n当然，不同的类可以拥有相同的selector，这个没有问题。不同类的实例对象执行相同的selector时，会在各自的方法列表中去根据selector去寻找自己对应的IMP。<br/>\n\n工程中的所有的SEL组成一个Set集合，Set的特点就是唯一，因此SEL是唯一的。因此，如果我们想到这个方法集合中查找某个方法时，只需要去找到这个方法对应的SEL就行了，SEL实际上就是根据方法名hash化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，可以说速度上无语伦比！！但是，有一个问题，就是数量增多会增大hash冲突而导致的性能下降（或是没有冲突，因为也可能用的是perfect hash）。但是不管使用什么样的方法加速，如果能够将总量减少（多个方法可能对应同一个SEL），那将是最犀利的方法。那么，我们就不难理解，为什么SEL仅仅是函数名了。\n\n本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。这个查找过程我们将在下面讨论。\n\n我们可以在运行时添加新的selector，也可以在运行时获取已存在的selector，我们可以通过下面三种方法来获取SEL:\n\n1. sel_registerName函数\n2. Objective-C编译器提供的@selector()\n3. NSSelectorFromString()方法\n\nIMP实际上是一个函数指针，指向方法实现的首地址。其定义如下：\n\n\tid (*IMP)(id, SEL, ...)\n\t\n介绍完SEL和IMP，我们就可以来讲讲Method了。Method用于表示类定义中的方法，则定义如下：\n\n\ttypedef struct objc_method *Method;\n\t\n\t\n\t\n\tstruct objc_method {\n\t\n\t    SEL method_name                 OBJC2_UNAVAILABLE;  // 方法名\n\t\n\t    char *method_types                  OBJC2_UNAVAILABLE;\n\t\n\t    IMP method_imp                      OBJC2_UNAVAILABLE;  // 方法实现\n\t\n\t}  \n我们可以看到该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。\n\t\n对于每一个实例对象它会有一个isa指针，该指针指向该实例对象的类对象，它是一个objc_class的结构体，该结构题中的objc_method_list内包含了该对象的所有实例方法，对于类方法，每个类对象中又有一个isa指针指向该类对象的元类，元类objc_class结构的objc_method_list结构中存储着该类的所有类方法。Runtime通过查找这两个类来获取方法的IMP。\n\n> 参考：http://southpeak.github.io/blog/2014/11/03/objective-c-runtime-yun-xing-shi-zhi-san-:fang-fa-yu-xiao-xi-zhuan-fa/\n\n### [※※※※]使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？\n不需要（ARC下和MRC），`overfllow`的一句话`Associated objects are released after the dealloc method of the original object has finished.`。通过源码我们可以得知关联对象是通过一个单例类`AssociationsManager`实例维护一个哈希列表`AssociationsHashMap`实现的。而map的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。\n\n而在对象的销毁逻辑里面，当对象的引用计数为0的时候，Runloop在清理对象的时候会调用对象的`dealloc`,该方法会调用`object_dispose`方法来清理对象，在`object_dispose`步会对关联对象进行清理。源代码见`objc-runtime-new.mm`:\n\n\tvoid *objc_destructInstance(id obj) \n\t{\n\t    if (obj) {\n\t        Class isa_gen = _object_getClass(obj);\n\t        class_t *isa = newcls(isa_gen);\n\t\n\t        // Read all of the flags at once for performance.\n\t        bool cxx = hasCxxStructors(isa);\n\t        bool assoc = !UseGC && _class_instancesHaveAssociatedObjects(isa_gen);\n\t\n\t        // This order is important.\n\t        if (cxx) object_cxxDestruct(obj);\n\t        if (assoc) _object_remove_assocations(obj);\n\t\n\t        if (!UseGC) objc_clear_deallocating(obj);\n\t    }\n\t\n\t    return obj;\n\t}\n\t\nRuntime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作。\n\n### [※※※※※]objc中的类方法和实例方法有什么本质区别和联系？\n\n### [※※※※※]_objc_msgForward函数是做什么的，直接调用它将会发生什么？\n### [※※※※※]runtime如何实现weak变量的自动置nil？\n\n### [※※※※※]能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\n\n不能向遍以后得到的类中增加实例变量，但是能够向运行时创建的类中添加实例变量。\n\n\tclass_addIvar\n\n> This function may only be called after objc_allocateClassPair and before objc_registerClassPair. \n> Adding an instance variable to an existing class is not supported.\n\n> Objective-C不支持往已存在的类中添加实例变量，因此不管是系统库提供的提供的类，还是我们自定义的类，都无法动态添加成员变量。但如果我们通过运行时来创建一个类的话，又应该如何给它添加成员变量呢？这时我们就可以使用class_addIvar函数了。不过需要注意的是，这个方法只能在objc_allocateClassPair函数与objc_registerClassPair之间调用。另外，这个类也不能是元类。成员变量的按字节最小对齐量是1<<alignment。这取决于ivar的类型和机器的架构。如果变量的类型是指针类型，则传递log2(sizeof(pointer_type))。\n\n> 文／西木（简书作者）\n> 原文链接：http://www.jianshu.com/p/6b905584f536\n\n\n### [※※※]runloop和线程有什么关系？\n\n### [※※※]runloop的mode作用是什么？\n\n### [※※※※]以+ scheduledTimerWithTimeInterval...的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？\n\n### [※※※※※]猜想runloop内部是如何实现的？\n\n### [※]objc使用什么机制管理对象内存？\n\n### [※※※※]ARC通过什么方式帮助开发者管理内存？\n\n### [※※※※]不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）\n\n### [※※※※]BAD_ACCESS在什么情况下出现？\n\n### [※※※※※]苹果是如何实现autoreleasepool的？\n\n### [※※]使用block时什么情况会发生引用循环，如何解决？\n\n### [※※]在block内如何修改block外部变量？\n\n### [※※※]使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？\n\n### [※※]GCD的队列（dispatch_queue_t）分哪两种类型？\n\n### [※※※※]如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\n\n### [※※※※]dispatch_barrier_async的作用是什么？\n\n### [※※※※※]苹果为什么要废弃dispatch_get_current_queue？\n\n### [※※※※※]以下代码运行结果如何？\n\n\t- (void)viewDidLoad\n\t{\n\t    [super viewDidLoad];\n\t    NSLog(@\"1\");\n\t    dispatch_sync(dispatch_get_main_queue(), ^{\n\t        NSLog(@\"2\");\n\t    });\n\t    NSLog(@\"3\");\n\t}\n### [※※]addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？\n\n### [※※※]如何手动触发一个value的KVO?\n\n### [※※※]若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？\n\n### [※※※※]KVC的keyPath中的集合运算符如何使用？\n\n### [※※※※]KVC和KVO的keyPath一定是属性么？\n\n### [※※※※※]如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？\n\n### [※※※※※]apple用什么方式实现对一个对象的KVO？\n\n### [※※]IBOutlet连出来的视图属性为什么可以被设置成weak?\n\n### [※※※※※]IB中User Defined Runtime Attributes如何使用？\n\n### [※※※]如何调试BAD_ACCESS错误?\n\n### [※※※]lldb（gdb）常用的调试命令？","source":"_posts/interview-checklist.md","raw":"---\ntitle: iOS面试题总结\ndate: 2016-06-23 22:52:03\ntags: [面试]\ncategories: 日常记事\n\n---\n\n# 常见的iOS面试题\n由于空闲时间比较喜欢在网上看一些大牛的技术blog，今天刚好看到大牛sunnyxx的一个关于他面试别人时提到的一些常见问题（[原文地址](http://blog.sunnyxx.com/2015/07/04/ios-interview/)），所以自己也就试着回答了一遍，也算时对自己的一次面试吧，通过自己面试时间也发现了一些自己不足的一面，所以今天记录下来，加深一下印象吧。<br/>\n\n<font color=\"red\"><strong>另外这里有一份 [详细答案](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md) 分析的很到位</strong></font>\n\n### [※]@property中有哪些属性关键字？\n在@property 中的关键词个人总结分为三类：RC语意修饰符，线程安全修饰符，读写属性修饰符。\n#### RC语意修饰符\n这类修饰符主要为了在ARC或者MRC下一个属性的内存管理方法，共如下几种：<br/>\n`assign`： 简单的赋值，不会改变引用计数，共享内存；一般用于基本类型（c/c++：int float等，OC:NSInteger,BOOL等）<br/>\n`retain`： 处理简单赋值外会对赋值对象的引用计数加1操作，用于OC对象；<br/>\n`copy`：处理简单赋值，但是赋值对象引用计数不变，被赋值对象引用计数为1，也就是新生成一个与被赋值对象一样的数据（非绝对 如NSArray对象）<br/>\n`unsafe_unretained`：简单赋值，与assign相似，多用于修饰OC对象，只是表显该对象是不安全的（当赋值对象变为nil的时候会引起crash 野指针问题）<br/>\n`strong`：ARC中简单赋值，与非ARC下的retain相同作用<br/>\n`weak`：ARC中简单赋值，与非ARC下的assign对应，但是又有不同，weak多用于修饰OC对象，且当改对象的引用计数为0的时候，改对象会被修改成nil，而assign则不会，好处时能有效的防止野指针<br/>\n\n#### 线程安全修饰符\n这类修饰符主要是指定属性赋值操作的线程安全性<br/>\n`atomic`：线程安全的，多线程访问情况下只有一个线程能访问他，影响访问速度<br/>\n`nonatomic`：非线程安全的，多线程可同时读写，容易造成混乱，但读写速度快<br/>\n\n#### 读写属性修饰符\n这类修饰符主要控制属性的读写权限<br/>\n`readonly`: 编译器只会对该属性生成get方法<br/>\n`readwrite`: 编译器能生成get/set方法，默认此属性<br/>\n另外get方法可以在修饰符最后指定，比如：`@property(getter = isGirl) BOOL girl`\n\n### [*]怎么用 copy 关键字？\n1. NSString，NSArray，NSDictionary类型属性常用，因为它们有NSMutableString,NSMutableArray,NSMutableDictionary类型属性，当我们不想外界干扰我们正在操作的这类型属性的时候，我们会把她们设置成copy。\n2. 在使用block的时候我们用copy，在MRC时代，block是创建在栈上的，所以当我们把block进行赋值时不进行copy操作的话，block内的变量会因为栈的pop而造成野指针，从而引起crash。当然在ARC下，block会自动进行copy，但是作为程序员团队协作开发，能明确让别人看到block是经过copy到堆上的对象则更加具有易读性。\n### [*]这个写法会出什么问题： @property (copy) NSMutableArray *array;\n1. 把NSMutableArray 属性设置成copy，无论赋值对象是NSArray还是NSMutableArray赋值后array指向的是NSArray对象，但我们往往会因为array的声明NSMutableArray＊ 而把它当成一个可变对象来操作，一旦调用了array的[array removeAtIndex:n],等不属于NSArray的方法后会引起Crash。\n2. 属性修饰符没有加nonatomic，那么array会被编译器默认设置为atomic，atomic表示该属性是原则性操作，每次setter都会加锁来确保它的原子性，这将耗费大量运算。\n\n### [*]如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？\n\n想要自己的类能够使用copy修饰符则必须让自己的类实现NSCopying协议，如果自己的类像NSString那样大小有可变版本和不可变版本，那么就是实现NSCopying协议和NSMutalbeCopying协议。\n\n具体步骤：\n1. 声明该类遵从NSCopying协议。\n2. 在该类中实现下面方法,并且注意对象copy是否需要深拷贝操作。\n\t\n\t- (id)copyWithZone:(NSZone *)zone;\n\t\n至于重写带copy关键字的setter的话一般如下：\n\n\t- (void)setCustomClass:(CustomClass *)customClass\n\t{\n\t\t_customClass = [customClass copy];\n\t}\n但是由于遵循NSCopying协议的类一般都是用作只读属性，所以我们就不去实现setter方法，而是在类initializer的时候对其进行初始化。例如：\n\t\n\t- (instancetype)initWithCustomClass:(CustomClass *)cClass\n\t{\n\t\tif(self == [super init]){\n\t\t\t_cClass = [cClass copy];\n\t\t}\n\t\treturn self;\n\t}\n\t\n\n### [*]@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的?\n<font color=\"red\" size=\"5px\"><strong>此为盗取答案：</strong></font>\n#### @property 的本质是什么？\n> @property = (ivar + getter + setter)\n> “属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。\n\n“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 Objective-C 2.0 的一部分。 而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。 正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:\n\n> 编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。 所以你也可以这么说：\n> @property = getter + setter;\n\n#### ivar、getter、setter 是如何生成并添加到这个类中的?\n\n> “自动合成”( autosynthesis)\n> 完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字.\n\n\t@implementation Person\n\t@synthesize firstName = _myFirstName;\n\t@synthesize lastName = _myLastName;\n\t@end\n\t\n> 我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西\n\n> 1. OBJC_IVAR_$类名$属性名称 ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，\n> 2. 表示该变量距离存放对象的内存区域的起始地址有多远。\n> 3. setter 与 getter 方法对应的实现函数\n> 4. ivar_list ：成员变量列表\n> 5. method_list ：方法列表\n> 6. prop_list ：属性列表\n> \n> 也就是说我们每次在增加一个属性,系统都会在 ivar_list 中添加一个成员变量的描述,在 method_list 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.\n\n### [*]@protocol 和 category 中如何使用 @property ?\n\n`@property`是封装数据的方式，我们一般不再`@protocol`和`category`中使用`@property`，而是在`class_continuation分类`中, 查看OC源码我们知道objc_struct结构中，成员变量的偏移量是放到`ivar_list`中的，是指针加偏移量来进行寻址操作的,OC把实例变量当作一种存储偏移量所用的“特殊变量”，并交由“类对象”来管理，偏移量会在运行时进行查找，如果类的定义变了，那么存储的偏移量也就变了，这样的话，无论何时访问实例变量，总能使用正确的偏移量，也就是说这些偏移量是是在编译时期生成的，所以不能在运行时期向类内加入实例变量。这和方法列表`method_list`不同的是，方法列表中结构中存的不是偏移量，而是方法指针的指针，也就是说每个方法我们可以修改其实现为任意实现地址。<br/>\n虽然我们不能通过在`@protocol`和`category`中添加实例变量，但是我们可以通过`@property`+`@dynamic`+`关联`来达到新增实例相同的结果。\n\n> 参考资料：https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html\n\n\n\n1. 在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性\n2. category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 \ncategory 增加属性的实现,需要借助于运行时的两个函数：\n\n\tobjc_setAssociatedObject\n\tobjc_getAssociatedObject\n\nRuntime给我们提供了这两个方法来达到这个目的，这些关联是通过一个`AssociationsManager`实例维护一个哈西列表`AssociationsHashMap`实现的。\n\n### [※]weak属性需要在dealloc中置nil么？\n不需要，因为被weak修饰符修饰的属性当其引用计数为0的时候，自动引用计数器会自动把属性设置为nil\n\n### [※※]@synthesize和@dynamic分别有什么作用？\n\n`@synthesize`: 该修饰符告诉编译器在编译期自动为该属性生成getter/setter方法，并可指明该属性对应的成员变量。\n`@dynamic`: 告诉编译器，不自动生成getter/setter方法，避免编译期间产生警告,然后由自己实现存取方法或存取方法在运行时动态创建绑定：主要使用在CoreData的实现NSManagedObject子类时使用，由Core Data框架在程序运行的时动态生成子类属性\n### [※※※]ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？\n内存管理默认`strong`,  原子性默认`atomic`,读写性默认`readwrite`;\n### [※※※]用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？\n对源头是NSMutableString的字符串，strong仅仅是指针引用，增加了引用计数器，这样源头改变的时候，用这种strong方式声明的变量（无论被赋值的变量是可变的还是不可变的），它也会跟着改变;而copy声明的变量，它不会跟着源头改变，它实际上是深拷贝的“备份”。<br/>\n对源头是NSString的字符串，无论是strong声明的变量还是copy声明的变量，当第二次源头的字符串重新指向其它的地方的时候，它还是指向原来的最初的那个位置（因为常量字符串分配在一个常量内存区），也就是说其实二者都是指针引用，也就是浅拷贝。<br/>\n\n而对于NSMutableArray和NSMutableDictionary情况是和NSMutableString是一样的，strong情况下是传引用，并且引用计数加1，copy情况下是产生一个深拷贝“备份”，并且这个备份变成了一个不可变的NSArray或NSDictionary<br/>\n对于NSArray和NSDictionary在strong情况下传引用，并且引用计数加1，copy情况下是产生一个深拷贝“备份”，并且这个备份变成了一个不可变的NSArray或NSDictionary。<br/>\n\n对于NSString，NSArray，NSDictionary我们经常用copy关键字是因为这些类型的对象不可变，我们只需要使用其一个备份就可以。另外，NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份，所以我们也会用copy修饰符。<br/>\n如果改用strong关键字修饰的话，试图去修改这些不可改变大小的对象而参数数据混乱（更改了一个原不想修改的数据）。\n### [※※※]@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？\n> 引用答案的一句话：` 实例变量 == 成员变量 == ivar `\n\n`@synthesize` 合成变量的规则是绑定成员属性getter/setter方法到某个成员变量，这个过程叫自动合成，你可以指定成员变量，也可以不指定，如果不指定，则这个成员变量的名字与属性名字相同，在没有`@synthesize`绑定情况下系统会自动生成一个“_属性名”的一个成员变量，并绑定getter/setter方法到“_属性名”成员变量。如果已经存在“_属性名”，则编译器不会再自动合成新变量。\n\n例如.h文件,用`@property`声明了一个FooClass类型的成员属性 `foo`：<br/>\n\t\n\tclass FooLcass : NSObject\n\t{\n\t\tFooClass* _foo; //实例变量\n\t}\n\n\t@property (strong, nonatomic) FooClass* foo; //成员属性\n\t\n在.m代码如下：\n\n\t@synthesize foo = _foo;\n\n\n### [※※]什么情况下不会autosynthesis（自动合成）?\n1. 同时重写了 setter 和 getter 时\n2. 重写了只读属性的 getter 时\n3. 使用了 @dynamic 时\n4. 在 @protocol 中定义的所有属性\n5. 在 category 中定义的所有属性\n6. 重载的属性当你在子类中重载了父类中的属性，你必须 使用 @synthesize 来手动合成ivar。\n\n### [※※※※※]在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？\n\n1. 手动合成ivar（手动管理property，不使用自动合成autosynthesis）\n2. 重载父类的属性 当子类重载了父类的属性石，必须手动指定ivar\n3. 以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字\n\n### [※※]objc中向一个nil对象发送消息将会发生什么？\n之前理解如果objc是nil，那么向nil对象发生消息将什么也不会发生（对象方法没有正常执行并且也没有引起crash），这些虽然从表象上看是正确的，但是在运行时Runtime中却发生了一系列变化。首先Runtime会动态转化方法调用为消息发送，调用objc_msgSend(receiver,selecter,argv,...),objc_msgSend是不会返回值，他只是起到消息转发的作用，整个过程就是objc_Send根据reciver找到该实例对象的类对象，然后从该类对象的方法列表objc_method_list中找到对应的IMP，然后把参数传给IMP进行方法调用，最后把IMP函数指针指定的方法只需结果返回。由于receiver参数是nil，也就是该类对象的isa指针指向为nil(0)，objc_msgSend也就返回nil(0).\n\n另外附上objc的一个结构定义\n\n\t// runtime.h（类在runtime中的定义）\n\t// http://weibo.com/luohanchenyilong/\n\t// https://github.com/ChenYilong\n\t\n\tstruct objc_class {\n\t  Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object\n\t  #if !__OBJC2__\n\t  Class super_class OBJC2_UNAVAILABLE; // 父类\n\t  const char *name OBJC2_UNAVAILABLE; // 类名\n\t  long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0\n\t  long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识\n\t  long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小\n\t  struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表\n\t  struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表\n\t  struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。\n\t  struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表\n\t  #endif\n\t  } OBJC2_UNAVAILABLE;\n### [※※※]objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？\n\nRuntime运行原理就如上描述一致，消息发生会被转发objc_msgSend((id)obj,@selecter(foo));除此之外对于“边界情况”，如果消息是发给父类的例如：[super foo]那么消息会被转发objc_msgSendSuper((id)obj,@selecter(foo));如果foo消息返回的是结构体，那么消息转换会变成objc_msgSend_stret((id)obj,@selecter(foo));如果foo消息返回的是浮点型数据，那么消息转换成objc_msgSend_fpret((id)obj,@selecter(foo));\n这些转换都是在动态编译的时候进行转换的。\n\n\n### [※※※]什么时候会报unrecognized selector的异常？\n\n“unrecognized selecter”中文翻译就是无法识别的方法，当实例对象或者类对象发送一个该对象objc_method_list/objc_protocol_list没有对应方法的时候，NSObject就是抛出异常。<br/>\n在Runtime抛出异常之间还可做很多事情来处理这种异常，这要依赖于NSObject的消息转发机制。<br/>\n首先在Class中的缓存查找IMP（没缓存则初始化缓存），如果没找到，则向父类的Class查找。如果一直查找到根类仍旧没有实现，则用_objc_msgForward函数指针代替IMP。最后，执行这个IMP。<br/>\n_objc_msgForward是用于消息转发的。这个函数的实现并没有在objc-runtime的开源代码里面，而是在Foundation框架里面实现的。__CFInitialize这个方法会调用objc_setForwardHandler函数来注册一个实现。<br/>\n_objc_msgForward消息转发做了如下几件事：\n\n征询接受者看其是否能动态添加方法，以处理当前这个“未知的选择子”（这叫动态方法解析）即调用：\n\n\t+ (BOOL)resolveInstanceMethod:(SEL)selecter;//实例对象的处理方法\n\t+ (BOOL)resolveClassMethod:(SEL)selecter;//类对象的处理方法\t\n该方法的参数就是哪个未知的选择子，我们可以在这里处理哪些没有被objc_msgSend找到的方法。<br/>\n假如在这个阶段还是没有处理这个未知的SEL，那么该SEL会被转发到备用接受者\n\t\n\t- (id)forwardingTargetForSelecter:(SEL)selecter;\n\t\n这个方法返回指定的能够处理该消息的实例对象或者类对象。<br/>\n如果没有备用接收者，那么就启用完整的转发机制，就是把尚未处理的那条消息的全部信息（选择子，目标，参数）封装成NSInvocation对象，并触发NSinvocation对象，让“消息派发系统”把消息指派给目标对象。即调用:\n\t\n\t- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;//获取方法签名信息\n\t- (void)forwardInvocation:(NSInvocation*)invocaton;\n\t\n消息派发系统依照类的继承关系逐一寻找能够处理该NSInvacation的对象，直到NSObject，如果最后调用了NSObject类方法，那么该方法还会继续调用`doesNotRecognizeSelecter:`以抛出异常。\n\n最后陪一个能够理解的图：\n![消息转发机制流程图](http://7xoo3c.com1.z0.glb.clouddn.com/blogmethod_forwarding.png \"消息转发机制流程图\")\n\n\n### [※※※※]一个objc对象如何进行内存布局？（考虑有父类的情况）\n* 一个objc对象的存储空间中保存着该对象的所有实例变量和该对象所有父类的所有实例变量\n* 每个对象都有一个isa指针，这个指针指向该objc对象的类对象，此类对象在Runtime环境中只有一份儿，并且和其它类对象有着相同的结构，此类对象中存储的是：\n\ntypedef struct objc_class *Class;\n\t\n\t/*\n\t  这是由编译器为每个类产生的数据结构,这个结构定义了一个类.\n\t  这个结构是通过编译器在执行时产生,在运行时发送消息时使用.\n\t  因此,一些成员改变了类型.\n\t  编译器产生\"char* const\"类型的字符串指针替代了下面的成员变量\"super_class\"\n\t*/\n\tstruct objc_class {\n\t  struct objc_class*  class_pointer;    /* 指向元类的指针. */\n\t  struct objc_class*  super_class;      /* 指向父类的指针. 对于NSObject来说是NULL.*/\n\t  const char*         name;             /* 类的名称. */\n\t  long                version;          /* 未知. */\n\t  unsigned long       info;             /* 比特蒙板.  参考下面类的蒙板定义. */\n\t  long                instance_size;    /* 类的字节数.包含类的定义和所有父类的定义 */\n\t#ifdef _WIN64\n\t  long pad;\n\t#endif\n\t  struct objc_ivar_list* ivars;         /* 指向类中定义的实例变量的列表结构. NULL代表没有实例变量.不包括父类的变量. */\n\t  struct objc_method_list*  methods;    /* 链接类中定义的实例方法. */\n\t  struct sarray *    dtable;            /* 指向实例方法分配表. */\n\t  struct objc_class* subclass_list;     /* 父类列表 */\n\t  struct objc_class* sibling_class;\n\t  struct objc_protocol_list *protocols; /* 要实现的原型列表 */\n\t  void* gc_object_type;\n\t};\n\n该类也有一个isa指针，它指向该类的元类，元类的作用类似于类作用于类对象，保存了该类的类方法信息。\n\n引用网上常列举的一张图：\n![内存布局图](http://7xoo3c.com1.z0.glb.clouddn.com/blogmeta_calss.png \"类内存布局图\")\n\n### [※※※※]一个objc对象的isa的指针指向什么？有什么作用？\n1. 实例对象的isa指向该实例的类对象，类对象的isa指向该类的元类，元类的isa指向自己。\n2. 类对象保存着该类的成员列表信息，方法列表信息等。元类保存着该类对象的类方法列表。\n\n\n### [※※※※]下面的代码输出什么？\n\n\t@implementation Son : Father\n\t- (id)init\n\t{\n\t    self = [super init];\n\t    if (self) {\n\t        NSLog(@\"%@\", NSStringFromClass([self class]));\n\t        NSLog(@\"%@\", NSStringFromClass([super class]));\n\t    }\n\t    return self;\n\t}\n\t@end\n\t\n都输出：Son，答案：http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1)%5Bnil%5D-self-and-super/\n\n\t2014-11-05 11:06:18.060 Test[8566:568584] NSStringFromClass([self class]) = Son\n\t2014-11-05 11:06:18.061 Test[8566:568584] NSStringFromClass([super class]) = Son\n\n解惑：这个题目主要是考察关于objc中对 self 和 super 的理解。\n\nself 是类的隐藏参数，指向当前调用方法的这个类的实例。而 super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者。上面的例子不管调用[self class]还是[super class]，接受消息的对象都是当前 Son ＊xxx 这个对象。而不同的是，super是告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。\n\n当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法。\n\n真的是这样吗？继续看：\n\n使用clang重写命令:\n\n\t$ clang -rewrite-objc test.m\n发现上述代码被转化为:\n\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_0, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(\"class\"))));\n\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_1, NSStringFromClass(((Class (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){ (id)self, (id)class_getSuperclass(objc_getClass(\"Son\")) }, sel_registerName(\"class\"))));\n    \n从上面的代码中，我们可以发现在调用`[self class]`时，会转化成`objc_msgSend`函数。看下函数定义：\n\n\tid objc_msgSend(id self, SEL op, ...)\n我们把`self`做为第一个参数传递进去。\n\n而在调用`[super class]`时，会转化成`objc_msgSendSuper`函数。看下函数定义:\n\n\tid objc_msgSendSuper(struct objc_super *super, SEL op, ...)\n第一个参数是`objc_super`这样一个结构体，其定义如下:\n\n\tstruct objc_super {\n\t   __unsafe_unretained id receiver;\n\t   __unsafe_unretained Class super_class;\n\t};\n结构体有两个成员，第一个成员是`receiver`, 类似于上面的`objc_msgSend`函数第一个参数`self`。第二个成员是记录当前类的父类是什么。\n\n所以，当调用`[self class]`时，实际先调用的是`objc_msgSend`函数，第一个参数是`Son`当前的这个实例，然后在`Son`这个类里面去找 `- (Class)class`这个方法，没有，去父类 Father里找，也没有，最后在 NSObject类中发现这个方法。而 `- (Class)class`的实现就是返回self的类别，故上述输出结果为 Son。\n\nobjc Runtime开源代码对- (Class)class方法的实现:\n\n\t- (Class)class {\n\t    return object_getClass(self);\n\t}\n而当调用`[super class]`时，会转换成`objc_msgSendSuper`函数。第一步先构造`objc_super`结构体，结构体第一个成员就是 self 。第二个成员是 `(id)class_getSuperclass(objc_getClass(“Son”)) `, 实际该函数输出结果为 Father。第二步是去 Father这个类里去找`- (Class)class`，没有，然后去NSObject类去找，找到了。最后内部是使用` objc_msgSend(objc_super->receiver, @selector(class))`去调用，此时已经和`[self class]`调用相同了，故上述输出结果仍然返回 `Son`。\n\n> 参考：http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1)%5Bnil%5D-self-and-super/\n\t\n### [*]runtime 如何实现 weak 属性?\n\n`weak`修饰符是ARC下引入的修饰符，其和`assign`表示相同，表示`nonowning relationship`(非拥有关系)，对于被`weak`修饰的对象，当其所引用的对象的引用计数为0的时候，该对象就为被值为nil。这个过程是依靠Runtime来实现的，当Runtime载入并注册类，会对内存布局，把类中每个被`weak`修饰的属性加入多一个与该类相关的哈希表结构中，此结构以该对象的地址为key，当该对象的引用计数为0的时候，就会调用dealloc方法，该方法会检索此哈希表，找到所有key为该地址的所有对象，并把它们设值成nil。\n\n### [※※※※]runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）\n\n我们看一下`@selector(methodName:)`返回一个`SEL`类型:\n\n\ttypedef struct objc_selector *SEL;\n\t\n\tstruct objc_selector\n\t{\n\t  void *sel_id;\n\t  const char *sel_types;\n\t};\n\t\n上面的结构是在网上搜索到的，但是我在objc/runtime.h中没有找到objc_selector的定义。\n\n> https://sourceware.org/svn/gcc/tags/stack-last-merge/libobjc/objc/objc.h\n\n这里指明了objc.h是GCC中的一个文件`This file is part of GCC.`。\n\nObjective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL。所以在Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行。相同的方法只能对应一个SEL。这也就导致Objective-C在处理相同方法名且参数个数相同但类型不同的方法方面的能力很差。如在某个类中定义以下两个方法：\n\t\n\t- (void)setWidth:(int)width;\n\t\n\t- (void)setWidth:(double)width;\n这样的定义被认为是一种编译错误，所以我们不能像C++, C#那样。而是需要像下面这样来声明：\n\n\t-(void)setWidthIntValue:(int)width;\n\t\n\t-(void)setWidthDoubleValue:(double)width;\n当然，不同的类可以拥有相同的selector，这个没有问题。不同类的实例对象执行相同的selector时，会在各自的方法列表中去根据selector去寻找自己对应的IMP。<br/>\n\n工程中的所有的SEL组成一个Set集合，Set的特点就是唯一，因此SEL是唯一的。因此，如果我们想到这个方法集合中查找某个方法时，只需要去找到这个方法对应的SEL就行了，SEL实际上就是根据方法名hash化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，可以说速度上无语伦比！！但是，有一个问题，就是数量增多会增大hash冲突而导致的性能下降（或是没有冲突，因为也可能用的是perfect hash）。但是不管使用什么样的方法加速，如果能够将总量减少（多个方法可能对应同一个SEL），那将是最犀利的方法。那么，我们就不难理解，为什么SEL仅仅是函数名了。\n\n本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。这个查找过程我们将在下面讨论。\n\n我们可以在运行时添加新的selector，也可以在运行时获取已存在的selector，我们可以通过下面三种方法来获取SEL:\n\n1. sel_registerName函数\n2. Objective-C编译器提供的@selector()\n3. NSSelectorFromString()方法\n\nIMP实际上是一个函数指针，指向方法实现的首地址。其定义如下：\n\n\tid (*IMP)(id, SEL, ...)\n\t\n介绍完SEL和IMP，我们就可以来讲讲Method了。Method用于表示类定义中的方法，则定义如下：\n\n\ttypedef struct objc_method *Method;\n\t\n\t\n\t\n\tstruct objc_method {\n\t\n\t    SEL method_name                 OBJC2_UNAVAILABLE;  // 方法名\n\t\n\t    char *method_types                  OBJC2_UNAVAILABLE;\n\t\n\t    IMP method_imp                      OBJC2_UNAVAILABLE;  // 方法实现\n\t\n\t}  \n我们可以看到该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。\n\t\n对于每一个实例对象它会有一个isa指针，该指针指向该实例对象的类对象，它是一个objc_class的结构体，该结构题中的objc_method_list内包含了该对象的所有实例方法，对于类方法，每个类对象中又有一个isa指针指向该类对象的元类，元类objc_class结构的objc_method_list结构中存储着该类的所有类方法。Runtime通过查找这两个类来获取方法的IMP。\n\n> 参考：http://southpeak.github.io/blog/2014/11/03/objective-c-runtime-yun-xing-shi-zhi-san-:fang-fa-yu-xiao-xi-zhuan-fa/\n\n### [※※※※]使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？\n不需要（ARC下和MRC），`overfllow`的一句话`Associated objects are released after the dealloc method of the original object has finished.`。通过源码我们可以得知关联对象是通过一个单例类`AssociationsManager`实例维护一个哈希列表`AssociationsHashMap`实现的。而map的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。\n\n而在对象的销毁逻辑里面，当对象的引用计数为0的时候，Runloop在清理对象的时候会调用对象的`dealloc`,该方法会调用`object_dispose`方法来清理对象，在`object_dispose`步会对关联对象进行清理。源代码见`objc-runtime-new.mm`:\n\n\tvoid *objc_destructInstance(id obj) \n\t{\n\t    if (obj) {\n\t        Class isa_gen = _object_getClass(obj);\n\t        class_t *isa = newcls(isa_gen);\n\t\n\t        // Read all of the flags at once for performance.\n\t        bool cxx = hasCxxStructors(isa);\n\t        bool assoc = !UseGC && _class_instancesHaveAssociatedObjects(isa_gen);\n\t\n\t        // This order is important.\n\t        if (cxx) object_cxxDestruct(obj);\n\t        if (assoc) _object_remove_assocations(obj);\n\t\n\t        if (!UseGC) objc_clear_deallocating(obj);\n\t    }\n\t\n\t    return obj;\n\t}\n\t\nRuntime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作。\n\n### [※※※※※]objc中的类方法和实例方法有什么本质区别和联系？\n\n### [※※※※※]_objc_msgForward函数是做什么的，直接调用它将会发生什么？\n### [※※※※※]runtime如何实现weak变量的自动置nil？\n\n### [※※※※※]能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\n\n不能向遍以后得到的类中增加实例变量，但是能够向运行时创建的类中添加实例变量。\n\n\tclass_addIvar\n\n> This function may only be called after objc_allocateClassPair and before objc_registerClassPair. \n> Adding an instance variable to an existing class is not supported.\n\n> Objective-C不支持往已存在的类中添加实例变量，因此不管是系统库提供的提供的类，还是我们自定义的类，都无法动态添加成员变量。但如果我们通过运行时来创建一个类的话，又应该如何给它添加成员变量呢？这时我们就可以使用class_addIvar函数了。不过需要注意的是，这个方法只能在objc_allocateClassPair函数与objc_registerClassPair之间调用。另外，这个类也不能是元类。成员变量的按字节最小对齐量是1<<alignment。这取决于ivar的类型和机器的架构。如果变量的类型是指针类型，则传递log2(sizeof(pointer_type))。\n\n> 文／西木（简书作者）\n> 原文链接：http://www.jianshu.com/p/6b905584f536\n\n\n### [※※※]runloop和线程有什么关系？\n\n### [※※※]runloop的mode作用是什么？\n\n### [※※※※]以+ scheduledTimerWithTimeInterval...的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？\n\n### [※※※※※]猜想runloop内部是如何实现的？\n\n### [※]objc使用什么机制管理对象内存？\n\n### [※※※※]ARC通过什么方式帮助开发者管理内存？\n\n### [※※※※]不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）\n\n### [※※※※]BAD_ACCESS在什么情况下出现？\n\n### [※※※※※]苹果是如何实现autoreleasepool的？\n\n### [※※]使用block时什么情况会发生引用循环，如何解决？\n\n### [※※]在block内如何修改block外部变量？\n\n### [※※※]使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？\n\n### [※※]GCD的队列（dispatch_queue_t）分哪两种类型？\n\n### [※※※※]如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\n\n### [※※※※]dispatch_barrier_async的作用是什么？\n\n### [※※※※※]苹果为什么要废弃dispatch_get_current_queue？\n\n### [※※※※※]以下代码运行结果如何？\n\n\t- (void)viewDidLoad\n\t{\n\t    [super viewDidLoad];\n\t    NSLog(@\"1\");\n\t    dispatch_sync(dispatch_get_main_queue(), ^{\n\t        NSLog(@\"2\");\n\t    });\n\t    NSLog(@\"3\");\n\t}\n### [※※]addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？\n\n### [※※※]如何手动触发一个value的KVO?\n\n### [※※※]若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？\n\n### [※※※※]KVC的keyPath中的集合运算符如何使用？\n\n### [※※※※]KVC和KVO的keyPath一定是属性么？\n\n### [※※※※※]如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？\n\n### [※※※※※]apple用什么方式实现对一个对象的KVO？\n\n### [※※]IBOutlet连出来的视图属性为什么可以被设置成weak?\n\n### [※※※※※]IB中User Defined Runtime Attributes如何使用？\n\n### [※※※]如何调试BAD_ACCESS错误?\n\n### [※※※]lldb（gdb）常用的调试命令？","slug":"interview-checklist","published":1,"updated":"2016-06-28T10:33:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzbicg6000gsiftz0wwx8z8","content":"<h1 id=\"常见的iOS面试题\"><a href=\"#常见的iOS面试题\" class=\"headerlink\" title=\"常见的iOS面试题\"></a>常见的iOS面试题</h1><p>由于空闲时间比较喜欢在网上看一些大牛的技术blog，今天刚好看到大牛sunnyxx的一个关于他面试别人时提到的一些常见问题（<a href=\"http://blog.sunnyxx.com/2015/07/04/ios-interview/\" target=\"_blank\" rel=\"external\">原文地址</a>），所以自己也就试着回答了一遍，也算时对自己的一次面试吧，通过自己面试时间也发现了一些自己不足的一面，所以今天记录下来，加深一下印象吧。<br></p>\n<font color=\"red\"><strong>另外这里有一份 <a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md\" target=\"_blank\" rel=\"external\">详细答案</a> 分析的很到位</strong></font>\n\n<h3 id=\"※-property中有哪些属性关键字？\"><a href=\"#※-property中有哪些属性关键字？\" class=\"headerlink\" title=\"[※]@property中有哪些属性关键字？\"></a>[※]@property中有哪些属性关键字？</h3><p>在@property 中的关键词个人总结分为三类：RC语意修饰符，线程安全修饰符，读写属性修饰符。</p>\n<h4 id=\"RC语意修饰符\"><a href=\"#RC语意修饰符\" class=\"headerlink\" title=\"RC语意修饰符\"></a>RC语意修饰符</h4><p>这类修饰符主要为了在ARC或者MRC下一个属性的内存管理方法，共如下几种：<br><br><code>assign</code>： 简单的赋值，不会改变引用计数，共享内存；一般用于基本类型（c/c++：int float等，OC:NSInteger,BOOL等）<br><br><code>retain</code>： 处理简单赋值外会对赋值对象的引用计数加1操作，用于OC对象；<br><br><code>copy</code>：处理简单赋值，但是赋值对象引用计数不变，被赋值对象引用计数为1，也就是新生成一个与被赋值对象一样的数据（非绝对 如NSArray对象）<br><br><code>unsafe_unretained</code>：简单赋值，与assign相似，多用于修饰OC对象，只是表显该对象是不安全的（当赋值对象变为nil的时候会引起crash 野指针问题）<br><br><code>strong</code>：ARC中简单赋值，与非ARC下的retain相同作用<br><br><code>weak</code>：ARC中简单赋值，与非ARC下的assign对应，但是又有不同，weak多用于修饰OC对象，且当改对象的引用计数为0的时候，改对象会被修改成nil，而assign则不会，好处时能有效的防止野指针<br></p>\n<h4 id=\"线程安全修饰符\"><a href=\"#线程安全修饰符\" class=\"headerlink\" title=\"线程安全修饰符\"></a>线程安全修饰符</h4><p>这类修饰符主要是指定属性赋值操作的线程安全性<br><br><code>atomic</code>：线程安全的，多线程访问情况下只有一个线程能访问他，影响访问速度<br><br><code>nonatomic</code>：非线程安全的，多线程可同时读写，容易造成混乱，但读写速度快<br></p>\n<h4 id=\"读写属性修饰符\"><a href=\"#读写属性修饰符\" class=\"headerlink\" title=\"读写属性修饰符\"></a>读写属性修饰符</h4><p>这类修饰符主要控制属性的读写权限<br><br><code>readonly</code>: 编译器只会对该属性生成get方法<br><br><code>readwrite</code>: 编译器能生成get/set方法，默认此属性<br><br>另外get方法可以在修饰符最后指定，比如：<code>@property(getter = isGirl) BOOL girl</code></p>\n<h3 id=\"怎么用-copy-关键字？\"><a href=\"#怎么用-copy-关键字？\" class=\"headerlink\" title=\"[*]怎么用 copy 关键字？\"></a>[*]怎么用 copy 关键字？</h3><ol>\n<li>NSString，NSArray，NSDictionary类型属性常用，因为它们有NSMutableString,NSMutableArray,NSMutableDictionary类型属性，当我们不想外界干扰我们正在操作的这类型属性的时候，我们会把她们设置成copy。</li>\n<li>在使用block的时候我们用copy，在MRC时代，block是创建在栈上的，所以当我们把block进行赋值时不进行copy操作的话，block内的变量会因为栈的pop而造成野指针，从而引起crash。当然在ARC下，block会自动进行copy，但是作为程序员团队协作开发，能明确让别人看到block是经过copy到堆上的对象则更加具有易读性。<h3 id=\"这个写法会出什么问题：-property-copy-NSMutableArray-array\"><a href=\"#这个写法会出什么问题：-property-copy-NSMutableArray-array\" class=\"headerlink\" title=\"[]这个写法会出什么问题： @property (copy) NSMutableArray array;\"></a>[<em>]这个写法会出什么问题： @property (copy) NSMutableArray </em>array;</h3></li>\n<li>把NSMutableArray 属性设置成copy，无论赋值对象是NSArray还是NSMutableArray赋值后array指向的是NSArray对象，但我们往往会因为array的声明NSMutableArray＊ 而把它当成一个可变对象来操作，一旦调用了array的[array removeAtIndex:n],等不属于NSArray的方法后会引起Crash。</li>\n<li>属性修饰符没有加nonatomic，那么array会被编译器默认设置为atomic，atomic表示该属性是原则性操作，每次setter都会加锁来确保它的原子性，这将耗费大量运算。</li>\n</ol>\n<h3 id=\"如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？\"><a href=\"#如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？\" class=\"headerlink\" title=\"[*]如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？\"></a>[*]如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</h3><p>想要自己的类能够使用copy修饰符则必须让自己的类实现NSCopying协议，如果自己的类像NSString那样大小有可变版本和不可变版本，那么就是实现NSCopying协议和NSMutalbeCopying协议。</p>\n<p>具体步骤：</p>\n<ol>\n<li>声明该类遵从NSCopying协议。</li>\n<li><p>在该类中实现下面方法,并且注意对象copy是否需要深拷贝操作。</p>\n<ul>\n<li>(id)copyWithZone:(NSZone *)zone;</li>\n</ul>\n</li>\n</ol>\n<p>至于重写带copy关键字的setter的话一般如下：</p>\n<pre><code>- (void)setCustomClass:(CustomClass *)customClass\n{\n    _customClass = [customClass copy];\n}\n</code></pre><p>但是由于遵循NSCopying协议的类一般都是用作只读属性，所以我们就不去实现setter方法，而是在类initializer的时候对其进行初始化。例如：</p>\n<pre><code>- (instancetype)initWithCustomClass:(CustomClass *)cClass\n{\n    if(self == [super init]){\n        _cClass = [cClass copy];\n    }\n    return self;\n}\n</code></pre><h3 id=\"property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的\"><a href=\"#property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的\" class=\"headerlink\" title=\"[*]@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的?\"></a>[*]@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的?</h3><p><font color=\"red\" size=\"5px\"><strong>此为盗取答案：</strong></font></p>\n<h4 id=\"property-的本质是什么？\"><a href=\"#property-的本质是什么？\" class=\"headerlink\" title=\"@property 的本质是什么？\"></a>@property 的本质是什么？</h4><blockquote>\n<p>@property = (ivar + getter + setter)<br>“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。</p>\n</blockquote>\n<p>“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 Objective-C 2.0 的一部分。 而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。 正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:</p>\n<blockquote>\n<p>编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。 所以你也可以这么说：<br>@property = getter + setter;</p>\n</blockquote>\n<h4 id=\"ivar、getter、setter-是如何生成并添加到这个类中的\"><a href=\"#ivar、getter、setter-是如何生成并添加到这个类中的\" class=\"headerlink\" title=\"ivar、getter、setter 是如何生成并添加到这个类中的?\"></a>ivar、getter、setter 是如何生成并添加到这个类中的?</h4><blockquote>\n<p>“自动合成”( autosynthesis)<br>完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字.</p>\n</blockquote>\n<pre><code>@implementation Person\n@synthesize firstName = _myFirstName;\n@synthesize lastName = _myLastName;\n@end\n</code></pre><blockquote>\n<p>我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西</p>\n<ol>\n<li>OBJC<em>IVAR</em>$类名$属性名称 ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，</li>\n<li>表示该变量距离存放对象的内存区域的起始地址有多远。</li>\n<li>setter 与 getter 方法对应的实现函数</li>\n<li>ivar_list ：成员变量列表</li>\n<li>method_list ：方法列表</li>\n<li>prop_list ：属性列表</li>\n</ol>\n<p>也就是说我们每次在增加一个属性,系统都会在 ivar_list 中添加一个成员变量的描述,在 method_list 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.</p>\n</blockquote>\n<h3 id=\"protocol-和-category-中如何使用-property\"><a href=\"#protocol-和-category-中如何使用-property\" class=\"headerlink\" title=\"[*]@protocol 和 category 中如何使用 @property ?\"></a>[*]@protocol 和 category 中如何使用 @property ?</h3><p><code>@property</code>是封装数据的方式，我们一般不再<code>@protocol</code>和<code>category</code>中使用<code>@property</code>，而是在<code>class_continuation分类</code>中, 查看OC源码我们知道objc_struct结构中，成员变量的偏移量是放到<code>ivar_list</code>中的，是指针加偏移量来进行寻址操作的,OC把实例变量当作一种存储偏移量所用的“特殊变量”，并交由“类对象”来管理，偏移量会在运行时进行查找，如果类的定义变了，那么存储的偏移量也就变了，这样的话，无论何时访问实例变量，总能使用正确的偏移量，也就是说这些偏移量是是在编译时期生成的，所以不能在运行时期向类内加入实例变量。这和方法列表<code>method_list</code>不同的是，方法列表中结构中存的不是偏移量，而是方法指针的指针，也就是说每个方法我们可以修改其实现为任意实现地址。<br><br>虽然我们不能通过在<code>@protocol</code>和<code>category</code>中添加实例变量，但是我们可以通过<code>@property</code>+<code>@dynamic</code>+<code>关联</code>来达到新增实例相同的结果。</p>\n<blockquote>\n<p>参考资料：<a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html\" target=\"_blank\" rel=\"external\">https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html</a></p>\n</blockquote>\n<ol>\n<li>在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性</li>\n<li><p>category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给<br>category 增加属性的实现,需要借助于运行时的两个函数：</p>\n<p> objc_setAssociatedObject<br> objc_getAssociatedObject</p>\n</li>\n</ol>\n<p>Runtime给我们提供了这两个方法来达到这个目的，这些关联是通过一个<code>AssociationsManager</code>实例维护一个哈西列表<code>AssociationsHashMap</code>实现的。</p>\n<h3 id=\"※-weak属性需要在dealloc中置nil么？\"><a href=\"#※-weak属性需要在dealloc中置nil么？\" class=\"headerlink\" title=\"[※]weak属性需要在dealloc中置nil么？\"></a>[※]weak属性需要在dealloc中置nil么？</h3><p>不需要，因为被weak修饰符修饰的属性当其引用计数为0的时候，自动引用计数器会自动把属性设置为nil</p>\n<h3 id=\"※※-synthesize和-dynamic分别有什么作用？\"><a href=\"#※※-synthesize和-dynamic分别有什么作用？\" class=\"headerlink\" title=\"[※※]@synthesize和@dynamic分别有什么作用？\"></a>[※※]@synthesize和@dynamic分别有什么作用？</h3><p><code>@synthesize</code>: 该修饰符告诉编译器在编译期自动为该属性生成getter/setter方法，并可指明该属性对应的成员变量。<br><code>@dynamic</code>: 告诉编译器，不自动生成getter/setter方法，避免编译期间产生警告,然后由自己实现存取方法或存取方法在运行时动态创建绑定：主要使用在CoreData的实现NSManagedObject子类时使用，由Core Data框架在程序运行的时动态生成子类属性</p>\n<h3 id=\"※※※-ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？\"><a href=\"#※※※-ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？\" class=\"headerlink\" title=\"[※※※]ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？\"></a>[※※※]ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</h3><p>内存管理默认<code>strong</code>,  原子性默认<code>atomic</code>,读写性默认<code>readwrite</code>;</p>\n<h3 id=\"※※※-用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？\"><a href=\"#※※※-用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？\" class=\"headerlink\" title=\"[※※※]用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？\"></a>[※※※]用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</h3><p>对源头是NSMutableString的字符串，strong仅仅是指针引用，增加了引用计数器，这样源头改变的时候，用这种strong方式声明的变量（无论被赋值的变量是可变的还是不可变的），它也会跟着改变;而copy声明的变量，它不会跟着源头改变，它实际上是深拷贝的“备份”。<br><br>对源头是NSString的字符串，无论是strong声明的变量还是copy声明的变量，当第二次源头的字符串重新指向其它的地方的时候，它还是指向原来的最初的那个位置（因为常量字符串分配在一个常量内存区），也就是说其实二者都是指针引用，也就是浅拷贝。<br></p>\n<p>而对于NSMutableArray和NSMutableDictionary情况是和NSMutableString是一样的，strong情况下是传引用，并且引用计数加1，copy情况下是产生一个深拷贝“备份”，并且这个备份变成了一个不可变的NSArray或NSDictionary<br><br>对于NSArray和NSDictionary在strong情况下传引用，并且引用计数加1，copy情况下是产生一个深拷贝“备份”，并且这个备份变成了一个不可变的NSArray或NSDictionary。<br></p>\n<p>对于NSString，NSArray，NSDictionary我们经常用copy关键字是因为这些类型的对象不可变，我们只需要使用其一个备份就可以。另外，NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份，所以我们也会用copy修饰符。<br><br>如果改用strong关键字修饰的话，试图去修改这些不可改变大小的对象而参数数据混乱（更改了一个原不想修改的数据）。</p>\n<h3 id=\"※※※-synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为-foo的实例变量，那么还会自动合成新变量么？\"><a href=\"#※※※-synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为-foo的实例变量，那么还会自动合成新变量么？\" class=\"headerlink\" title=\"[※※※]@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？\"></a>[※※※]@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？</h3><blockquote>\n<p>引用答案的一句话：<code>实例变量 == 成员变量 == ivar</code></p>\n</blockquote>\n<p><code>@synthesize</code> 合成变量的规则是绑定成员属性getter/setter方法到某个成员变量，这个过程叫自动合成，你可以指定成员变量，也可以不指定，如果不指定，则这个成员变量的名字与属性名字相同，在没有<code>@synthesize</code>绑定情况下系统会自动生成一个“<em>属性名”的一个成员变量，并绑定getter/setter方法到“</em>属性名”成员变量。如果已经存在“_属性名”，则编译器不会再自动合成新变量。</p>\n<p>例如.h文件,用<code>@property</code>声明了一个FooClass类型的成员属性 <code>foo</code>：<br></p>\n<pre><code>class FooLcass : NSObject\n{\n    FooClass* _foo; //实例变量\n}\n\n@property (strong, nonatomic) FooClass* foo; //成员属性\n</code></pre><p>在.m代码如下：</p>\n<pre><code>@synthesize foo = _foo;\n</code></pre><h3 id=\"※※-什么情况下不会autosynthesis（自动合成）\"><a href=\"#※※-什么情况下不会autosynthesis（自动合成）\" class=\"headerlink\" title=\"[※※]什么情况下不会autosynthesis（自动合成）?\"></a>[※※]什么情况下不会autosynthesis（自动合成）?</h3><ol>\n<li>同时重写了 setter 和 getter 时</li>\n<li>重写了只读属性的 getter 时</li>\n<li>使用了 @dynamic 时</li>\n<li>在 @protocol 中定义的所有属性</li>\n<li>在 category 中定义的所有属性</li>\n<li>重载的属性当你在子类中重载了父类中的属性，你必须 使用 @synthesize 来手动合成ivar。</li>\n</ol>\n<h3 id=\"※※※※※-在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？\"><a href=\"#※※※※※-在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？\" class=\"headerlink\" title=\"[※※※※※]在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？\"></a>[※※※※※]在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</h3><ol>\n<li>手动合成ivar（手动管理property，不使用自动合成autosynthesis）</li>\n<li>重载父类的属性 当子类重载了父类的属性石，必须手动指定ivar</li>\n<li>以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字</li>\n</ol>\n<h3 id=\"※※-objc中向一个nil对象发送消息将会发生什么？\"><a href=\"#※※-objc中向一个nil对象发送消息将会发生什么？\" class=\"headerlink\" title=\"[※※]objc中向一个nil对象发送消息将会发生什么？\"></a>[※※]objc中向一个nil对象发送消息将会发生什么？</h3><p>之前理解如果objc是nil，那么向nil对象发生消息将什么也不会发生（对象方法没有正常执行并且也没有引起crash），这些虽然从表象上看是正确的，但是在运行时Runtime中却发生了一系列变化。首先Runtime会动态转化方法调用为消息发送，调用objc_msgSend(receiver,selecter,argv,…),objc_msgSend是不会返回值，他只是起到消息转发的作用，整个过程就是objc_Send根据reciver找到该实例对象的类对象，然后从该类对象的方法列表objc_method_list中找到对应的IMP，然后把参数传给IMP进行方法调用，最后把IMP函数指针指定的方法只需结果返回。由于receiver参数是nil，也就是该类对象的isa指针指向为nil(0)，objc_msgSend也就返回nil(0).</p>\n<p>另外附上objc的一个结构定义</p>\n<pre><code>// runtime.h（类在runtime中的定义）\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n\nstruct objc_class {\n  Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object\n  #if !__OBJC2__\n  Class super_class OBJC2_UNAVAILABLE; // 父类\n  const char *name OBJC2_UNAVAILABLE; // 类名\n  long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0\n  long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识\n  long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小\n  struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表\n  struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表\n  struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。\n  struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表\n  #endif\n  } OBJC2_UNAVAILABLE;\n</code></pre><h3 id=\"※※※-objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？\"><a href=\"#※※※-objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？\" class=\"headerlink\" title=\"[※※※]objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？\"></a>[※※※]objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</h3><p>Runtime运行原理就如上描述一致，消息发生会被转发objc_msgSend((id)obj,@selecter(foo));除此之外对于“边界情况”，如果消息是发给父类的例如：[super foo]那么消息会被转发objc_msgSendSuper((id)obj,@selecter(foo));如果foo消息返回的是结构体，那么消息转换会变成objc_msgSend_stret((id)obj,@selecter(foo));如果foo消息返回的是浮点型数据，那么消息转换成objc_msgSend_fpret((id)obj,@selecter(foo));<br>这些转换都是在动态编译的时候进行转换的。</p>\n<h3 id=\"※※※-什么时候会报unrecognized-selector的异常？\"><a href=\"#※※※-什么时候会报unrecognized-selector的异常？\" class=\"headerlink\" title=\"[※※※]什么时候会报unrecognized selector的异常？\"></a>[※※※]什么时候会报unrecognized selector的异常？</h3><p>“unrecognized selecter”中文翻译就是无法识别的方法，当实例对象或者类对象发送一个该对象objc_method_list/objc_protocol_list没有对应方法的时候，NSObject就是抛出异常。<br><br>在Runtime抛出异常之间还可做很多事情来处理这种异常，这要依赖于NSObject的消息转发机制。<br><br>首先在Class中的缓存查找IMP（没缓存则初始化缓存），如果没找到，则向父类的Class查找。如果一直查找到根类仍旧没有实现，则用_objc_msgForward函数指针代替IMP。最后，执行这个IMP。<br><br>_objc_msgForward是用于消息转发的。这个函数的实现并没有在objc-runtime的开源代码里面，而是在Foundation框架里面实现的。__CFInitialize这个方法会调用objc_setForwardHandler函数来注册一个实现。<br><br>_objc_msgForward消息转发做了如下几件事：</p>\n<p>征询接受者看其是否能动态添加方法，以处理当前这个“未知的选择子”（这叫动态方法解析）即调用：</p>\n<pre><code>+ (BOOL)resolveInstanceMethod:(SEL)selecter;//实例对象的处理方法\n+ (BOOL)resolveClassMethod:(SEL)selecter;//类对象的处理方法    \n</code></pre><p>该方法的参数就是哪个未知的选择子，我们可以在这里处理哪些没有被objc_msgSend找到的方法。<br><br>假如在这个阶段还是没有处理这个未知的SEL，那么该SEL会被转发到备用接受者</p>\n<pre><code>- (id)forwardingTargetForSelecter:(SEL)selecter;\n</code></pre><p>这个方法返回指定的能够处理该消息的实例对象或者类对象。<br><br>如果没有备用接收者，那么就启用完整的转发机制，就是把尚未处理的那条消息的全部信息（选择子，目标，参数）封装成NSInvocation对象，并触发NSinvocation对象，让“消息派发系统”把消息指派给目标对象。即调用:</p>\n<pre><code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;//获取方法签名信息\n- (void)forwardInvocation:(NSInvocation*)invocaton;\n</code></pre><p>消息派发系统依照类的继承关系逐一寻找能够处理该NSInvacation的对象，直到NSObject，如果最后调用了NSObject类方法，那么该方法还会继续调用<code>doesNotRecognizeSelecter:</code>以抛出异常。</p>\n<p>最后陪一个能够理解的图：<br><img src=\"http://7xoo3c.com1.z0.glb.clouddn.com/blogmethod_forwarding.png\" alt=\"消息转发机制流程图\" title=\"消息转发机制流程图\"></p>\n<h3 id=\"※※※※-一个objc对象如何进行内存布局？（考虑有父类的情况）\"><a href=\"#※※※※-一个objc对象如何进行内存布局？（考虑有父类的情况）\" class=\"headerlink\" title=\"[※※※※]一个objc对象如何进行内存布局？（考虑有父类的情况）\"></a>[※※※※]一个objc对象如何进行内存布局？（考虑有父类的情况）</h3><ul>\n<li>一个objc对象的存储空间中保存着该对象的所有实例变量和该对象所有父类的所有实例变量</li>\n<li>每个对象都有一个isa指针，这个指针指向该objc对象的类对象，此类对象在Runtime环境中只有一份儿，并且和其它类对象有着相同的结构，此类对象中存储的是：</li>\n</ul>\n<p>typedef struct objc_class *Class;</p>\n<pre><code>/*\n  这是由编译器为每个类产生的数据结构,这个结构定义了一个类.\n  这个结构是通过编译器在执行时产生,在运行时发送消息时使用.\n  因此,一些成员改变了类型.\n  编译器产生&quot;char* const&quot;类型的字符串指针替代了下面的成员变量&quot;super_class&quot;\n*/\nstruct objc_class {\n  struct objc_class*  class_pointer;    /* 指向元类的指针. */\n  struct objc_class*  super_class;      /* 指向父类的指针. 对于NSObject来说是NULL.*/\n  const char*         name;             /* 类的名称. */\n  long                version;          /* 未知. */\n  unsigned long       info;             /* 比特蒙板.  参考下面类的蒙板定义. */\n  long                instance_size;    /* 类的字节数.包含类的定义和所有父类的定义 */\n#ifdef _WIN64\n  long pad;\n#endif\n  struct objc_ivar_list* ivars;         /* 指向类中定义的实例变量的列表结构. NULL代表没有实例变量.不包括父类的变量. */\n  struct objc_method_list*  methods;    /* 链接类中定义的实例方法. */\n  struct sarray *    dtable;            /* 指向实例方法分配表. */\n  struct objc_class* subclass_list;     /* 父类列表 */\n  struct objc_class* sibling_class;\n  struct objc_protocol_list *protocols; /* 要实现的原型列表 */\n  void* gc_object_type;\n};\n</code></pre><p>该类也有一个isa指针，它指向该类的元类，元类的作用类似于类作用于类对象，保存了该类的类方法信息。</p>\n<p>引用网上常列举的一张图：<br><img src=\"http://7xoo3c.com1.z0.glb.clouddn.com/blogmeta_calss.png\" alt=\"内存布局图\" title=\"类内存布局图\"></p>\n<h3 id=\"※※※※-一个objc对象的isa的指针指向什么？有什么作用？\"><a href=\"#※※※※-一个objc对象的isa的指针指向什么？有什么作用？\" class=\"headerlink\" title=\"[※※※※]一个objc对象的isa的指针指向什么？有什么作用？\"></a>[※※※※]一个objc对象的isa的指针指向什么？有什么作用？</h3><ol>\n<li>实例对象的isa指向该实例的类对象，类对象的isa指向该类的元类，元类的isa指向自己。</li>\n<li>类对象保存着该类的成员列表信息，方法列表信息等。元类保存着该类对象的类方法列表。</li>\n</ol>\n<h3 id=\"※※※※-下面的代码输出什么？\"><a href=\"#※※※※-下面的代码输出什么？\" class=\"headerlink\" title=\"[※※※※]下面的代码输出什么？\"></a>[※※※※]下面的代码输出什么？</h3><pre><code>@implementation Son : Father\n- (id)init\n{\n    self = [super init];\n    if (self) {\n        NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));\n        NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));\n    }\n    return self;\n}\n@end\n</code></pre><p>都输出：Son，答案：<a href=\"http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1)%5Bnil%5D-self-and-super/\" target=\"_blank\" rel=\"external\">http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1)%5Bnil%5D-self-and-super/</a></p>\n<pre><code>2014-11-05 11:06:18.060 Test[8566:568584] NSStringFromClass([self class]) = Son\n2014-11-05 11:06:18.061 Test[8566:568584] NSStringFromClass([super class]) = Son\n</code></pre><p>解惑：这个题目主要是考察关于objc中对 self 和 super 的理解。</p>\n<p>self 是类的隐藏参数，指向当前调用方法的这个类的实例。而 super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者。上面的例子不管调用[self class]还是[super class]，接受消息的对象都是当前 Son ＊xxx 这个对象。而不同的是，super是告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。</p>\n<p>当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法。</p>\n<p>真的是这样吗？继续看：</p>\n<p>使用clang重写命令:</p>\n<pre><code>$ clang -rewrite-objc test.m\n</code></pre><p>发现上述代码被转化为:</p>\n<pre><code>NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_0, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(&quot;class&quot;))));\n\nNSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_1, NSStringFromClass(((Class (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){ (id)self, (id)class_getSuperclass(objc_getClass(&quot;Son&quot;)) }, sel_registerName(&quot;class&quot;))));\n</code></pre><p>从上面的代码中，我们可以发现在调用<code>[self class]</code>时，会转化成<code>objc_msgSend</code>函数。看下函数定义：</p>\n<pre><code>id objc_msgSend(id self, SEL op, ...)\n</code></pre><p>我们把<code>self</code>做为第一个参数传递进去。</p>\n<p>而在调用<code>[super class]</code>时，会转化成<code>objc_msgSendSuper</code>函数。看下函数定义:</p>\n<pre><code>id objc_msgSendSuper(struct objc_super *super, SEL op, ...)\n</code></pre><p>第一个参数是<code>objc_super</code>这样一个结构体，其定义如下:</p>\n<pre><code>struct objc_super {\n   __unsafe_unretained id receiver;\n   __unsafe_unretained Class super_class;\n};\n</code></pre><p>结构体有两个成员，第一个成员是<code>receiver</code>, 类似于上面的<code>objc_msgSend</code>函数第一个参数<code>self</code>。第二个成员是记录当前类的父类是什么。</p>\n<p>所以，当调用<code>[self class]</code>时，实际先调用的是<code>objc_msgSend</code>函数，第一个参数是<code>Son</code>当前的这个实例，然后在<code>Son</code>这个类里面去找 <code>- (Class)class</code>这个方法，没有，去父类 Father里找，也没有，最后在 NSObject类中发现这个方法。而 <code>- (Class)class</code>的实现就是返回self的类别，故上述输出结果为 Son。</p>\n<p>objc Runtime开源代码对- (Class)class方法的实现:</p>\n<pre><code>- (Class)class {\n    return object_getClass(self);\n}\n</code></pre><p>而当调用<code>[super class]</code>时，会转换成<code>objc_msgSendSuper</code>函数。第一步先构造<code>objc_super</code>结构体，结构体第一个成员就是 self 。第二个成员是 <code>(id)class_getSuperclass(objc_getClass(“Son”))</code>, 实际该函数输出结果为 Father。第二步是去 Father这个类里去找<code>- (Class)class</code>，没有，然后去NSObject类去找，找到了。最后内部是使用<code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>去调用，此时已经和<code>[self class]</code>调用相同了，故上述输出结果仍然返回 <code>Son</code>。</p>\n<blockquote>\n<p>参考：<a href=\"http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1)%5Bnil%5D-self-and-super/\" target=\"_blank\" rel=\"external\">http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1)%5Bnil%5D-self-and-super/</a></p>\n</blockquote>\n<h3 id=\"runtime-如何实现-weak-属性\"><a href=\"#runtime-如何实现-weak-属性\" class=\"headerlink\" title=\"[*]runtime 如何实现 weak 属性?\"></a>[*]runtime 如何实现 weak 属性?</h3><p><code>weak</code>修饰符是ARC下引入的修饰符，其和<code>assign</code>表示相同，表示<code>nonowning relationship</code>(非拥有关系)，对于被<code>weak</code>修饰的对象，当其所引用的对象的引用计数为0的时候，该对象就为被值为nil。这个过程是依靠Runtime来实现的，当Runtime载入并注册类，会对内存布局，把类中每个被<code>weak</code>修饰的属性加入多一个与该类相关的哈希表结构中，此结构以该对象的地址为key，当该对象的引用计数为0的时候，就会调用dealloc方法，该方法会检索此哈希表，找到所有key为该地址的所有对象，并把它们设值成nil。</p>\n<h3 id=\"※※※※-runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）\"><a href=\"#※※※※-runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）\" class=\"headerlink\" title=\"[※※※※]runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）\"></a>[※※※※]runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</h3><p>我们看一下<code>@selector(methodName:)</code>返回一个<code>SEL</code>类型:</p>\n<pre><code>typedef struct objc_selector *SEL;\n\nstruct objc_selector\n{\n  void *sel_id;\n  const char *sel_types;\n};\n</code></pre><p>上面的结构是在网上搜索到的，但是我在objc/runtime.h中没有找到objc_selector的定义。</p>\n<blockquote>\n<p><a href=\"https://sourceware.org/svn/gcc/tags/stack-last-merge/libobjc/objc/objc.h\" target=\"_blank\" rel=\"external\">https://sourceware.org/svn/gcc/tags/stack-last-merge/libobjc/objc/objc.h</a></p>\n</blockquote>\n<p>这里指明了objc.h是GCC中的一个文件<code>This file is part of GCC.</code>。</p>\n<p>Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL。所以在Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行。相同的方法只能对应一个SEL。这也就导致Objective-C在处理相同方法名且参数个数相同但类型不同的方法方面的能力很差。如在某个类中定义以下两个方法：</p>\n<pre><code>- (void)setWidth:(int)width;\n\n- (void)setWidth:(double)width;\n</code></pre><p>这样的定义被认为是一种编译错误，所以我们不能像C++, C#那样。而是需要像下面这样来声明：</p>\n<pre><code>-(void)setWidthIntValue:(int)width;\n\n-(void)setWidthDoubleValue:(double)width;\n</code></pre><p>当然，不同的类可以拥有相同的selector，这个没有问题。不同类的实例对象执行相同的selector时，会在各自的方法列表中去根据selector去寻找自己对应的IMP。<br></p>\n<p>工程中的所有的SEL组成一个Set集合，Set的特点就是唯一，因此SEL是唯一的。因此，如果我们想到这个方法集合中查找某个方法时，只需要去找到这个方法对应的SEL就行了，SEL实际上就是根据方法名hash化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，可以说速度上无语伦比！！但是，有一个问题，就是数量增多会增大hash冲突而导致的性能下降（或是没有冲突，因为也可能用的是perfect hash）。但是不管使用什么样的方法加速，如果能够将总量减少（多个方法可能对应同一个SEL），那将是最犀利的方法。那么，我们就不难理解，为什么SEL仅仅是函数名了。</p>\n<p>本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。这个查找过程我们将在下面讨论。</p>\n<p>我们可以在运行时添加新的selector，也可以在运行时获取已存在的selector，我们可以通过下面三种方法来获取SEL:</p>\n<ol>\n<li>sel_registerName函数</li>\n<li>Objective-C编译器提供的@selector()</li>\n<li>NSSelectorFromString()方法</li>\n</ol>\n<p>IMP实际上是一个函数指针，指向方法实现的首地址。其定义如下：</p>\n<pre><code>id (*IMP)(id, SEL, ...)\n</code></pre><p>介绍完SEL和IMP，我们就可以来讲讲Method了。Method用于表示类定义中的方法，则定义如下：</p>\n<pre><code>typedef struct objc_method *Method;\n\n\n\nstruct objc_method {\n\n    SEL method_name                 OBJC2_UNAVAILABLE;  // 方法名\n\n    char *method_types                  OBJC2_UNAVAILABLE;\n\n    IMP method_imp                      OBJC2_UNAVAILABLE;  // 方法实现\n\n}  \n</code></pre><p>我们可以看到该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。</p>\n<p>对于每一个实例对象它会有一个isa指针，该指针指向该实例对象的类对象，它是一个objc_class的结构体，该结构题中的objc_method_list内包含了该对象的所有实例方法，对于类方法，每个类对象中又有一个isa指针指向该类对象的元类，元类objc_class结构的objc_method_list结构中存储着该类的所有类方法。Runtime通过查找这两个类来获取方法的IMP。</p>\n<blockquote>\n<p>参考：<a href=\"http://southpeak.github.io/blog/2014/11/03/objective-c-runtime-yun-xing-shi-zhi-san-:fang-fa-yu-xiao-xi-zhuan-fa/\" target=\"_blank\" rel=\"external\">http://southpeak.github.io/blog/2014/11/03/objective-c-runtime-yun-xing-shi-zhi-san-:fang-fa-yu-xiao-xi-zhuan-fa/</a></p>\n</blockquote>\n<h3 id=\"※※※※-使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？\"><a href=\"#※※※※-使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？\" class=\"headerlink\" title=\"[※※※※]使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？\"></a>[※※※※]使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</h3><p>不需要（ARC下和MRC），<code>overfllow</code>的一句话<code>Associated objects are released after the dealloc method of the original object has finished.</code>。通过源码我们可以得知关联对象是通过一个单例类<code>AssociationsManager</code>实例维护一个哈希列表<code>AssociationsHashMap</code>实现的。而map的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。</p>\n<p>而在对象的销毁逻辑里面，当对象的引用计数为0的时候，Runloop在清理对象的时候会调用对象的<code>dealloc</code>,该方法会调用<code>object_dispose</code>方法来清理对象，在<code>object_dispose</code>步会对关联对象进行清理。源代码见<code>objc-runtime-new.mm</code>:</p>\n<pre><code>void *objc_destructInstance(id obj) \n{\n    if (obj) {\n        Class isa_gen = _object_getClass(obj);\n        class_t *isa = newcls(isa_gen);\n\n        // Read all of the flags at once for performance.\n        bool cxx = hasCxxStructors(isa);\n        bool assoc = !UseGC &amp;&amp; _class_instancesHaveAssociatedObjects(isa_gen);\n\n        // This order is important.\n        if (cxx) object_cxxDestruct(obj);\n        if (assoc) _object_remove_assocations(obj);\n\n        if (!UseGC) objc_clear_deallocating(obj);\n    }\n\n    return obj;\n}\n</code></pre><p>Runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作。</p>\n<h3 id=\"※※※※※-objc中的类方法和实例方法有什么本质区别和联系？\"><a href=\"#※※※※※-objc中的类方法和实例方法有什么本质区别和联系？\" class=\"headerlink\" title=\"[※※※※※]objc中的类方法和实例方法有什么本质区别和联系？\"></a>[※※※※※]objc中的类方法和实例方法有什么本质区别和联系？</h3><h3 id=\"※※※※※-objc-msgForward函数是做什么的，直接调用它将会发生什么？\"><a href=\"#※※※※※-objc-msgForward函数是做什么的，直接调用它将会发生什么？\" class=\"headerlink\" title=\"[※※※※※]_objc_msgForward函数是做什么的，直接调用它将会发生什么？\"></a>[※※※※※]_objc_msgForward函数是做什么的，直接调用它将会发生什么？</h3><h3 id=\"※※※※※-runtime如何实现weak变量的自动置nil？\"><a href=\"#※※※※※-runtime如何实现weak变量的自动置nil？\" class=\"headerlink\" title=\"[※※※※※]runtime如何实现weak变量的自动置nil？\"></a>[※※※※※]runtime如何实现weak变量的自动置nil？</h3><h3 id=\"※※※※※-能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\"><a href=\"#※※※※※-能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\" class=\"headerlink\" title=\"[※※※※※]能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\"></a>[※※※※※]能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h3><p>不能向遍以后得到的类中增加实例变量，但是能够向运行时创建的类中添加实例变量。</p>\n<pre><code>class_addIvar\n</code></pre><blockquote>\n<p>This function may only be called after objc_allocateClassPair and before objc_registerClassPair.<br>Adding an instance variable to an existing class is not supported.</p>\n<p>Objective-C不支持往已存在的类中添加实例变量，因此不管是系统库提供的提供的类，还是我们自定义的类，都无法动态添加成员变量。但如果我们通过运行时来创建一个类的话，又应该如何给它添加成员变量呢？这时我们就可以使用class_addIvar函数了。不过需要注意的是，这个方法只能在objc_allocateClassPair函数与objc_registerClassPair之间调用。另外，这个类也不能是元类。成员变量的按字节最小对齐量是1&lt;&lt;alignment。这取决于ivar的类型和机器的架构。如果变量的类型是指针类型，则传递log2(sizeof(pointer_type))。</p>\n<p>文／西木（简书作者）<br>原文链接：<a href=\"http://www.jianshu.com/p/6b905584f536\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/6b905584f536</a></p>\n</blockquote>\n<h3 id=\"※※※-runloop和线程有什么关系？\"><a href=\"#※※※-runloop和线程有什么关系？\" class=\"headerlink\" title=\"[※※※]runloop和线程有什么关系？\"></a>[※※※]runloop和线程有什么关系？</h3><h3 id=\"※※※-runloop的mode作用是什么？\"><a href=\"#※※※-runloop的mode作用是什么？\" class=\"headerlink\" title=\"[※※※]runloop的mode作用是什么？\"></a>[※※※]runloop的mode作用是什么？</h3><h3 id=\"※※※※-以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？\"><a href=\"#※※※※-以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？\" class=\"headerlink\" title=\"[※※※※]以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？\"></a>[※※※※]以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</h3><h3 id=\"※※※※※-猜想runloop内部是如何实现的？\"><a href=\"#※※※※※-猜想runloop内部是如何实现的？\" class=\"headerlink\" title=\"[※※※※※]猜想runloop内部是如何实现的？\"></a>[※※※※※]猜想runloop内部是如何实现的？</h3><h3 id=\"※-objc使用什么机制管理对象内存？\"><a href=\"#※-objc使用什么机制管理对象内存？\" class=\"headerlink\" title=\"[※]objc使用什么机制管理对象内存？\"></a>[※]objc使用什么机制管理对象内存？</h3><h3 id=\"※※※※-ARC通过什么方式帮助开发者管理内存？\"><a href=\"#※※※※-ARC通过什么方式帮助开发者管理内存？\" class=\"headerlink\" title=\"[※※※※]ARC通过什么方式帮助开发者管理内存？\"></a>[※※※※]ARC通过什么方式帮助开发者管理内存？</h3><h3 id=\"※※※※-不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）\"><a href=\"#※※※※-不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）\" class=\"headerlink\" title=\"[※※※※]不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）\"></a>[※※※※]不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</h3><h3 id=\"※※※※-BAD-ACCESS在什么情况下出现？\"><a href=\"#※※※※-BAD-ACCESS在什么情况下出现？\" class=\"headerlink\" title=\"[※※※※]BAD_ACCESS在什么情况下出现？\"></a>[※※※※]BAD_ACCESS在什么情况下出现？</h3><h3 id=\"※※※※※-苹果是如何实现autoreleasepool的？\"><a href=\"#※※※※※-苹果是如何实现autoreleasepool的？\" class=\"headerlink\" title=\"[※※※※※]苹果是如何实现autoreleasepool的？\"></a>[※※※※※]苹果是如何实现autoreleasepool的？</h3><h3 id=\"※※-使用block时什么情况会发生引用循环，如何解决？\"><a href=\"#※※-使用block时什么情况会发生引用循环，如何解决？\" class=\"headerlink\" title=\"[※※]使用block时什么情况会发生引用循环，如何解决？\"></a>[※※]使用block时什么情况会发生引用循环，如何解决？</h3><h3 id=\"※※-在block内如何修改block外部变量？\"><a href=\"#※※-在block内如何修改block外部变量？\" class=\"headerlink\" title=\"[※※]在block内如何修改block外部变量？\"></a>[※※]在block内如何修改block外部变量？</h3><h3 id=\"※※※-使用系统的某些block-api（如UIView的block版本写动画时），是否也考虑引用循环问题？\"><a href=\"#※※※-使用系统的某些block-api（如UIView的block版本写动画时），是否也考虑引用循环问题？\" class=\"headerlink\" title=\"[※※※]使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？\"></a>[※※※]使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</h3><h3 id=\"※※-GCD的队列（dispatch-queue-t）分哪两种类型？\"><a href=\"#※※-GCD的队列（dispatch-queue-t）分哪两种类型？\" class=\"headerlink\" title=\"[※※]GCD的队列（dispatch_queue_t）分哪两种类型？\"></a>[※※]GCD的队列（dispatch_queue_t）分哪两种类型？</h3><h3 id=\"※※※※-如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\"><a href=\"#※※※※-如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\" class=\"headerlink\" title=\"[※※※※]如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\"></a>[※※※※]如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</h3><h3 id=\"※※※※-dispatch-barrier-async的作用是什么？\"><a href=\"#※※※※-dispatch-barrier-async的作用是什么？\" class=\"headerlink\" title=\"[※※※※]dispatch_barrier_async的作用是什么？\"></a>[※※※※]dispatch_barrier_async的作用是什么？</h3><h3 id=\"※※※※※-苹果为什么要废弃dispatch-get-current-queue？\"><a href=\"#※※※※※-苹果为什么要废弃dispatch-get-current-queue？\" class=\"headerlink\" title=\"[※※※※※]苹果为什么要废弃dispatch_get_current_queue？\"></a>[※※※※※]苹果为什么要废弃dispatch_get_current_queue？</h3><h3 id=\"※※※※※-以下代码运行结果如何？\"><a href=\"#※※※※※-以下代码运行结果如何？\" class=\"headerlink\" title=\"[※※※※※]以下代码运行结果如何？\"></a>[※※※※※]以下代码运行结果如何？</h3><pre><code>- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    NSLog(@&quot;1&quot;);\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@&quot;2&quot;);\n    });\n    NSLog(@&quot;3&quot;);\n}\n</code></pre><h3 id=\"※※-addObserver-forKeyPath-options-context-各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？\"><a href=\"#※※-addObserver-forKeyPath-options-context-各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？\" class=\"headerlink\" title=\"[※※]addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？\"></a>[※※]addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</h3><h3 id=\"※※※-如何手动触发一个value的KVO\"><a href=\"#※※※-如何手动触发一个value的KVO\" class=\"headerlink\" title=\"[※※※]如何手动触发一个value的KVO?\"></a>[※※※]如何手动触发一个value的KVO?</h3><h3 id=\"※※※-若一个类有实例变量NSString-foo，调用setValue-forKey-时，可以以foo还是-foo作为key？\"><a href=\"#※※※-若一个类有实例变量NSString-foo，调用setValue-forKey-时，可以以foo还是-foo作为key？\" class=\"headerlink\" title=\"[※※※]若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？\"></a>[※※※]若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？</h3><h3 id=\"※※※※-KVC的keyPath中的集合运算符如何使用？\"><a href=\"#※※※※-KVC的keyPath中的集合运算符如何使用？\" class=\"headerlink\" title=\"[※※※※]KVC的keyPath中的集合运算符如何使用？\"></a>[※※※※]KVC的keyPath中的集合运算符如何使用？</h3><h3 id=\"※※※※-KVC和KVO的keyPath一定是属性么？\"><a href=\"#※※※※-KVC和KVO的keyPath一定是属性么？\" class=\"headerlink\" title=\"[※※※※]KVC和KVO的keyPath一定是属性么？\"></a>[※※※※]KVC和KVO的keyPath一定是属性么？</h3><h3 id=\"※※※※※-如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？\"><a href=\"#※※※※※-如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？\" class=\"headerlink\" title=\"[※※※※※]如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？\"></a>[※※※※※]如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</h3><h3 id=\"※※※※※-apple用什么方式实现对一个对象的KVO？\"><a href=\"#※※※※※-apple用什么方式实现对一个对象的KVO？\" class=\"headerlink\" title=\"[※※※※※]apple用什么方式实现对一个对象的KVO？\"></a>[※※※※※]apple用什么方式实现对一个对象的KVO？</h3><h3 id=\"※※-IBOutlet连出来的视图属性为什么可以被设置成weak\"><a href=\"#※※-IBOutlet连出来的视图属性为什么可以被设置成weak\" class=\"headerlink\" title=\"[※※]IBOutlet连出来的视图属性为什么可以被设置成weak?\"></a>[※※]IBOutlet连出来的视图属性为什么可以被设置成weak?</h3><h3 id=\"※※※※※-IB中User-Defined-Runtime-Attributes如何使用？\"><a href=\"#※※※※※-IB中User-Defined-Runtime-Attributes如何使用？\" class=\"headerlink\" title=\"[※※※※※]IB中User Defined Runtime Attributes如何使用？\"></a>[※※※※※]IB中User Defined Runtime Attributes如何使用？</h3><h3 id=\"※※※-如何调试BAD-ACCESS错误\"><a href=\"#※※※-如何调试BAD-ACCESS错误\" class=\"headerlink\" title=\"[※※※]如何调试BAD_ACCESS错误?\"></a>[※※※]如何调试BAD_ACCESS错误?</h3><h3 id=\"※※※-lldb（gdb）常用的调试命令？\"><a href=\"#※※※-lldb（gdb）常用的调试命令？\" class=\"headerlink\" title=\"[※※※]lldb（gdb）常用的调试命令？\"></a>[※※※]lldb（gdb）常用的调试命令？</h3>","excerpt":"","more":"<h1 id=\"常见的iOS面试题\"><a href=\"#常见的iOS面试题\" class=\"headerlink\" title=\"常见的iOS面试题\"></a>常见的iOS面试题</h1><p>由于空闲时间比较喜欢在网上看一些大牛的技术blog，今天刚好看到大牛sunnyxx的一个关于他面试别人时提到的一些常见问题（<a href=\"http://blog.sunnyxx.com/2015/07/04/ios-interview/\">原文地址</a>），所以自己也就试着回答了一遍，也算时对自己的一次面试吧，通过自己面试时间也发现了一些自己不足的一面，所以今天记录下来，加深一下印象吧。<br/></p>\n<font color=\"red\"><strong>另外这里有一份 <a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md\">详细答案</a> 分析的很到位</strong></font>\n\n<h3 id=\"※-property中有哪些属性关键字？\"><a href=\"#※-property中有哪些属性关键字？\" class=\"headerlink\" title=\"[※]@property中有哪些属性关键字？\"></a>[※]@property中有哪些属性关键字？</h3><p>在@property 中的关键词个人总结分为三类：RC语意修饰符，线程安全修饰符，读写属性修饰符。</p>\n<h4 id=\"RC语意修饰符\"><a href=\"#RC语意修饰符\" class=\"headerlink\" title=\"RC语意修饰符\"></a>RC语意修饰符</h4><p>这类修饰符主要为了在ARC或者MRC下一个属性的内存管理方法，共如下几种：<br/><br><code>assign</code>： 简单的赋值，不会改变引用计数，共享内存；一般用于基本类型（c/c++：int float等，OC:NSInteger,BOOL等）<br/><br><code>retain</code>： 处理简单赋值外会对赋值对象的引用计数加1操作，用于OC对象；<br/><br><code>copy</code>：处理简单赋值，但是赋值对象引用计数不变，被赋值对象引用计数为1，也就是新生成一个与被赋值对象一样的数据（非绝对 如NSArray对象）<br/><br><code>unsafe_unretained</code>：简单赋值，与assign相似，多用于修饰OC对象，只是表显该对象是不安全的（当赋值对象变为nil的时候会引起crash 野指针问题）<br/><br><code>strong</code>：ARC中简单赋值，与非ARC下的retain相同作用<br/><br><code>weak</code>：ARC中简单赋值，与非ARC下的assign对应，但是又有不同，weak多用于修饰OC对象，且当改对象的引用计数为0的时候，改对象会被修改成nil，而assign则不会，好处时能有效的防止野指针<br/></p>\n<h4 id=\"线程安全修饰符\"><a href=\"#线程安全修饰符\" class=\"headerlink\" title=\"线程安全修饰符\"></a>线程安全修饰符</h4><p>这类修饰符主要是指定属性赋值操作的线程安全性<br/><br><code>atomic</code>：线程安全的，多线程访问情况下只有一个线程能访问他，影响访问速度<br/><br><code>nonatomic</code>：非线程安全的，多线程可同时读写，容易造成混乱，但读写速度快<br/></p>\n<h4 id=\"读写属性修饰符\"><a href=\"#读写属性修饰符\" class=\"headerlink\" title=\"读写属性修饰符\"></a>读写属性修饰符</h4><p>这类修饰符主要控制属性的读写权限<br/><br><code>readonly</code>: 编译器只会对该属性生成get方法<br/><br><code>readwrite</code>: 编译器能生成get/set方法，默认此属性<br/><br>另外get方法可以在修饰符最后指定，比如：<code>@property(getter = isGirl) BOOL girl</code></p>\n<h3 id=\"怎么用-copy-关键字？\"><a href=\"#怎么用-copy-关键字？\" class=\"headerlink\" title=\"[*]怎么用 copy 关键字？\"></a>[*]怎么用 copy 关键字？</h3><ol>\n<li>NSString，NSArray，NSDictionary类型属性常用，因为它们有NSMutableString,NSMutableArray,NSMutableDictionary类型属性，当我们不想外界干扰我们正在操作的这类型属性的时候，我们会把她们设置成copy。</li>\n<li>在使用block的时候我们用copy，在MRC时代，block是创建在栈上的，所以当我们把block进行赋值时不进行copy操作的话，block内的变量会因为栈的pop而造成野指针，从而引起crash。当然在ARC下，block会自动进行copy，但是作为程序员团队协作开发，能明确让别人看到block是经过copy到堆上的对象则更加具有易读性。<h3 id=\"这个写法会出什么问题：-property-copy-NSMutableArray-array\"><a href=\"#这个写法会出什么问题：-property-copy-NSMutableArray-array\" class=\"headerlink\" title=\"[]这个写法会出什么问题： @property (copy) NSMutableArray array;\"></a>[<em>]这个写法会出什么问题： @property (copy) NSMutableArray </em>array;</h3></li>\n<li>把NSMutableArray 属性设置成copy，无论赋值对象是NSArray还是NSMutableArray赋值后array指向的是NSArray对象，但我们往往会因为array的声明NSMutableArray＊ 而把它当成一个可变对象来操作，一旦调用了array的[array removeAtIndex:n],等不属于NSArray的方法后会引起Crash。</li>\n<li>属性修饰符没有加nonatomic，那么array会被编译器默认设置为atomic，atomic表示该属性是原则性操作，每次setter都会加锁来确保它的原子性，这将耗费大量运算。</li>\n</ol>\n<h3 id=\"如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？\"><a href=\"#如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？\" class=\"headerlink\" title=\"[*]如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？\"></a>[*]如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</h3><p>想要自己的类能够使用copy修饰符则必须让自己的类实现NSCopying协议，如果自己的类像NSString那样大小有可变版本和不可变版本，那么就是实现NSCopying协议和NSMutalbeCopying协议。</p>\n<p>具体步骤：</p>\n<ol>\n<li>声明该类遵从NSCopying协议。</li>\n<li><p>在该类中实现下面方法,并且注意对象copy是否需要深拷贝操作。</p>\n<ul>\n<li>(id)copyWithZone:(NSZone *)zone;</li>\n</ul>\n</li>\n</ol>\n<p>至于重写带copy关键字的setter的话一般如下：</p>\n<pre><code>- (void)setCustomClass:(CustomClass *)customClass\n{\n    _customClass = [customClass copy];\n}\n</code></pre><p>但是由于遵循NSCopying协议的类一般都是用作只读属性，所以我们就不去实现setter方法，而是在类initializer的时候对其进行初始化。例如：</p>\n<pre><code>- (instancetype)initWithCustomClass:(CustomClass *)cClass\n{\n    if(self == [super init]){\n        _cClass = [cClass copy];\n    }\n    return self;\n}\n</code></pre><h3 id=\"property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的\"><a href=\"#property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的\" class=\"headerlink\" title=\"[*]@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的?\"></a>[*]@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的?</h3><p><font color=\"red\" size=\"5px\"><strong>此为盗取答案：</strong></font></p>\n<h4 id=\"property-的本质是什么？\"><a href=\"#property-的本质是什么？\" class=\"headerlink\" title=\"@property 的本质是什么？\"></a>@property 的本质是什么？</h4><blockquote>\n<p>@property = (ivar + getter + setter)<br>“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。</p>\n</blockquote>\n<p>“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 Objective-C 2.0 的一部分。 而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。 正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:</p>\n<blockquote>\n<p>编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。 所以你也可以这么说：<br>@property = getter + setter;</p>\n</blockquote>\n<h4 id=\"ivar、getter、setter-是如何生成并添加到这个类中的\"><a href=\"#ivar、getter、setter-是如何生成并添加到这个类中的\" class=\"headerlink\" title=\"ivar、getter、setter 是如何生成并添加到这个类中的?\"></a>ivar、getter、setter 是如何生成并添加到这个类中的?</h4><blockquote>\n<p>“自动合成”( autosynthesis)<br>完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字.</p>\n</blockquote>\n<pre><code>@implementation Person\n@synthesize firstName = _myFirstName;\n@synthesize lastName = _myLastName;\n@end\n</code></pre><blockquote>\n<p>我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西</p>\n<ol>\n<li>OBJC<em>IVAR</em>$类名$属性名称 ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，</li>\n<li>表示该变量距离存放对象的内存区域的起始地址有多远。</li>\n<li>setter 与 getter 方法对应的实现函数</li>\n<li>ivar_list ：成员变量列表</li>\n<li>method_list ：方法列表</li>\n<li>prop_list ：属性列表</li>\n</ol>\n<p>也就是说我们每次在增加一个属性,系统都会在 ivar_list 中添加一个成员变量的描述,在 method_list 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.</p>\n</blockquote>\n<h3 id=\"protocol-和-category-中如何使用-property\"><a href=\"#protocol-和-category-中如何使用-property\" class=\"headerlink\" title=\"[*]@protocol 和 category 中如何使用 @property ?\"></a>[*]@protocol 和 category 中如何使用 @property ?</h3><p><code>@property</code>是封装数据的方式，我们一般不再<code>@protocol</code>和<code>category</code>中使用<code>@property</code>，而是在<code>class_continuation分类</code>中, 查看OC源码我们知道objc_struct结构中，成员变量的偏移量是放到<code>ivar_list</code>中的，是指针加偏移量来进行寻址操作的,OC把实例变量当作一种存储偏移量所用的“特殊变量”，并交由“类对象”来管理，偏移量会在运行时进行查找，如果类的定义变了，那么存储的偏移量也就变了，这样的话，无论何时访问实例变量，总能使用正确的偏移量，也就是说这些偏移量是是在编译时期生成的，所以不能在运行时期向类内加入实例变量。这和方法列表<code>method_list</code>不同的是，方法列表中结构中存的不是偏移量，而是方法指针的指针，也就是说每个方法我们可以修改其实现为任意实现地址。<br/><br>虽然我们不能通过在<code>@protocol</code>和<code>category</code>中添加实例变量，但是我们可以通过<code>@property</code>+<code>@dynamic</code>+<code>关联</code>来达到新增实例相同的结果。</p>\n<blockquote>\n<p>参考资料：<a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html\">https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html</a></p>\n</blockquote>\n<ol>\n<li>在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性</li>\n<li><p>category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给<br>category 增加属性的实现,需要借助于运行时的两个函数：</p>\n<p> objc_setAssociatedObject<br> objc_getAssociatedObject</p>\n</li>\n</ol>\n<p>Runtime给我们提供了这两个方法来达到这个目的，这些关联是通过一个<code>AssociationsManager</code>实例维护一个哈西列表<code>AssociationsHashMap</code>实现的。</p>\n<h3 id=\"※-weak属性需要在dealloc中置nil么？\"><a href=\"#※-weak属性需要在dealloc中置nil么？\" class=\"headerlink\" title=\"[※]weak属性需要在dealloc中置nil么？\"></a>[※]weak属性需要在dealloc中置nil么？</h3><p>不需要，因为被weak修饰符修饰的属性当其引用计数为0的时候，自动引用计数器会自动把属性设置为nil</p>\n<h3 id=\"※※-synthesize和-dynamic分别有什么作用？\"><a href=\"#※※-synthesize和-dynamic分别有什么作用？\" class=\"headerlink\" title=\"[※※]@synthesize和@dynamic分别有什么作用？\"></a>[※※]@synthesize和@dynamic分别有什么作用？</h3><p><code>@synthesize</code>: 该修饰符告诉编译器在编译期自动为该属性生成getter/setter方法，并可指明该属性对应的成员变量。<br><code>@dynamic</code>: 告诉编译器，不自动生成getter/setter方法，避免编译期间产生警告,然后由自己实现存取方法或存取方法在运行时动态创建绑定：主要使用在CoreData的实现NSManagedObject子类时使用，由Core Data框架在程序运行的时动态生成子类属性</p>\n<h3 id=\"※※※-ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？\"><a href=\"#※※※-ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？\" class=\"headerlink\" title=\"[※※※]ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？\"></a>[※※※]ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</h3><p>内存管理默认<code>strong</code>,  原子性默认<code>atomic</code>,读写性默认<code>readwrite</code>;</p>\n<h3 id=\"※※※-用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？\"><a href=\"#※※※-用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？\" class=\"headerlink\" title=\"[※※※]用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？\"></a>[※※※]用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</h3><p>对源头是NSMutableString的字符串，strong仅仅是指针引用，增加了引用计数器，这样源头改变的时候，用这种strong方式声明的变量（无论被赋值的变量是可变的还是不可变的），它也会跟着改变;而copy声明的变量，它不会跟着源头改变，它实际上是深拷贝的“备份”。<br/><br>对源头是NSString的字符串，无论是strong声明的变量还是copy声明的变量，当第二次源头的字符串重新指向其它的地方的时候，它还是指向原来的最初的那个位置（因为常量字符串分配在一个常量内存区），也就是说其实二者都是指针引用，也就是浅拷贝。<br/></p>\n<p>而对于NSMutableArray和NSMutableDictionary情况是和NSMutableString是一样的，strong情况下是传引用，并且引用计数加1，copy情况下是产生一个深拷贝“备份”，并且这个备份变成了一个不可变的NSArray或NSDictionary<br/><br>对于NSArray和NSDictionary在strong情况下传引用，并且引用计数加1，copy情况下是产生一个深拷贝“备份”，并且这个备份变成了一个不可变的NSArray或NSDictionary。<br/></p>\n<p>对于NSString，NSArray，NSDictionary我们经常用copy关键字是因为这些类型的对象不可变，我们只需要使用其一个备份就可以。另外，NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份，所以我们也会用copy修饰符。<br/><br>如果改用strong关键字修饰的话，试图去修改这些不可改变大小的对象而参数数据混乱（更改了一个原不想修改的数据）。</p>\n<h3 id=\"※※※-synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为-foo的实例变量，那么还会自动合成新变量么？\"><a href=\"#※※※-synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为-foo的实例变量，那么还会自动合成新变量么？\" class=\"headerlink\" title=\"[※※※]@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？\"></a>[※※※]@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？</h3><blockquote>\n<p>引用答案的一句话：<code>实例变量 == 成员变量 == ivar</code></p>\n</blockquote>\n<p><code>@synthesize</code> 合成变量的规则是绑定成员属性getter/setter方法到某个成员变量，这个过程叫自动合成，你可以指定成员变量，也可以不指定，如果不指定，则这个成员变量的名字与属性名字相同，在没有<code>@synthesize</code>绑定情况下系统会自动生成一个“<em>属性名”的一个成员变量，并绑定getter/setter方法到“</em>属性名”成员变量。如果已经存在“_属性名”，则编译器不会再自动合成新变量。</p>\n<p>例如.h文件,用<code>@property</code>声明了一个FooClass类型的成员属性 <code>foo</code>：<br/></p>\n<pre><code>class FooLcass : NSObject\n{\n    FooClass* _foo; //实例变量\n}\n\n@property (strong, nonatomic) FooClass* foo; //成员属性\n</code></pre><p>在.m代码如下：</p>\n<pre><code>@synthesize foo = _foo;\n</code></pre><h3 id=\"※※-什么情况下不会autosynthesis（自动合成）\"><a href=\"#※※-什么情况下不会autosynthesis（自动合成）\" class=\"headerlink\" title=\"[※※]什么情况下不会autosynthesis（自动合成）?\"></a>[※※]什么情况下不会autosynthesis（自动合成）?</h3><ol>\n<li>同时重写了 setter 和 getter 时</li>\n<li>重写了只读属性的 getter 时</li>\n<li>使用了 @dynamic 时</li>\n<li>在 @protocol 中定义的所有属性</li>\n<li>在 category 中定义的所有属性</li>\n<li>重载的属性当你在子类中重载了父类中的属性，你必须 使用 @synthesize 来手动合成ivar。</li>\n</ol>\n<h3 id=\"※※※※※-在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？\"><a href=\"#※※※※※-在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？\" class=\"headerlink\" title=\"[※※※※※]在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？\"></a>[※※※※※]在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</h3><ol>\n<li>手动合成ivar（手动管理property，不使用自动合成autosynthesis）</li>\n<li>重载父类的属性 当子类重载了父类的属性石，必须手动指定ivar</li>\n<li>以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字</li>\n</ol>\n<h3 id=\"※※-objc中向一个nil对象发送消息将会发生什么？\"><a href=\"#※※-objc中向一个nil对象发送消息将会发生什么？\" class=\"headerlink\" title=\"[※※]objc中向一个nil对象发送消息将会发生什么？\"></a>[※※]objc中向一个nil对象发送消息将会发生什么？</h3><p>之前理解如果objc是nil，那么向nil对象发生消息将什么也不会发生（对象方法没有正常执行并且也没有引起crash），这些虽然从表象上看是正确的，但是在运行时Runtime中却发生了一系列变化。首先Runtime会动态转化方法调用为消息发送，调用objc_msgSend(receiver,selecter,argv,…),objc_msgSend是不会返回值，他只是起到消息转发的作用，整个过程就是objc_Send根据reciver找到该实例对象的类对象，然后从该类对象的方法列表objc_method_list中找到对应的IMP，然后把参数传给IMP进行方法调用，最后把IMP函数指针指定的方法只需结果返回。由于receiver参数是nil，也就是该类对象的isa指针指向为nil(0)，objc_msgSend也就返回nil(0).</p>\n<p>另外附上objc的一个结构定义</p>\n<pre><code>// runtime.h（类在runtime中的定义）\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n\nstruct objc_class {\n  Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object\n  #if !__OBJC2__\n  Class super_class OBJC2_UNAVAILABLE; // 父类\n  const char *name OBJC2_UNAVAILABLE; // 类名\n  long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0\n  long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识\n  long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小\n  struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表\n  struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表\n  struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。\n  struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表\n  #endif\n  } OBJC2_UNAVAILABLE;\n</code></pre><h3 id=\"※※※-objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？\"><a href=\"#※※※-objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？\" class=\"headerlink\" title=\"[※※※]objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？\"></a>[※※※]objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</h3><p>Runtime运行原理就如上描述一致，消息发生会被转发objc_msgSend((id)obj,@selecter(foo));除此之外对于“边界情况”，如果消息是发给父类的例如：[super foo]那么消息会被转发objc_msgSendSuper((id)obj,@selecter(foo));如果foo消息返回的是结构体，那么消息转换会变成objc_msgSend_stret((id)obj,@selecter(foo));如果foo消息返回的是浮点型数据，那么消息转换成objc_msgSend_fpret((id)obj,@selecter(foo));<br>这些转换都是在动态编译的时候进行转换的。</p>\n<h3 id=\"※※※-什么时候会报unrecognized-selector的异常？\"><a href=\"#※※※-什么时候会报unrecognized-selector的异常？\" class=\"headerlink\" title=\"[※※※]什么时候会报unrecognized selector的异常？\"></a>[※※※]什么时候会报unrecognized selector的异常？</h3><p>“unrecognized selecter”中文翻译就是无法识别的方法，当实例对象或者类对象发送一个该对象objc_method_list/objc_protocol_list没有对应方法的时候，NSObject就是抛出异常。<br/><br>在Runtime抛出异常之间还可做很多事情来处理这种异常，这要依赖于NSObject的消息转发机制。<br/><br>首先在Class中的缓存查找IMP（没缓存则初始化缓存），如果没找到，则向父类的Class查找。如果一直查找到根类仍旧没有实现，则用_objc_msgForward函数指针代替IMP。最后，执行这个IMP。<br/><br>_objc_msgForward是用于消息转发的。这个函数的实现并没有在objc-runtime的开源代码里面，而是在Foundation框架里面实现的。__CFInitialize这个方法会调用objc_setForwardHandler函数来注册一个实现。<br/><br>_objc_msgForward消息转发做了如下几件事：</p>\n<p>征询接受者看其是否能动态添加方法，以处理当前这个“未知的选择子”（这叫动态方法解析）即调用：</p>\n<pre><code>+ (BOOL)resolveInstanceMethod:(SEL)selecter;//实例对象的处理方法\n+ (BOOL)resolveClassMethod:(SEL)selecter;//类对象的处理方法    \n</code></pre><p>该方法的参数就是哪个未知的选择子，我们可以在这里处理哪些没有被objc_msgSend找到的方法。<br/><br>假如在这个阶段还是没有处理这个未知的SEL，那么该SEL会被转发到备用接受者</p>\n<pre><code>- (id)forwardingTargetForSelecter:(SEL)selecter;\n</code></pre><p>这个方法返回指定的能够处理该消息的实例对象或者类对象。<br/><br>如果没有备用接收者，那么就启用完整的转发机制，就是把尚未处理的那条消息的全部信息（选择子，目标，参数）封装成NSInvocation对象，并触发NSinvocation对象，让“消息派发系统”把消息指派给目标对象。即调用:</p>\n<pre><code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;//获取方法签名信息\n- (void)forwardInvocation:(NSInvocation*)invocaton;\n</code></pre><p>消息派发系统依照类的继承关系逐一寻找能够处理该NSInvacation的对象，直到NSObject，如果最后调用了NSObject类方法，那么该方法还会继续调用<code>doesNotRecognizeSelecter:</code>以抛出异常。</p>\n<p>最后陪一个能够理解的图：<br><img src=\"http://7xoo3c.com1.z0.glb.clouddn.com/blogmethod_forwarding.png\" alt=\"消息转发机制流程图\" title=\"消息转发机制流程图\"></p>\n<h3 id=\"※※※※-一个objc对象如何进行内存布局？（考虑有父类的情况）\"><a href=\"#※※※※-一个objc对象如何进行内存布局？（考虑有父类的情况）\" class=\"headerlink\" title=\"[※※※※]一个objc对象如何进行内存布局？（考虑有父类的情况）\"></a>[※※※※]一个objc对象如何进行内存布局？（考虑有父类的情况）</h3><ul>\n<li>一个objc对象的存储空间中保存着该对象的所有实例变量和该对象所有父类的所有实例变量</li>\n<li>每个对象都有一个isa指针，这个指针指向该objc对象的类对象，此类对象在Runtime环境中只有一份儿，并且和其它类对象有着相同的结构，此类对象中存储的是：</li>\n</ul>\n<p>typedef struct objc_class *Class;</p>\n<pre><code>/*\n  这是由编译器为每个类产生的数据结构,这个结构定义了一个类.\n  这个结构是通过编译器在执行时产生,在运行时发送消息时使用.\n  因此,一些成员改变了类型.\n  编译器产生&quot;char* const&quot;类型的字符串指针替代了下面的成员变量&quot;super_class&quot;\n*/\nstruct objc_class {\n  struct objc_class*  class_pointer;    /* 指向元类的指针. */\n  struct objc_class*  super_class;      /* 指向父类的指针. 对于NSObject来说是NULL.*/\n  const char*         name;             /* 类的名称. */\n  long                version;          /* 未知. */\n  unsigned long       info;             /* 比特蒙板.  参考下面类的蒙板定义. */\n  long                instance_size;    /* 类的字节数.包含类的定义和所有父类的定义 */\n#ifdef _WIN64\n  long pad;\n#endif\n  struct objc_ivar_list* ivars;         /* 指向类中定义的实例变量的列表结构. NULL代表没有实例变量.不包括父类的变量. */\n  struct objc_method_list*  methods;    /* 链接类中定义的实例方法. */\n  struct sarray *    dtable;            /* 指向实例方法分配表. */\n  struct objc_class* subclass_list;     /* 父类列表 */\n  struct objc_class* sibling_class;\n  struct objc_protocol_list *protocols; /* 要实现的原型列表 */\n  void* gc_object_type;\n};\n</code></pre><p>该类也有一个isa指针，它指向该类的元类，元类的作用类似于类作用于类对象，保存了该类的类方法信息。</p>\n<p>引用网上常列举的一张图：<br><img src=\"http://7xoo3c.com1.z0.glb.clouddn.com/blogmeta_calss.png\" alt=\"内存布局图\" title=\"类内存布局图\"></p>\n<h3 id=\"※※※※-一个objc对象的isa的指针指向什么？有什么作用？\"><a href=\"#※※※※-一个objc对象的isa的指针指向什么？有什么作用？\" class=\"headerlink\" title=\"[※※※※]一个objc对象的isa的指针指向什么？有什么作用？\"></a>[※※※※]一个objc对象的isa的指针指向什么？有什么作用？</h3><ol>\n<li>实例对象的isa指向该实例的类对象，类对象的isa指向该类的元类，元类的isa指向自己。</li>\n<li>类对象保存着该类的成员列表信息，方法列表信息等。元类保存着该类对象的类方法列表。</li>\n</ol>\n<h3 id=\"※※※※-下面的代码输出什么？\"><a href=\"#※※※※-下面的代码输出什么？\" class=\"headerlink\" title=\"[※※※※]下面的代码输出什么？\"></a>[※※※※]下面的代码输出什么？</h3><pre><code>@implementation Son : Father\n- (id)init\n{\n    self = [super init];\n    if (self) {\n        NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));\n        NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));\n    }\n    return self;\n}\n@end\n</code></pre><p>都输出：Son，答案：<a href=\"http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1)%5Bnil%5D-self-and-super/\">http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1)%5Bnil%5D-self-and-super/</a></p>\n<pre><code>2014-11-05 11:06:18.060 Test[8566:568584] NSStringFromClass([self class]) = Son\n2014-11-05 11:06:18.061 Test[8566:568584] NSStringFromClass([super class]) = Son\n</code></pre><p>解惑：这个题目主要是考察关于objc中对 self 和 super 的理解。</p>\n<p>self 是类的隐藏参数，指向当前调用方法的这个类的实例。而 super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者。上面的例子不管调用[self class]还是[super class]，接受消息的对象都是当前 Son ＊xxx 这个对象。而不同的是，super是告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。</p>\n<p>当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法。</p>\n<p>真的是这样吗？继续看：</p>\n<p>使用clang重写命令:</p>\n<pre><code>$ clang -rewrite-objc test.m\n</code></pre><p>发现上述代码被转化为:</p>\n<pre><code>NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_0, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(&quot;class&quot;))));\n\nNSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_1, NSStringFromClass(((Class (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){ (id)self, (id)class_getSuperclass(objc_getClass(&quot;Son&quot;)) }, sel_registerName(&quot;class&quot;))));\n</code></pre><p>从上面的代码中，我们可以发现在调用<code>[self class]</code>时，会转化成<code>objc_msgSend</code>函数。看下函数定义：</p>\n<pre><code>id objc_msgSend(id self, SEL op, ...)\n</code></pre><p>我们把<code>self</code>做为第一个参数传递进去。</p>\n<p>而在调用<code>[super class]</code>时，会转化成<code>objc_msgSendSuper</code>函数。看下函数定义:</p>\n<pre><code>id objc_msgSendSuper(struct objc_super *super, SEL op, ...)\n</code></pre><p>第一个参数是<code>objc_super</code>这样一个结构体，其定义如下:</p>\n<pre><code>struct objc_super {\n   __unsafe_unretained id receiver;\n   __unsafe_unretained Class super_class;\n};\n</code></pre><p>结构体有两个成员，第一个成员是<code>receiver</code>, 类似于上面的<code>objc_msgSend</code>函数第一个参数<code>self</code>。第二个成员是记录当前类的父类是什么。</p>\n<p>所以，当调用<code>[self class]</code>时，实际先调用的是<code>objc_msgSend</code>函数，第一个参数是<code>Son</code>当前的这个实例，然后在<code>Son</code>这个类里面去找 <code>- (Class)class</code>这个方法，没有，去父类 Father里找，也没有，最后在 NSObject类中发现这个方法。而 <code>- (Class)class</code>的实现就是返回self的类别，故上述输出结果为 Son。</p>\n<p>objc Runtime开源代码对- (Class)class方法的实现:</p>\n<pre><code>- (Class)class {\n    return object_getClass(self);\n}\n</code></pre><p>而当调用<code>[super class]</code>时，会转换成<code>objc_msgSendSuper</code>函数。第一步先构造<code>objc_super</code>结构体，结构体第一个成员就是 self 。第二个成员是 <code>(id)class_getSuperclass(objc_getClass(“Son”))</code>, 实际该函数输出结果为 Father。第二步是去 Father这个类里去找<code>- (Class)class</code>，没有，然后去NSObject类去找，找到了。最后内部是使用<code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>去调用，此时已经和<code>[self class]</code>调用相同了，故上述输出结果仍然返回 <code>Son</code>。</p>\n<blockquote>\n<p>参考：<a href=\"http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1)%5Bnil%5D-self-and-super/\">http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1)%5Bnil%5D-self-and-super/</a></p>\n</blockquote>\n<h3 id=\"runtime-如何实现-weak-属性\"><a href=\"#runtime-如何实现-weak-属性\" class=\"headerlink\" title=\"[*]runtime 如何实现 weak 属性?\"></a>[*]runtime 如何实现 weak 属性?</h3><p><code>weak</code>修饰符是ARC下引入的修饰符，其和<code>assign</code>表示相同，表示<code>nonowning relationship</code>(非拥有关系)，对于被<code>weak</code>修饰的对象，当其所引用的对象的引用计数为0的时候，该对象就为被值为nil。这个过程是依靠Runtime来实现的，当Runtime载入并注册类，会对内存布局，把类中每个被<code>weak</code>修饰的属性加入多一个与该类相关的哈希表结构中，此结构以该对象的地址为key，当该对象的引用计数为0的时候，就会调用dealloc方法，该方法会检索此哈希表，找到所有key为该地址的所有对象，并把它们设值成nil。</p>\n<h3 id=\"※※※※-runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）\"><a href=\"#※※※※-runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）\" class=\"headerlink\" title=\"[※※※※]runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）\"></a>[※※※※]runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</h3><p>我们看一下<code>@selector(methodName:)</code>返回一个<code>SEL</code>类型:</p>\n<pre><code>typedef struct objc_selector *SEL;\n\nstruct objc_selector\n{\n  void *sel_id;\n  const char *sel_types;\n};\n</code></pre><p>上面的结构是在网上搜索到的，但是我在objc/runtime.h中没有找到objc_selector的定义。</p>\n<blockquote>\n<p><a href=\"https://sourceware.org/svn/gcc/tags/stack-last-merge/libobjc/objc/objc.h\">https://sourceware.org/svn/gcc/tags/stack-last-merge/libobjc/objc/objc.h</a></p>\n</blockquote>\n<p>这里指明了objc.h是GCC中的一个文件<code>This file is part of GCC.</code>。</p>\n<p>Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL。所以在Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行。相同的方法只能对应一个SEL。这也就导致Objective-C在处理相同方法名且参数个数相同但类型不同的方法方面的能力很差。如在某个类中定义以下两个方法：</p>\n<pre><code>- (void)setWidth:(int)width;\n\n- (void)setWidth:(double)width;\n</code></pre><p>这样的定义被认为是一种编译错误，所以我们不能像C++, C#那样。而是需要像下面这样来声明：</p>\n<pre><code>-(void)setWidthIntValue:(int)width;\n\n-(void)setWidthDoubleValue:(double)width;\n</code></pre><p>当然，不同的类可以拥有相同的selector，这个没有问题。不同类的实例对象执行相同的selector时，会在各自的方法列表中去根据selector去寻找自己对应的IMP。<br/></p>\n<p>工程中的所有的SEL组成一个Set集合，Set的特点就是唯一，因此SEL是唯一的。因此，如果我们想到这个方法集合中查找某个方法时，只需要去找到这个方法对应的SEL就行了，SEL实际上就是根据方法名hash化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，可以说速度上无语伦比！！但是，有一个问题，就是数量增多会增大hash冲突而导致的性能下降（或是没有冲突，因为也可能用的是perfect hash）。但是不管使用什么样的方法加速，如果能够将总量减少（多个方法可能对应同一个SEL），那将是最犀利的方法。那么，我们就不难理解，为什么SEL仅仅是函数名了。</p>\n<p>本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。这个查找过程我们将在下面讨论。</p>\n<p>我们可以在运行时添加新的selector，也可以在运行时获取已存在的selector，我们可以通过下面三种方法来获取SEL:</p>\n<ol>\n<li>sel_registerName函数</li>\n<li>Objective-C编译器提供的@selector()</li>\n<li>NSSelectorFromString()方法</li>\n</ol>\n<p>IMP实际上是一个函数指针，指向方法实现的首地址。其定义如下：</p>\n<pre><code>id (*IMP)(id, SEL, ...)\n</code></pre><p>介绍完SEL和IMP，我们就可以来讲讲Method了。Method用于表示类定义中的方法，则定义如下：</p>\n<pre><code>typedef struct objc_method *Method;\n\n\n\nstruct objc_method {\n\n    SEL method_name                 OBJC2_UNAVAILABLE;  // 方法名\n\n    char *method_types                  OBJC2_UNAVAILABLE;\n\n    IMP method_imp                      OBJC2_UNAVAILABLE;  // 方法实现\n\n}  \n</code></pre><p>我们可以看到该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。</p>\n<p>对于每一个实例对象它会有一个isa指针，该指针指向该实例对象的类对象，它是一个objc_class的结构体，该结构题中的objc_method_list内包含了该对象的所有实例方法，对于类方法，每个类对象中又有一个isa指针指向该类对象的元类，元类objc_class结构的objc_method_list结构中存储着该类的所有类方法。Runtime通过查找这两个类来获取方法的IMP。</p>\n<blockquote>\n<p>参考：<a href=\"http://southpeak.github.io/blog/2014/11/03/objective-c-runtime-yun-xing-shi-zhi-san-:fang-fa-yu-xiao-xi-zhuan-fa/\">http://southpeak.github.io/blog/2014/11/03/objective-c-runtime-yun-xing-shi-zhi-san-:fang-fa-yu-xiao-xi-zhuan-fa/</a></p>\n</blockquote>\n<h3 id=\"※※※※-使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？\"><a href=\"#※※※※-使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？\" class=\"headerlink\" title=\"[※※※※]使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？\"></a>[※※※※]使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</h3><p>不需要（ARC下和MRC），<code>overfllow</code>的一句话<code>Associated objects are released after the dealloc method of the original object has finished.</code>。通过源码我们可以得知关联对象是通过一个单例类<code>AssociationsManager</code>实例维护一个哈希列表<code>AssociationsHashMap</code>实现的。而map的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。</p>\n<p>而在对象的销毁逻辑里面，当对象的引用计数为0的时候，Runloop在清理对象的时候会调用对象的<code>dealloc</code>,该方法会调用<code>object_dispose</code>方法来清理对象，在<code>object_dispose</code>步会对关联对象进行清理。源代码见<code>objc-runtime-new.mm</code>:</p>\n<pre><code>void *objc_destructInstance(id obj) \n{\n    if (obj) {\n        Class isa_gen = _object_getClass(obj);\n        class_t *isa = newcls(isa_gen);\n\n        // Read all of the flags at once for performance.\n        bool cxx = hasCxxStructors(isa);\n        bool assoc = !UseGC &amp;&amp; _class_instancesHaveAssociatedObjects(isa_gen);\n\n        // This order is important.\n        if (cxx) object_cxxDestruct(obj);\n        if (assoc) _object_remove_assocations(obj);\n\n        if (!UseGC) objc_clear_deallocating(obj);\n    }\n\n    return obj;\n}\n</code></pre><p>Runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作。</p>\n<h3 id=\"※※※※※-objc中的类方法和实例方法有什么本质区别和联系？\"><a href=\"#※※※※※-objc中的类方法和实例方法有什么本质区别和联系？\" class=\"headerlink\" title=\"[※※※※※]objc中的类方法和实例方法有什么本质区别和联系？\"></a>[※※※※※]objc中的类方法和实例方法有什么本质区别和联系？</h3><h3 id=\"※※※※※-objc-msgForward函数是做什么的，直接调用它将会发生什么？\"><a href=\"#※※※※※-objc-msgForward函数是做什么的，直接调用它将会发生什么？\" class=\"headerlink\" title=\"[※※※※※]_objc_msgForward函数是做什么的，直接调用它将会发生什么？\"></a>[※※※※※]_objc_msgForward函数是做什么的，直接调用它将会发生什么？</h3><h3 id=\"※※※※※-runtime如何实现weak变量的自动置nil？\"><a href=\"#※※※※※-runtime如何实现weak变量的自动置nil？\" class=\"headerlink\" title=\"[※※※※※]runtime如何实现weak变量的自动置nil？\"></a>[※※※※※]runtime如何实现weak变量的自动置nil？</h3><h3 id=\"※※※※※-能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\"><a href=\"#※※※※※-能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\" class=\"headerlink\" title=\"[※※※※※]能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\"></a>[※※※※※]能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h3><p>不能向遍以后得到的类中增加实例变量，但是能够向运行时创建的类中添加实例变量。</p>\n<pre><code>class_addIvar\n</code></pre><blockquote>\n<p>This function may only be called after objc_allocateClassPair and before objc_registerClassPair.<br>Adding an instance variable to an existing class is not supported.</p>\n<p>Objective-C不支持往已存在的类中添加实例变量，因此不管是系统库提供的提供的类，还是我们自定义的类，都无法动态添加成员变量。但如果我们通过运行时来创建一个类的话，又应该如何给它添加成员变量呢？这时我们就可以使用class_addIvar函数了。不过需要注意的是，这个方法只能在objc_allocateClassPair函数与objc_registerClassPair之间调用。另外，这个类也不能是元类。成员变量的按字节最小对齐量是1&lt;&lt;alignment。这取决于ivar的类型和机器的架构。如果变量的类型是指针类型，则传递log2(sizeof(pointer_type))。</p>\n<p>文／西木（简书作者）<br>原文链接：<a href=\"http://www.jianshu.com/p/6b905584f536\">http://www.jianshu.com/p/6b905584f536</a></p>\n</blockquote>\n<h3 id=\"※※※-runloop和线程有什么关系？\"><a href=\"#※※※-runloop和线程有什么关系？\" class=\"headerlink\" title=\"[※※※]runloop和线程有什么关系？\"></a>[※※※]runloop和线程有什么关系？</h3><h3 id=\"※※※-runloop的mode作用是什么？\"><a href=\"#※※※-runloop的mode作用是什么？\" class=\"headerlink\" title=\"[※※※]runloop的mode作用是什么？\"></a>[※※※]runloop的mode作用是什么？</h3><h3 id=\"※※※※-以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？\"><a href=\"#※※※※-以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？\" class=\"headerlink\" title=\"[※※※※]以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？\"></a>[※※※※]以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</h3><h3 id=\"※※※※※-猜想runloop内部是如何实现的？\"><a href=\"#※※※※※-猜想runloop内部是如何实现的？\" class=\"headerlink\" title=\"[※※※※※]猜想runloop内部是如何实现的？\"></a>[※※※※※]猜想runloop内部是如何实现的？</h3><h3 id=\"※-objc使用什么机制管理对象内存？\"><a href=\"#※-objc使用什么机制管理对象内存？\" class=\"headerlink\" title=\"[※]objc使用什么机制管理对象内存？\"></a>[※]objc使用什么机制管理对象内存？</h3><h3 id=\"※※※※-ARC通过什么方式帮助开发者管理内存？\"><a href=\"#※※※※-ARC通过什么方式帮助开发者管理内存？\" class=\"headerlink\" title=\"[※※※※]ARC通过什么方式帮助开发者管理内存？\"></a>[※※※※]ARC通过什么方式帮助开发者管理内存？</h3><h3 id=\"※※※※-不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）\"><a href=\"#※※※※-不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）\" class=\"headerlink\" title=\"[※※※※]不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）\"></a>[※※※※]不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</h3><h3 id=\"※※※※-BAD-ACCESS在什么情况下出现？\"><a href=\"#※※※※-BAD-ACCESS在什么情况下出现？\" class=\"headerlink\" title=\"[※※※※]BAD_ACCESS在什么情况下出现？\"></a>[※※※※]BAD_ACCESS在什么情况下出现？</h3><h3 id=\"※※※※※-苹果是如何实现autoreleasepool的？\"><a href=\"#※※※※※-苹果是如何实现autoreleasepool的？\" class=\"headerlink\" title=\"[※※※※※]苹果是如何实现autoreleasepool的？\"></a>[※※※※※]苹果是如何实现autoreleasepool的？</h3><h3 id=\"※※-使用block时什么情况会发生引用循环，如何解决？\"><a href=\"#※※-使用block时什么情况会发生引用循环，如何解决？\" class=\"headerlink\" title=\"[※※]使用block时什么情况会发生引用循环，如何解决？\"></a>[※※]使用block时什么情况会发生引用循环，如何解决？</h3><h3 id=\"※※-在block内如何修改block外部变量？\"><a href=\"#※※-在block内如何修改block外部变量？\" class=\"headerlink\" title=\"[※※]在block内如何修改block外部变量？\"></a>[※※]在block内如何修改block外部变量？</h3><h3 id=\"※※※-使用系统的某些block-api（如UIView的block版本写动画时），是否也考虑引用循环问题？\"><a href=\"#※※※-使用系统的某些block-api（如UIView的block版本写动画时），是否也考虑引用循环问题？\" class=\"headerlink\" title=\"[※※※]使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？\"></a>[※※※]使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</h3><h3 id=\"※※-GCD的队列（dispatch-queue-t）分哪两种类型？\"><a href=\"#※※-GCD的队列（dispatch-queue-t）分哪两种类型？\" class=\"headerlink\" title=\"[※※]GCD的队列（dispatch_queue_t）分哪两种类型？\"></a>[※※]GCD的队列（dispatch_queue_t）分哪两种类型？</h3><h3 id=\"※※※※-如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\"><a href=\"#※※※※-如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\" class=\"headerlink\" title=\"[※※※※]如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\"></a>[※※※※]如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</h3><h3 id=\"※※※※-dispatch-barrier-async的作用是什么？\"><a href=\"#※※※※-dispatch-barrier-async的作用是什么？\" class=\"headerlink\" title=\"[※※※※]dispatch_barrier_async的作用是什么？\"></a>[※※※※]dispatch_barrier_async的作用是什么？</h3><h3 id=\"※※※※※-苹果为什么要废弃dispatch-get-current-queue？\"><a href=\"#※※※※※-苹果为什么要废弃dispatch-get-current-queue？\" class=\"headerlink\" title=\"[※※※※※]苹果为什么要废弃dispatch_get_current_queue？\"></a>[※※※※※]苹果为什么要废弃dispatch_get_current_queue？</h3><h3 id=\"※※※※※-以下代码运行结果如何？\"><a href=\"#※※※※※-以下代码运行结果如何？\" class=\"headerlink\" title=\"[※※※※※]以下代码运行结果如何？\"></a>[※※※※※]以下代码运行结果如何？</h3><pre><code>- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    NSLog(@&quot;1&quot;);\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@&quot;2&quot;);\n    });\n    NSLog(@&quot;3&quot;);\n}\n</code></pre><h3 id=\"※※-addObserver-forKeyPath-options-context-各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？\"><a href=\"#※※-addObserver-forKeyPath-options-context-各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？\" class=\"headerlink\" title=\"[※※]addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？\"></a>[※※]addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</h3><h3 id=\"※※※-如何手动触发一个value的KVO\"><a href=\"#※※※-如何手动触发一个value的KVO\" class=\"headerlink\" title=\"[※※※]如何手动触发一个value的KVO?\"></a>[※※※]如何手动触发一个value的KVO?</h3><h3 id=\"※※※-若一个类有实例变量NSString-foo，调用setValue-forKey-时，可以以foo还是-foo作为key？\"><a href=\"#※※※-若一个类有实例变量NSString-foo，调用setValue-forKey-时，可以以foo还是-foo作为key？\" class=\"headerlink\" title=\"[※※※]若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？\"></a>[※※※]若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？</h3><h3 id=\"※※※※-KVC的keyPath中的集合运算符如何使用？\"><a href=\"#※※※※-KVC的keyPath中的集合运算符如何使用？\" class=\"headerlink\" title=\"[※※※※]KVC的keyPath中的集合运算符如何使用？\"></a>[※※※※]KVC的keyPath中的集合运算符如何使用？</h3><h3 id=\"※※※※-KVC和KVO的keyPath一定是属性么？\"><a href=\"#※※※※-KVC和KVO的keyPath一定是属性么？\" class=\"headerlink\" title=\"[※※※※]KVC和KVO的keyPath一定是属性么？\"></a>[※※※※]KVC和KVO的keyPath一定是属性么？</h3><h3 id=\"※※※※※-如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？\"><a href=\"#※※※※※-如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？\" class=\"headerlink\" title=\"[※※※※※]如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？\"></a>[※※※※※]如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</h3><h3 id=\"※※※※※-apple用什么方式实现对一个对象的KVO？\"><a href=\"#※※※※※-apple用什么方式实现对一个对象的KVO？\" class=\"headerlink\" title=\"[※※※※※]apple用什么方式实现对一个对象的KVO？\"></a>[※※※※※]apple用什么方式实现对一个对象的KVO？</h3><h3 id=\"※※-IBOutlet连出来的视图属性为什么可以被设置成weak\"><a href=\"#※※-IBOutlet连出来的视图属性为什么可以被设置成weak\" class=\"headerlink\" title=\"[※※]IBOutlet连出来的视图属性为什么可以被设置成weak?\"></a>[※※]IBOutlet连出来的视图属性为什么可以被设置成weak?</h3><h3 id=\"※※※※※-IB中User-Defined-Runtime-Attributes如何使用？\"><a href=\"#※※※※※-IB中User-Defined-Runtime-Attributes如何使用？\" class=\"headerlink\" title=\"[※※※※※]IB中User Defined Runtime Attributes如何使用？\"></a>[※※※※※]IB中User Defined Runtime Attributes如何使用？</h3><h3 id=\"※※※-如何调试BAD-ACCESS错误\"><a href=\"#※※※-如何调试BAD-ACCESS错误\" class=\"headerlink\" title=\"[※※※]如何调试BAD_ACCESS错误?\"></a>[※※※]如何调试BAD_ACCESS错误?</h3><h3 id=\"※※※-lldb（gdb）常用的调试命令？\"><a href=\"#※※※-lldb（gdb）常用的调试命令？\" class=\"headerlink\" title=\"[※※※]lldb（gdb）常用的调试命令？\"></a>[※※※]lldb（gdb）常用的调试命令？</h3>"},{"title":"Objective-C底层数据结构","date":"2016-06-27T05:46:34.000Z","_content":"\n# [转]Objective-C底层数据结构\n\n<br/>\n<br/>\n> 原文地址：http://iostour.diandian.com/post/2013-01-16/40047469315\n\n<br/>\n<br/>\n<br/>\n## 类的数据结构\n\n### Class(指针)\n\n\ttypedef struct objc_class *Class;\n\t       \n\t/*\n\t  这是由编译器为每个类产生的数据结构,这个结构定义了一个类.\n\t  这个结构是通过编译器在执行时产生,在运行时发送消息时使用.\n\t  因此,一些成员改变了类型.\n\t  编译器产生\"char* const\"类型的字符串指针替代了下面的成员变量\"super_class\"\n\t*/\n\tstruct objc_class {\n\t  struct objc_class*  class_pointer;    /* 指向元类的指针. */\n\t  struct objc_class*  super_class;      /* 指向父类的指针. 对于NSObject来说是NULL.*/\n\t  const char*         name;             /* 类的名称. */\n\t  long                version;          /* 未知. */\n\t  unsigned long       info;             /* 比特蒙板.  参考下面类的蒙板定义. */\n\t  long                instance_size;    /* 类的字节数.包含类的定义和所有父类的定义 */\n\t#ifdef _WIN64\n\t  long pad;\n\t#endif\n\t  struct objc_ivar_list* ivars;         /* 指向类中定义的实例变量的列表结构. NULL代表没有实例变量.不包括父类的变量. */\n\t  struct objc_method_list*  methods;    /* 链接类中定义的实例方法. */\n\t  struct sarray *    dtable;            /* 指向实例方法分配表. */\n\t  struct objc_class* subclass_list;     /* 父类列表 */\n\t  struct objc_class* sibling_class;\n\t  struct objc_protocol_list *protocols; /* 要实现的原型列表 */\n\t  void* gc_object_type;\n\t};\n\t\n### Method(指针)\n\n\ttypedef struct objc_method *Method;\n\t       \n\t/* 编译器依据类中定义的方法为该类产生一个或更多这种这种结构.\n\t    一个类的实现可以分散在一个文件中不同部分,同时类别可以分散在不同的模块中.为了处理这个问题,使用一个单独的方法链表 */\n\tstruct objc_method\n\t{\n\t  SEL         method_name;  /* 这个变量就是方法的名称.编译器使用在这里使用一个`char*`,当一个方法被注册,名称在运行时被使用真正的SEL替代  */\n\t  const char* method_types; /* 描述方法的参数列表. 在运行时注册选择器时使用.那时候方法名就会包含方法的参数列表.*/\n\t  IMP         method_imp;   /* 方法执行时候的地址. */\n\t};\n\n### Ivar(指针)\n\n\ttypedef struct objc_ivar *Ivar;\n\t       \n\t/* 编译器依据类中定义的实例变量为该类产生一个或更多这种这种结构  */\n\tstruct objc_ivar\n\t{\n\t  const char* ivar_name;  /* 类中定义的变量名. */\n\t  const char* ivar_type;  /* 描述变量的类型.调试时非常有用. */\n\t  int        ivar_offset; /* 实例结构的基地址偏移字节 */\n\t};\n\n### Category(指针)\n\n\ttypedef struct objc_category *Category;\n\t       \n\t/* 编译器为每个类别产生一个这样的结构.一个类可以具有多个类别同时既包括实例方法,也可以包括类方法*/\n\tstruct objc_category\n\t{\n\t  const char*   category_name;                /* 类别名.定义在类别后面的括号内*/\n\t  const char*   class_name;                   /* 类名 */\n\t  struct objc_method_list  *instance_methods; /* 链接类中定义的实例方法. NULL表示没有实例方法. */\n\t  struct objc_method_list *class_methods;     /* 链接类中定义的类方法. NULL表示没有类方法. */\n\t  struct objc_protocol_list *protocols;       /* 遵循的协议表  */\n\t};\n\n### objc_property_t\n\n\ttypedef struct objc_property *objc_property_t;\n\n### IMP\n\n\tid (*IMP)(id, SEL, ...)\n\n### SEL\n\n\ttypedef struct objc_selector *SEL;\n\t       \n\tstruct objc_selector\n\t{\n\t  void *sel_id;\n\t  const char *sel_types;\n\t};\n\n### objc_method_list\n\n\tstruct objc_method_list\n\t{\n\t  struct objc_method_list*  method_next; /* 这个变量用来链接另一个单独的方法链表 */\n\t  int            method_count;            /* 结构中定义的方法数量 */\n\t  struct objc_method method_list[1];      /* 可变长度的结构 */\n\t};\n\n### objc_cache\n\n\tstruct objc_cache\n\t{\n\t    unsigned int mask;\n\t    unsigned int occupied;\n\t    Method buckets[1];\n\t};\n\n### objc_protocol_list\n\n\tstruct objc_protocol_list\n\t{\n\t  struct objc_protocol_list *next;\n\t  size_t count;\n\t  struct objc_protocol *list[1];\n\t};\n\n## 实例的数据结构\n\n### id\n\n\ttypedef struct objc_object *id;\n\n### objc_object\n\n\tstruct objc_object\n\t{\n\t  /* 类的指针是对象相关的类.如果是一个类对象, 这个指针指向元类.\n\t  Class isa;\n\t};\n\n### objc_super\n\n\tstruct objc_super\n\t{\n\t  id    self;        /* 消息的接受者  */\n\t  Class super_class; /* 接受者的父类  */\n\t};\n\n\n> 原文地址：http://iostour.diandian.com/post/2013-01-16/40047469315\n","source":"_posts/oc-struct.md","raw":"---\ntitle: Objective-C底层数据结构\ndate: 2016-06-27 13:46:34\ntags: [Objective-C]\ncategories: Objective-C语言\n\n---\n\n# [转]Objective-C底层数据结构\n\n<br/>\n<br/>\n> 原文地址：http://iostour.diandian.com/post/2013-01-16/40047469315\n\n<br/>\n<br/>\n<br/>\n## 类的数据结构\n\n### Class(指针)\n\n\ttypedef struct objc_class *Class;\n\t       \n\t/*\n\t  这是由编译器为每个类产生的数据结构,这个结构定义了一个类.\n\t  这个结构是通过编译器在执行时产生,在运行时发送消息时使用.\n\t  因此,一些成员改变了类型.\n\t  编译器产生\"char* const\"类型的字符串指针替代了下面的成员变量\"super_class\"\n\t*/\n\tstruct objc_class {\n\t  struct objc_class*  class_pointer;    /* 指向元类的指针. */\n\t  struct objc_class*  super_class;      /* 指向父类的指针. 对于NSObject来说是NULL.*/\n\t  const char*         name;             /* 类的名称. */\n\t  long                version;          /* 未知. */\n\t  unsigned long       info;             /* 比特蒙板.  参考下面类的蒙板定义. */\n\t  long                instance_size;    /* 类的字节数.包含类的定义和所有父类的定义 */\n\t#ifdef _WIN64\n\t  long pad;\n\t#endif\n\t  struct objc_ivar_list* ivars;         /* 指向类中定义的实例变量的列表结构. NULL代表没有实例变量.不包括父类的变量. */\n\t  struct objc_method_list*  methods;    /* 链接类中定义的实例方法. */\n\t  struct sarray *    dtable;            /* 指向实例方法分配表. */\n\t  struct objc_class* subclass_list;     /* 父类列表 */\n\t  struct objc_class* sibling_class;\n\t  struct objc_protocol_list *protocols; /* 要实现的原型列表 */\n\t  void* gc_object_type;\n\t};\n\t\n### Method(指针)\n\n\ttypedef struct objc_method *Method;\n\t       \n\t/* 编译器依据类中定义的方法为该类产生一个或更多这种这种结构.\n\t    一个类的实现可以分散在一个文件中不同部分,同时类别可以分散在不同的模块中.为了处理这个问题,使用一个单独的方法链表 */\n\tstruct objc_method\n\t{\n\t  SEL         method_name;  /* 这个变量就是方法的名称.编译器使用在这里使用一个`char*`,当一个方法被注册,名称在运行时被使用真正的SEL替代  */\n\t  const char* method_types; /* 描述方法的参数列表. 在运行时注册选择器时使用.那时候方法名就会包含方法的参数列表.*/\n\t  IMP         method_imp;   /* 方法执行时候的地址. */\n\t};\n\n### Ivar(指针)\n\n\ttypedef struct objc_ivar *Ivar;\n\t       \n\t/* 编译器依据类中定义的实例变量为该类产生一个或更多这种这种结构  */\n\tstruct objc_ivar\n\t{\n\t  const char* ivar_name;  /* 类中定义的变量名. */\n\t  const char* ivar_type;  /* 描述变量的类型.调试时非常有用. */\n\t  int        ivar_offset; /* 实例结构的基地址偏移字节 */\n\t};\n\n### Category(指针)\n\n\ttypedef struct objc_category *Category;\n\t       \n\t/* 编译器为每个类别产生一个这样的结构.一个类可以具有多个类别同时既包括实例方法,也可以包括类方法*/\n\tstruct objc_category\n\t{\n\t  const char*   category_name;                /* 类别名.定义在类别后面的括号内*/\n\t  const char*   class_name;                   /* 类名 */\n\t  struct objc_method_list  *instance_methods; /* 链接类中定义的实例方法. NULL表示没有实例方法. */\n\t  struct objc_method_list *class_methods;     /* 链接类中定义的类方法. NULL表示没有类方法. */\n\t  struct objc_protocol_list *protocols;       /* 遵循的协议表  */\n\t};\n\n### objc_property_t\n\n\ttypedef struct objc_property *objc_property_t;\n\n### IMP\n\n\tid (*IMP)(id, SEL, ...)\n\n### SEL\n\n\ttypedef struct objc_selector *SEL;\n\t       \n\tstruct objc_selector\n\t{\n\t  void *sel_id;\n\t  const char *sel_types;\n\t};\n\n### objc_method_list\n\n\tstruct objc_method_list\n\t{\n\t  struct objc_method_list*  method_next; /* 这个变量用来链接另一个单独的方法链表 */\n\t  int            method_count;            /* 结构中定义的方法数量 */\n\t  struct objc_method method_list[1];      /* 可变长度的结构 */\n\t};\n\n### objc_cache\n\n\tstruct objc_cache\n\t{\n\t    unsigned int mask;\n\t    unsigned int occupied;\n\t    Method buckets[1];\n\t};\n\n### objc_protocol_list\n\n\tstruct objc_protocol_list\n\t{\n\t  struct objc_protocol_list *next;\n\t  size_t count;\n\t  struct objc_protocol *list[1];\n\t};\n\n## 实例的数据结构\n\n### id\n\n\ttypedef struct objc_object *id;\n\n### objc_object\n\n\tstruct objc_object\n\t{\n\t  /* 类的指针是对象相关的类.如果是一个类对象, 这个指针指向元类.\n\t  Class isa;\n\t};\n\n### objc_super\n\n\tstruct objc_super\n\t{\n\t  id    self;        /* 消息的接受者  */\n\t  Class super_class; /* 接受者的父类  */\n\t};\n\n\n> 原文地址：http://iostour.diandian.com/post/2013-01-16/40047469315\n","slug":"oc-struct","published":1,"updated":"2016-06-27T06:09:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipzbicgb000isiftjq5ao4f8","content":"<h1 id=\"转-Objective-C底层数据结构\"><a href=\"#转-Objective-C底层数据结构\" class=\"headerlink\" title=\"[转]Objective-C底层数据结构\"></a>[转]Objective-C底层数据结构</h1><p><br><br><br></p>\n<blockquote>\n<p>原文地址：<a href=\"http://iostour.diandian.com/post/2013-01-16/40047469315\" target=\"_blank\" rel=\"external\">http://iostour.diandian.com/post/2013-01-16/40047469315</a></p>\n</blockquote>\n<p><br><br><br><br><br></p>\n<h2 id=\"类的数据结构\"><a href=\"#类的数据结构\" class=\"headerlink\" title=\"类的数据结构\"></a>类的数据结构</h2><h3 id=\"Class-指针\"><a href=\"#Class-指针\" class=\"headerlink\" title=\"Class(指针)\"></a>Class(指针)</h3><pre><code>typedef struct objc_class *Class;\n\n/*\n  这是由编译器为每个类产生的数据结构,这个结构定义了一个类.\n  这个结构是通过编译器在执行时产生,在运行时发送消息时使用.\n  因此,一些成员改变了类型.\n  编译器产生&quot;char* const&quot;类型的字符串指针替代了下面的成员变量&quot;super_class&quot;\n*/\nstruct objc_class {\n  struct objc_class*  class_pointer;    /* 指向元类的指针. */\n  struct objc_class*  super_class;      /* 指向父类的指针. 对于NSObject来说是NULL.*/\n  const char*         name;             /* 类的名称. */\n  long                version;          /* 未知. */\n  unsigned long       info;             /* 比特蒙板.  参考下面类的蒙板定义. */\n  long                instance_size;    /* 类的字节数.包含类的定义和所有父类的定义 */\n#ifdef _WIN64\n  long pad;\n#endif\n  struct objc_ivar_list* ivars;         /* 指向类中定义的实例变量的列表结构. NULL代表没有实例变量.不包括父类的变量. */\n  struct objc_method_list*  methods;    /* 链接类中定义的实例方法. */\n  struct sarray *    dtable;            /* 指向实例方法分配表. */\n  struct objc_class* subclass_list;     /* 父类列表 */\n  struct objc_class* sibling_class;\n  struct objc_protocol_list *protocols; /* 要实现的原型列表 */\n  void* gc_object_type;\n};\n</code></pre><h3 id=\"Method-指针\"><a href=\"#Method-指针\" class=\"headerlink\" title=\"Method(指针)\"></a>Method(指针)</h3><pre><code>typedef struct objc_method *Method;\n\n/* 编译器依据类中定义的方法为该类产生一个或更多这种这种结构.\n    一个类的实现可以分散在一个文件中不同部分,同时类别可以分散在不同的模块中.为了处理这个问题,使用一个单独的方法链表 */\nstruct objc_method\n{\n  SEL         method_name;  /* 这个变量就是方法的名称.编译器使用在这里使用一个`char*`,当一个方法被注册,名称在运行时被使用真正的SEL替代  */\n  const char* method_types; /* 描述方法的参数列表. 在运行时注册选择器时使用.那时候方法名就会包含方法的参数列表.*/\n  IMP         method_imp;   /* 方法执行时候的地址. */\n};\n</code></pre><h3 id=\"Ivar-指针\"><a href=\"#Ivar-指针\" class=\"headerlink\" title=\"Ivar(指针)\"></a>Ivar(指针)</h3><pre><code>typedef struct objc_ivar *Ivar;\n\n/* 编译器依据类中定义的实例变量为该类产生一个或更多这种这种结构  */\nstruct objc_ivar\n{\n  const char* ivar_name;  /* 类中定义的变量名. */\n  const char* ivar_type;  /* 描述变量的类型.调试时非常有用. */\n  int        ivar_offset; /* 实例结构的基地址偏移字节 */\n};\n</code></pre><h3 id=\"Category-指针\"><a href=\"#Category-指针\" class=\"headerlink\" title=\"Category(指针)\"></a>Category(指针)</h3><pre><code>typedef struct objc_category *Category;\n\n/* 编译器为每个类别产生一个这样的结构.一个类可以具有多个类别同时既包括实例方法,也可以包括类方法*/\nstruct objc_category\n{\n  const char*   category_name;                /* 类别名.定义在类别后面的括号内*/\n  const char*   class_name;                   /* 类名 */\n  struct objc_method_list  *instance_methods; /* 链接类中定义的实例方法. NULL表示没有实例方法. */\n  struct objc_method_list *class_methods;     /* 链接类中定义的类方法. NULL表示没有类方法. */\n  struct objc_protocol_list *protocols;       /* 遵循的协议表  */\n};\n</code></pre><h3 id=\"objc-property-t\"><a href=\"#objc-property-t\" class=\"headerlink\" title=\"objc_property_t\"></a>objc_property_t</h3><pre><code>typedef struct objc_property *objc_property_t;\n</code></pre><h3 id=\"IMP\"><a href=\"#IMP\" class=\"headerlink\" title=\"IMP\"></a>IMP</h3><pre><code>id (*IMP)(id, SEL, ...)\n</code></pre><h3 id=\"SEL\"><a href=\"#SEL\" class=\"headerlink\" title=\"SEL\"></a>SEL</h3><pre><code>typedef struct objc_selector *SEL;\n\nstruct objc_selector\n{\n  void *sel_id;\n  const char *sel_types;\n};\n</code></pre><h3 id=\"objc-method-list\"><a href=\"#objc-method-list\" class=\"headerlink\" title=\"objc_method_list\"></a>objc_method_list</h3><pre><code>struct objc_method_list\n{\n  struct objc_method_list*  method_next; /* 这个变量用来链接另一个单独的方法链表 */\n  int            method_count;            /* 结构中定义的方法数量 */\n  struct objc_method method_list[1];      /* 可变长度的结构 */\n};\n</code></pre><h3 id=\"objc-cache\"><a href=\"#objc-cache\" class=\"headerlink\" title=\"objc_cache\"></a>objc_cache</h3><pre><code>struct objc_cache\n{\n    unsigned int mask;\n    unsigned int occupied;\n    Method buckets[1];\n};\n</code></pre><h3 id=\"objc-protocol-list\"><a href=\"#objc-protocol-list\" class=\"headerlink\" title=\"objc_protocol_list\"></a>objc_protocol_list</h3><pre><code>struct objc_protocol_list\n{\n  struct objc_protocol_list *next;\n  size_t count;\n  struct objc_protocol *list[1];\n};\n</code></pre><h2 id=\"实例的数据结构\"><a href=\"#实例的数据结构\" class=\"headerlink\" title=\"实例的数据结构\"></a>实例的数据结构</h2><h3 id=\"id\"><a href=\"#id\" class=\"headerlink\" title=\"id\"></a>id</h3><pre><code>typedef struct objc_object *id;\n</code></pre><h3 id=\"objc-object\"><a href=\"#objc-object\" class=\"headerlink\" title=\"objc_object\"></a>objc_object</h3><pre><code>struct objc_object\n{\n  /* 类的指针是对象相关的类.如果是一个类对象, 这个指针指向元类.\n  Class isa;\n};\n</code></pre><h3 id=\"objc-super\"><a href=\"#objc-super\" class=\"headerlink\" title=\"objc_super\"></a>objc_super</h3><pre><code>struct objc_super\n{\n  id    self;        /* 消息的接受者  */\n  Class super_class; /* 接受者的父类  */\n};\n</code></pre><blockquote>\n<p>原文地址：<a href=\"http://iostour.diandian.com/post/2013-01-16/40047469315\" target=\"_blank\" rel=\"external\">http://iostour.diandian.com/post/2013-01-16/40047469315</a></p>\n</blockquote>\n","excerpt":"","more":"<h1 id=\"转-Objective-C底层数据结构\"><a href=\"#转-Objective-C底层数据结构\" class=\"headerlink\" title=\"[转]Objective-C底层数据结构\"></a>[转]Objective-C底层数据结构</h1><p><br/><br><br/></p>\n<blockquote>\n<p>原文地址：<a href=\"http://iostour.diandian.com/post/2013-01-16/40047469315\">http://iostour.diandian.com/post/2013-01-16/40047469315</a></p>\n</blockquote>\n<p><br/><br><br/><br><br/></p>\n<h2 id=\"类的数据结构\"><a href=\"#类的数据结构\" class=\"headerlink\" title=\"类的数据结构\"></a>类的数据结构</h2><h3 id=\"Class-指针\"><a href=\"#Class-指针\" class=\"headerlink\" title=\"Class(指针)\"></a>Class(指针)</h3><pre><code>typedef struct objc_class *Class;\n\n/*\n  这是由编译器为每个类产生的数据结构,这个结构定义了一个类.\n  这个结构是通过编译器在执行时产生,在运行时发送消息时使用.\n  因此,一些成员改变了类型.\n  编译器产生&quot;char* const&quot;类型的字符串指针替代了下面的成员变量&quot;super_class&quot;\n*/\nstruct objc_class {\n  struct objc_class*  class_pointer;    /* 指向元类的指针. */\n  struct objc_class*  super_class;      /* 指向父类的指针. 对于NSObject来说是NULL.*/\n  const char*         name;             /* 类的名称. */\n  long                version;          /* 未知. */\n  unsigned long       info;             /* 比特蒙板.  参考下面类的蒙板定义. */\n  long                instance_size;    /* 类的字节数.包含类的定义和所有父类的定义 */\n#ifdef _WIN64\n  long pad;\n#endif\n  struct objc_ivar_list* ivars;         /* 指向类中定义的实例变量的列表结构. NULL代表没有实例变量.不包括父类的变量. */\n  struct objc_method_list*  methods;    /* 链接类中定义的实例方法. */\n  struct sarray *    dtable;            /* 指向实例方法分配表. */\n  struct objc_class* subclass_list;     /* 父类列表 */\n  struct objc_class* sibling_class;\n  struct objc_protocol_list *protocols; /* 要实现的原型列表 */\n  void* gc_object_type;\n};\n</code></pre><h3 id=\"Method-指针\"><a href=\"#Method-指针\" class=\"headerlink\" title=\"Method(指针)\"></a>Method(指针)</h3><pre><code>typedef struct objc_method *Method;\n\n/* 编译器依据类中定义的方法为该类产生一个或更多这种这种结构.\n    一个类的实现可以分散在一个文件中不同部分,同时类别可以分散在不同的模块中.为了处理这个问题,使用一个单独的方法链表 */\nstruct objc_method\n{\n  SEL         method_name;  /* 这个变量就是方法的名称.编译器使用在这里使用一个`char*`,当一个方法被注册,名称在运行时被使用真正的SEL替代  */\n  const char* method_types; /* 描述方法的参数列表. 在运行时注册选择器时使用.那时候方法名就会包含方法的参数列表.*/\n  IMP         method_imp;   /* 方法执行时候的地址. */\n};\n</code></pre><h3 id=\"Ivar-指针\"><a href=\"#Ivar-指针\" class=\"headerlink\" title=\"Ivar(指针)\"></a>Ivar(指针)</h3><pre><code>typedef struct objc_ivar *Ivar;\n\n/* 编译器依据类中定义的实例变量为该类产生一个或更多这种这种结构  */\nstruct objc_ivar\n{\n  const char* ivar_name;  /* 类中定义的变量名. */\n  const char* ivar_type;  /* 描述变量的类型.调试时非常有用. */\n  int        ivar_offset; /* 实例结构的基地址偏移字节 */\n};\n</code></pre><h3 id=\"Category-指针\"><a href=\"#Category-指针\" class=\"headerlink\" title=\"Category(指针)\"></a>Category(指针)</h3><pre><code>typedef struct objc_category *Category;\n\n/* 编译器为每个类别产生一个这样的结构.一个类可以具有多个类别同时既包括实例方法,也可以包括类方法*/\nstruct objc_category\n{\n  const char*   category_name;                /* 类别名.定义在类别后面的括号内*/\n  const char*   class_name;                   /* 类名 */\n  struct objc_method_list  *instance_methods; /* 链接类中定义的实例方法. NULL表示没有实例方法. */\n  struct objc_method_list *class_methods;     /* 链接类中定义的类方法. NULL表示没有类方法. */\n  struct objc_protocol_list *protocols;       /* 遵循的协议表  */\n};\n</code></pre><h3 id=\"objc-property-t\"><a href=\"#objc-property-t\" class=\"headerlink\" title=\"objc_property_t\"></a>objc_property_t</h3><pre><code>typedef struct objc_property *objc_property_t;\n</code></pre><h3 id=\"IMP\"><a href=\"#IMP\" class=\"headerlink\" title=\"IMP\"></a>IMP</h3><pre><code>id (*IMP)(id, SEL, ...)\n</code></pre><h3 id=\"SEL\"><a href=\"#SEL\" class=\"headerlink\" title=\"SEL\"></a>SEL</h3><pre><code>typedef struct objc_selector *SEL;\n\nstruct objc_selector\n{\n  void *sel_id;\n  const char *sel_types;\n};\n</code></pre><h3 id=\"objc-method-list\"><a href=\"#objc-method-list\" class=\"headerlink\" title=\"objc_method_list\"></a>objc_method_list</h3><pre><code>struct objc_method_list\n{\n  struct objc_method_list*  method_next; /* 这个变量用来链接另一个单独的方法链表 */\n  int            method_count;            /* 结构中定义的方法数量 */\n  struct objc_method method_list[1];      /* 可变长度的结构 */\n};\n</code></pre><h3 id=\"objc-cache\"><a href=\"#objc-cache\" class=\"headerlink\" title=\"objc_cache\"></a>objc_cache</h3><pre><code>struct objc_cache\n{\n    unsigned int mask;\n    unsigned int occupied;\n    Method buckets[1];\n};\n</code></pre><h3 id=\"objc-protocol-list\"><a href=\"#objc-protocol-list\" class=\"headerlink\" title=\"objc_protocol_list\"></a>objc_protocol_list</h3><pre><code>struct objc_protocol_list\n{\n  struct objc_protocol_list *next;\n  size_t count;\n  struct objc_protocol *list[1];\n};\n</code></pre><h2 id=\"实例的数据结构\"><a href=\"#实例的数据结构\" class=\"headerlink\" title=\"实例的数据结构\"></a>实例的数据结构</h2><h3 id=\"id\"><a href=\"#id\" class=\"headerlink\" title=\"id\"></a>id</h3><pre><code>typedef struct objc_object *id;\n</code></pre><h3 id=\"objc-object\"><a href=\"#objc-object\" class=\"headerlink\" title=\"objc_object\"></a>objc_object</h3><pre><code>struct objc_object\n{\n  /* 类的指针是对象相关的类.如果是一个类对象, 这个指针指向元类.\n  Class isa;\n};\n</code></pre><h3 id=\"objc-super\"><a href=\"#objc-super\" class=\"headerlink\" title=\"objc_super\"></a>objc_super</h3><pre><code>struct objc_super\n{\n  id    self;        /* 消息的接受者  */\n  Class super_class; /* 接受者的父类  */\n};\n</code></pre><blockquote>\n<p>原文地址：<a href=\"http://iostour.diandian.com/post/2013-01-16/40047469315\">http://iostour.diandian.com/post/2013-01-16/40047469315</a></p>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cipzbicet0000siftxzzmagtp","category_id":"cipzbicf90004siftqziesnbk","_id":"cipzbicfp000asift8l7bj1dv"},{"post_id":"cipzbicfh0008sift9ixn1k36","category_id":"cipzbicf90004siftqziesnbk","_id":"cipzbicfy000dsiftcjnlm38b"},{"post_id":"cipzbicfr000bsift194donsm","category_id":"cipzbicg5000fsiftpeqpxal6","_id":"cipzbicgh000osiftsrd15v7f"},{"post_id":"cipzbicg6000gsiftz0wwx8z8","category_id":"cipzbicgg000ksiftbtygv5mq","_id":"cipzbicgk000tsift3c3mtqba"},{"post_id":"cipzbicgb000isiftjq5ao4f8","category_id":"cipzbicgi000qsift4n4i4f4u","_id":"cipzbicgl000wsiftfmtdu28r"}],"PostTag":[{"post_id":"cipzbicet0000siftxzzmagtp","tag_id":"cipzbicf60003siftqfy5mq4d","_id":"cipzbicgf000jsiftlcxpinyk"},{"post_id":"cipzbicet0000siftxzzmagtp","tag_id":"cipzbicfg0007sifth9caxo2h","_id":"cipzbicgg000lsift48oqepek"},{"post_id":"cipzbicet0000siftxzzmagtp","tag_id":"cipzbicfu000csiftsgpiverx","_id":"cipzbicgh000nsift7zkkp1q0"},{"post_id":"cipzbicf10002sift3qvscxpg","tag_id":"cipzbicg9000hsifthj0jxgm1","_id":"cipzbicgi000psiftghzffepi"},{"post_id":"cipzbicfd0006siftbgti8q3a","tag_id":"cipzbicgh000msiftvxczuonm","_id":"cipzbicgk000ssifth43563g5"},{"post_id":"cipzbicfh0008sift9ixn1k36","tag_id":"cipzbicg9000hsifthj0jxgm1","_id":"cipzbicgl000vsiftn79j4j6s"},{"post_id":"cipzbicfr000bsift194donsm","tag_id":"cipzbicgk000usift4kjp6ww7","_id":"cipzbicgl000ysifthmzhqzf6"},{"post_id":"cipzbicfz000esiftc173l0xy","tag_id":"cipzbicgl000xsift465p6o42","_id":"cipzbicgm0010siftb0ookmjf"},{"post_id":"cipzbicg6000gsiftz0wwx8z8","tag_id":"cipzbicgm000zsiftdq6j2uiv","_id":"cipzbicgn0012sifti8ypt4qa"},{"post_id":"cipzbicgb000isiftjq5ao4f8","tag_id":"cipzbicgm0011sift4ziynruc","_id":"cipzbicgn0013sift37vl4kpf"}],"Tag":[{"name":"HybridApp","_id":"cipzbicf60003siftqfy5mq4d"},{"name":"Webview","_id":"cipzbicfg0007sifth9caxo2h"},{"name":"Javascript","_id":"cipzbicfu000csiftsgpiverx"},{"name":"iOS","_id":"cipzbicg9000hsifthj0jxgm1"},{"name":"设计模式","_id":"cipzbicgh000msiftvxczuonm"},{"name":"Xcode","_id":"cipzbicgk000usift4kjp6ww7"},{"name":"Hexo","_id":"cipzbicgl000xsift465p6o42"},{"name":"面试","_id":"cipzbicgm000zsiftdq6j2uiv"},{"name":"Objective-C","_id":"cipzbicgm0011sift4ziynruc"}]}}