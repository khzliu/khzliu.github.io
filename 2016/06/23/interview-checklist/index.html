
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>iOS面试题总结 | khzliu&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="khzliu">
    
    <meta name="description" content="常见的iOS面试题由于空闲时间比较喜欢在网上看一些大牛的技术blog，今天刚好看到大牛sunnyxx的一个关于他面试别人时提到的一些常见问题（原文地址），所以自己也就试着回答了一遍，也算时对自己的一次面试吧，通过自己面试时间也发现了一些自己不足的一面，所以今天记录下来，加深一下印象吧。
另外这里有一">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="khzliu&#39;s blog" title="khzliu&#39;s blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="khzliu&#39;s blog">khzliu&#39;s blog</a></h1>
				<h2 class="blog-motto">喜欢dota2，喜欢科幻片，喜欢美剧!</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/tags">标签</a></li>
					
						<li><a href="/categories">分类</a></li>
					
						<li><a href="/works">作品</a></li>
					
						<li><a href="/about">关于我</a></li>
					
					<li>
					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/06/23/interview-checklist/" title="iOS面试题总结" itemprop="url">iOS面试题总结</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://blog.khzliu.net" title="khzliu">khzliu</a>
    </p>
  <p class="article-time">
    <time datetime="2016-06-23T14:52:03.000Z" itemprop="datePublished">2016-06-23</time>
    Updated:<time datetime="2016-06-27T05:54:42.000Z" itemprop="dateModified">2016-06-27</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#常见的iOS面试题"><span class="toc-number">1.</span> <span class="toc-text">常见的iOS面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#※-property中有哪些属性关键字？"><span class="toc-number">1.0.1.</span> <span class="toc-text">[※]@property中有哪些属性关键字？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RC语意修饰符"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">RC语意修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程安全修饰符"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">线程安全修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读写属性修饰符"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">读写属性修饰符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#怎么用-copy-关键字？"><span class="toc-number">1.0.2.</span> <span class="toc-text">[*]怎么用 copy 关键字？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#这个写法会出什么问题：-property-copy-NSMutableArray-array"><span class="toc-number">1.0.3.</span> <span class="toc-text">[]这个写法会出什么问题： @property (copy) NSMutableArray array;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？"><span class="toc-number">1.0.4.</span> <span class="toc-text">[*]如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的"><span class="toc-number">1.0.5.</span> <span class="toc-text">[*]@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#property-的本质是什么？"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">@property 的本质是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ivar、getter、setter-是如何生成并添加到这个类中的"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">ivar、getter、setter 是如何生成并添加到这个类中的?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#protocol-和-category-中如何使用-property"><span class="toc-number">1.0.6.</span> <span class="toc-text">[*]@protocol 和 category 中如何使用 @property ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※-weak属性需要在dealloc中置nil么？"><span class="toc-number">1.0.7.</span> <span class="toc-text">[※]weak属性需要在dealloc中置nil么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※-synthesize和-dynamic分别有什么作用？"><span class="toc-number">1.0.8.</span> <span class="toc-text">[※※]@synthesize和@dynamic分别有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※-ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"><span class="toc-number">1.0.9.</span> <span class="toc-text">[※※※]ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※-用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？"><span class="toc-number">1.0.10.</span> <span class="toc-text">[※※※]用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※-synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为-foo的实例变量，那么还会自动合成新变量么？"><span class="toc-number">1.0.11.</span> <span class="toc-text">[※※※]@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※-什么情况下不会autosynthesis（自动合成）"><span class="toc-number">1.0.12.</span> <span class="toc-text">[※※]什么情况下不会autosynthesis（自动合成）?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※※-在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？"><span class="toc-number">1.0.13.</span> <span class="toc-text">[※※※※※]在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※-objc中向一个nil对象发送消息将会发生什么？"><span class="toc-number">1.0.14.</span> <span class="toc-text">[※※]objc中向一个nil对象发送消息将会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※-objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？"><span class="toc-number">1.0.15.</span> <span class="toc-text">[※※※]objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※-什么时候会报unrecognized-selector的异常？"><span class="toc-number">1.0.16.</span> <span class="toc-text">[※※※]什么时候会报unrecognized selector的异常？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-一个objc对象如何进行内存布局？（考虑有父类的情况）"><span class="toc-number">1.0.17.</span> <span class="toc-text">[※※※※]一个objc对象如何进行内存布局？（考虑有父类的情况）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-一个objc对象的isa的指针指向什么？有什么作用？"><span class="toc-number">1.0.18.</span> <span class="toc-text">[※※※※]一个objc对象的isa的指针指向什么？有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-下面的代码输出什么？"><span class="toc-number">1.0.19.</span> <span class="toc-text">[※※※※]下面的代码输出什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runtime-如何实现-weak-属性"><span class="toc-number">1.0.20.</span> <span class="toc-text">[*]runtime 如何实现 weak 属性?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）"><span class="toc-number">1.0.21.</span> <span class="toc-text">[※※※※]runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？"><span class="toc-number">1.0.22.</span> <span class="toc-text">[※※※※]使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※※-objc中的类方法和实例方法有什么本质区别和联系？"><span class="toc-number">1.0.23.</span> <span class="toc-text">[※※※※※]objc中的类方法和实例方法有什么本质区别和联系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※※-objc-msgForward函数是做什么的，直接调用它将会发生什么？"><span class="toc-number">1.0.24.</span> <span class="toc-text">[※※※※※]_objc_msgForward函数是做什么的，直接调用它将会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※※-runtime如何实现weak变量的自动置nil？"><span class="toc-number">1.0.25.</span> <span class="toc-text">[※※※※※]runtime如何实现weak变量的自动置nil？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※※-能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？"><span class="toc-number">1.0.26.</span> <span class="toc-text">[※※※※※]能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※-runloop和线程有什么关系？"><span class="toc-number">1.0.27.</span> <span class="toc-text">[※※※]runloop和线程有什么关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※-runloop的mode作用是什么？"><span class="toc-number">1.0.28.</span> <span class="toc-text">[※※※]runloop的mode作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？"><span class="toc-number">1.0.29.</span> <span class="toc-text">[※※※※]以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※※-猜想runloop内部是如何实现的？"><span class="toc-number">1.0.30.</span> <span class="toc-text">[※※※※※]猜想runloop内部是如何实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※-objc使用什么机制管理对象内存？"><span class="toc-number">1.0.31.</span> <span class="toc-text">[※]objc使用什么机制管理对象内存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-ARC通过什么方式帮助开发者管理内存？"><span class="toc-number">1.0.32.</span> <span class="toc-text">[※※※※]ARC通过什么方式帮助开发者管理内存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）"><span class="toc-number">1.0.33.</span> <span class="toc-text">[※※※※]不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-BAD-ACCESS在什么情况下出现？"><span class="toc-number">1.0.34.</span> <span class="toc-text">[※※※※]BAD_ACCESS在什么情况下出现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※※-苹果是如何实现autoreleasepool的？"><span class="toc-number">1.0.35.</span> <span class="toc-text">[※※※※※]苹果是如何实现autoreleasepool的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※-使用block时什么情况会发生引用循环，如何解决？"><span class="toc-number">1.0.36.</span> <span class="toc-text">[※※]使用block时什么情况会发生引用循环，如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※-在block内如何修改block外部变量？"><span class="toc-number">1.0.37.</span> <span class="toc-text">[※※]在block内如何修改block外部变量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※-使用系统的某些block-api（如UIView的block版本写动画时），是否也考虑引用循环问题？"><span class="toc-number">1.0.38.</span> <span class="toc-text">[※※※]使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※-GCD的队列（dispatch-queue-t）分哪两种类型？"><span class="toc-number">1.0.39.</span> <span class="toc-text">[※※]GCD的队列（dispatch_queue_t）分哪两种类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）"><span class="toc-number">1.0.40.</span> <span class="toc-text">[※※※※]如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-dispatch-barrier-async的作用是什么？"><span class="toc-number">1.0.41.</span> <span class="toc-text">[※※※※]dispatch_barrier_async的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※※-苹果为什么要废弃dispatch-get-current-queue？"><span class="toc-number">1.0.42.</span> <span class="toc-text">[※※※※※]苹果为什么要废弃dispatch_get_current_queue？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※※-以下代码运行结果如何？"><span class="toc-number">1.0.43.</span> <span class="toc-text">[※※※※※]以下代码运行结果如何？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※-addObserver-forKeyPath-options-context-各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？"><span class="toc-number">1.0.44.</span> <span class="toc-text">[※※]addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※-如何手动触发一个value的KVO"><span class="toc-number">1.0.45.</span> <span class="toc-text">[※※※]如何手动触发一个value的KVO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※-若一个类有实例变量NSString-foo，调用setValue-forKey-时，可以以foo还是-foo作为key？"><span class="toc-number">1.0.46.</span> <span class="toc-text">[※※※]若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-KVC的keyPath中的集合运算符如何使用？"><span class="toc-number">1.0.47.</span> <span class="toc-text">[※※※※]KVC的keyPath中的集合运算符如何使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-KVC和KVO的keyPath一定是属性么？"><span class="toc-number">1.0.48.</span> <span class="toc-text">[※※※※]KVC和KVO的keyPath一定是属性么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※※-如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？"><span class="toc-number">1.0.49.</span> <span class="toc-text">[※※※※※]如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※※-apple用什么方式实现对一个对象的KVO？"><span class="toc-number">1.0.50.</span> <span class="toc-text">[※※※※※]apple用什么方式实现对一个对象的KVO？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※-IBOutlet连出来的视图属性为什么可以被设置成weak"><span class="toc-number">1.0.51.</span> <span class="toc-text">[※※]IBOutlet连出来的视图属性为什么可以被设置成weak?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※※-IB中User-Defined-Runtime-Attributes如何使用？"><span class="toc-number">1.0.52.</span> <span class="toc-text">[※※※※※]IB中User Defined Runtime Attributes如何使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※-如何调试BAD-ACCESS错误"><span class="toc-number">1.0.53.</span> <span class="toc-text">[※※※]如何调试BAD_ACCESS错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※-lldb（gdb）常用的调试命令？"><span class="toc-number">1.0.54.</span> <span class="toc-text">[※※※]lldb（gdb）常用的调试命令？</span></a></li></ol></li></ol></li></ol>
		</div>
		
		<h1 id="常见的iOS面试题"><a href="#常见的iOS面试题" class="headerlink" title="常见的iOS面试题"></a>常见的iOS面试题</h1><p>由于空闲时间比较喜欢在网上看一些大牛的技术blog，今天刚好看到大牛sunnyxx的一个关于他面试别人时提到的一些常见问题（<a href="http://blog.sunnyxx.com/2015/07/04/ios-interview/" target="_blank" rel="external">原文地址</a>），所以自己也就试着回答了一遍，也算时对自己的一次面试吧，通过自己面试时间也发现了一些自己不足的一面，所以今天记录下来，加深一下印象吧。<br></p>
<font color="red"><strong>另外这里有一份 <a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md" target="_blank" rel="external">详细答案</a> 分析的很到位</strong></font>

<h3 id="※-property中有哪些属性关键字？"><a href="#※-property中有哪些属性关键字？" class="headerlink" title="[※]@property中有哪些属性关键字？"></a>[※]@property中有哪些属性关键字？</h3><p>在@property 中的关键词个人总结分为三类：RC语意修饰符，线程安全修饰符，读写属性修饰符。</p>
<h4 id="RC语意修饰符"><a href="#RC语意修饰符" class="headerlink" title="RC语意修饰符"></a>RC语意修饰符</h4><p>这类修饰符主要为了在ARC或者MRC下一个属性的内存管理方法，共如下几种：<br><br><code>assign</code>： 简单的赋值，不会改变引用计数，共享内存；一般用于基本类型（c/c++：int float等，OC:NSInteger,BOOL等）<br><br><code>retain</code>： 处理简单赋值外会对赋值对象的引用计数加1操作，用于OC对象；<br><br><code>copy</code>：处理简单赋值，但是赋值对象引用计数不变，被赋值对象引用计数为1，也就是新生成一个与被赋值对象一样的数据（非绝对 如NSArray对象）<br><br><code>unsafe_unretained</code>：简单赋值，与assign相似，多用于修饰OC对象，只是表显该对象是不安全的（当赋值对象变为nil的时候会引起crash 野指针问题）<br><br><code>strong</code>：ARC中简单赋值，与非ARC下的retain相同作用<br><br><code>weak</code>：ARC中简单赋值，与非ARC下的assign对应，但是又有不同，weak多用于修饰OC对象，且当改对象的引用计数为0的时候，改对象会被修改成nil，而assign则不会，好处时能有效的防止野指针<br></p>
<h4 id="线程安全修饰符"><a href="#线程安全修饰符" class="headerlink" title="线程安全修饰符"></a>线程安全修饰符</h4><p>这类修饰符主要是指定属性赋值操作的线程安全性<br><br><code>atomic</code>：线程安全的，多线程访问情况下只有一个线程能访问他，影响访问速度<br><br><code>nonatomic</code>：非线程安全的，多线程可同时读写，容易造成混乱，但读写速度快<br></p>
<h4 id="读写属性修饰符"><a href="#读写属性修饰符" class="headerlink" title="读写属性修饰符"></a>读写属性修饰符</h4><p>这类修饰符主要控制属性的读写权限<br><br><code>readonly</code>: 编译器只会对该属性生成get方法<br><br><code>readwrite</code>: 编译器能生成get/set方法，默认此属性<br><br>另外get方法可以在修饰符最后指定，比如：<code>@property(getter = isGirl) BOOL girl</code></p>
<h3 id="怎么用-copy-关键字？"><a href="#怎么用-copy-关键字？" class="headerlink" title="[*]怎么用 copy 关键字？"></a>[*]怎么用 copy 关键字？</h3><ol>
<li>NSString，NSArray，NSDictionary类型属性常用，因为它们有NSMutableString,NSMutableArray,NSMutableDictionary类型属性，当我们不想外界干扰我们正在操作的这类型属性的时候，我们会把她们设置成copy。</li>
<li>在使用block的时候我们用copy，在MRC时代，block是创建在栈上的，所以当我们把block进行赋值时不进行copy操作的话，block内的变量会因为栈的pop而造成野指针，从而引起crash。当然在ARC下，block会自动进行copy，但是作为程序员团队协作开发，能明确让别人看到block是经过copy到堆上的对象则更加具有易读性。<h3 id="这个写法会出什么问题：-property-copy-NSMutableArray-array"><a href="#这个写法会出什么问题：-property-copy-NSMutableArray-array" class="headerlink" title="[]这个写法会出什么问题： @property (copy) NSMutableArray array;"></a>[<em>]这个写法会出什么问题： @property (copy) NSMutableArray </em>array;</h3></li>
<li>把NSMutableArray 属性设置成copy，无论赋值对象是NSArray还是NSMutableArray赋值后array指向的是NSArray对象，但我们往往会因为array的声明NSMutableArray＊ 而把它当成一个可变对象来操作，一旦调用了array的[array removeAtIndex:n],等不属于NSArray的方法后会引起Crash。</li>
<li>属性修饰符没有加nonatomic，那么array会被编译器默认设置为atomic，atomic表示该属性是原则性操作，每次setter都会加锁来确保它的原子性，这将耗费大量运算。</li>
</ol>
<h3 id="如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？"><a href="#如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？" class="headerlink" title="[*]如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？"></a>[*]如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</h3><p>想要自己的类能够使用copy修饰符则必须让自己的类实现NSCopying协议，如果自己的类像NSString那样大小有可变版本和不可变版本，那么就是实现NSCopying协议和NSMutalbeCopying协议。</p>
<p>具体步骤：</p>
<ol>
<li>声明该类遵从NSCopying协议。</li>
<li><p>在该类中实现下面方法,并且注意对象copy是否需要深拷贝操作。</p>
<ul>
<li>(id)copyWithZone:(NSZone *)zone;</li>
</ul>
</li>
</ol>
<p>至于重写带copy关键字的setter的话一般如下：</p>
<pre><code>- (void)setCustomClass:(CustomClass *)customClass
{
    _customClass = [customClass copy];
}
</code></pre><p>但是由于遵循NSCopying协议的类一般都是用作只读属性，所以我们就不去实现setter方法，而是在类initializer的时候对其进行初始化。例如：</p>
<pre><code>- (instancetype)initWithCustomClass:(CustomClass *)cClass
{
    if(self == [super init]){
        _cClass = [cClass copy];
    }
    return self;
}
</code></pre><h3 id="property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的"><a href="#property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的" class="headerlink" title="[*]@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的?"></a>[*]@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的?</h3><p><font color="red" size="5px"><strong>此为盗取答案：</strong></font></p>
<h4 id="property-的本质是什么？"><a href="#property-的本质是什么？" class="headerlink" title="@property 的本质是什么？"></a>@property 的本质是什么？</h4><blockquote>
<p>@property = (ivar + getter + setter)<br>“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。</p>
</blockquote>
<p>“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 Objective-C 2.0 的一部分。 而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。 正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:</p>
<blockquote>
<p>编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。 所以你也可以这么说：<br>@property = getter + setter;</p>
</blockquote>
<h4 id="ivar、getter、setter-是如何生成并添加到这个类中的"><a href="#ivar、getter、setter-是如何生成并添加到这个类中的" class="headerlink" title="ivar、getter、setter 是如何生成并添加到这个类中的?"></a>ivar、getter、setter 是如何生成并添加到这个类中的?</h4><blockquote>
<p>“自动合成”( autosynthesis)<br>完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字.</p>
</blockquote>
<pre><code>@implementation Person
@synthesize firstName = _myFirstName;
@synthesize lastName = _myLastName;
@end
</code></pre><blockquote>
<p>我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西</p>
<ol>
<li>OBJC<em>IVAR</em>$类名$属性名称 ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，</li>
<li>表示该变量距离存放对象的内存区域的起始地址有多远。</li>
<li>setter 与 getter 方法对应的实现函数</li>
<li>ivar_list ：成员变量列表</li>
<li>method_list ：方法列表</li>
<li>prop_list ：属性列表</li>
</ol>
<p>也就是说我们每次在增加一个属性,系统都会在 ivar_list 中添加一个成员变量的描述,在 method_list 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.</p>
</blockquote>
<h3 id="protocol-和-category-中如何使用-property"><a href="#protocol-和-category-中如何使用-property" class="headerlink" title="[*]@protocol 和 category 中如何使用 @property ?"></a>[*]@protocol 和 category 中如何使用 @property ?</h3><p><code>@property</code>是封装数据的方式，我们一般不再<code>@protocol</code>和<code>category</code>中使用<code>@property</code>，而是在<code>class_continuation分类</code>中, 查看OC源码我们知道objc_struct结构中，成员变量的偏移量是放到<code>ivar_list</code>中的，是指针加偏移量来进行寻址操作的,OC把实例变量当作一种存储偏移量所用的“特殊变量”，并交由“类对象”来管理，偏移量会在运行时进行查找，如果类的定义变了，那么存储的偏移量也就变了，这样的话，无论何时访问实例变量，总能使用正确的偏移量。</p>
<h3 id="※-weak属性需要在dealloc中置nil么？"><a href="#※-weak属性需要在dealloc中置nil么？" class="headerlink" title="[※]weak属性需要在dealloc中置nil么？"></a>[※]weak属性需要在dealloc中置nil么？</h3><p>不需要，因为被weak修饰符修饰的属性当其引用计数为0的时候，自动引用计数器会自动把属性设置为nil</p>
<h3 id="※※-synthesize和-dynamic分别有什么作用？"><a href="#※※-synthesize和-dynamic分别有什么作用？" class="headerlink" title="[※※]@synthesize和@dynamic分别有什么作用？"></a>[※※]@synthesize和@dynamic分别有什么作用？</h3><p><code>@synthesize</code>: 该修饰符告诉编译器在编译期自动为该属性生成getter/setter方法，并可指明该属性对应的成员变量。<br><code>@dynamic</code>: 告诉编译器，不自动生成getter/setter方法，避免编译期间产生警告,然后由自己实现存取方法或存取方法在运行时动态创建绑定：主要使用在CoreData的实现NSManagedObject子类时使用，由Core Data框架在程序运行的时动态生成子类属性</p>
<h3 id="※※※-ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"><a href="#※※※-ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？" class="headerlink" title="[※※※]ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"></a>[※※※]ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</h3><p>内存管理默认<code>strong</code>,  原子性默认<code>atomic</code>,读写性默认<code>readwrite</code>;</p>
<h3 id="※※※-用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？"><a href="#※※※-用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？" class="headerlink" title="[※※※]用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？"></a>[※※※]用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</h3><p>对源头是NSMutableString的字符串，strong仅仅是指针引用，增加了引用计数器，这样源头改变的时候，用这种strong方式声明的变量（无论被赋值的变量是可变的还是不可变的），它也会跟着改变;而copy声明的变量，它不会跟着源头改变，它实际上是深拷贝的“备份”。<br><br>对源头是NSString的字符串，无论是strong声明的变量还是copy声明的变量，当第二次源头的字符串重新指向其它的地方的时候，它还是指向原来的最初的那个位置（因为常量字符串分配在一个常量内存区），也就是说其实二者都是指针引用，也就是浅拷贝。<br></p>
<p>而对于NSMutableArray和NSMutableDictionary情况是和NSMutableString是一样的，strong情况下是传引用，并且引用计数加1，copy情况下是产生一个深拷贝“备份”，并且这个备份变成了一个不可变的NSArray或NSDictionary<br><br>对于NSArray和NSDictionary在strong情况下传引用，并且引用计数加1，copy情况下是产生一个深拷贝“备份”，并且这个备份变成了一个不可变的NSArray或NSDictionary。<br></p>
<p>对于NSString，NSArray，NSDictionary我们经常用copy关键字是因为这些类型的对象不可变，我们只需要使用其一个备份就可以。另外，NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份，所以我们也会用copy修饰符。<br><br>如果改用strong关键字修饰的话，试图去修改这些不可改变大小的对象而参数数据混乱（更改了一个原不想修改的数据）。</p>
<h3 id="※※※-synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为-foo的实例变量，那么还会自动合成新变量么？"><a href="#※※※-synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为-foo的实例变量，那么还会自动合成新变量么？" class="headerlink" title="[※※※]@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？"></a>[※※※]@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？</h3><blockquote>
<p>引用答案的一句话：<code>实例变量 == 成员变量 == ivar</code></p>
</blockquote>
<p><code>@synthesize</code> 合成变量的规则是绑定成员属性getter/setter方法到某个成员变量，这个过程叫自动合成，你可以指定成员变量，也可以不指定，如果不指定，则这个成员变量的名字与属性名字相同，在没有<code>@synthesize</code>绑定情况下系统会自动生成一个“<em>属性名”的一个成员变量，并绑定getter/setter方法到“</em>属性名”成员变量。如果已经存在“_属性名”，则编译器不会再自动合成新变量。</p>
<p>例如.h文件,用<code>@property</code>声明了一个FooClass类型的成员属性 <code>foo</code>：<br></p>
<pre><code>class FooLcass : NSObject
{
    FooClass* _foo; //实例变量
}

@property (strong, nonatomic) FooClass* foo; //成员属性
</code></pre><p>在.m代码如下：</p>
<pre><code>@synthesize foo = _foo;
</code></pre><h3 id="※※-什么情况下不会autosynthesis（自动合成）"><a href="#※※-什么情况下不会autosynthesis（自动合成）" class="headerlink" title="[※※]什么情况下不会autosynthesis（自动合成）?"></a>[※※]什么情况下不会autosynthesis（自动合成）?</h3><ol>
<li>同时重写了 setter 和 getter 时</li>
<li>重写了只读属性的 getter 时</li>
<li>使用了 @dynamic 时</li>
<li>在 @protocol 中定义的所有属性</li>
<li>在 category 中定义的所有属性</li>
<li>重载的属性当你在子类中重载了父类中的属性，你必须 使用 @synthesize 来手动合成ivar。</li>
</ol>
<h3 id="※※※※※-在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？"><a href="#※※※※※-在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？" class="headerlink" title="[※※※※※]在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？"></a>[※※※※※]在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</h3><ol>
<li>手动合成ivar（手动管理property，不使用自动合成autosynthesis）</li>
<li>重载父类的属性 当子类重载了父类的属性石，必须手动指定ivar</li>
<li>以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字</li>
</ol>
<h3 id="※※-objc中向一个nil对象发送消息将会发生什么？"><a href="#※※-objc中向一个nil对象发送消息将会发生什么？" class="headerlink" title="[※※]objc中向一个nil对象发送消息将会发生什么？"></a>[※※]objc中向一个nil对象发送消息将会发生什么？</h3><p>之前理解如果objc是nil，那么向nil对象发生消息将什么也不会发生（对象方法没有正常执行并且也没有引起crash），这些虽然从表象上看是正确的，但是在运行时Runtime中却发生了一系列变化。首先Runtime会动态转化方法调用为消息发送，调用objc_msgSend(receiver,selecter,argv,…),objc_msgSend是不会返回值，他只是起到消息转发的作用，整个过程就是objc_Send根据reciver找到该实例对象的类对象，然后从该类对象的方法列表objc_method_list中找到对应的IMP，然后把参数传给IMP进行方法调用，最后把IMP函数指针指定的方法只需结果返回。由于receiver参数是nil，也就是该类对象的isa指针指向为nil(0)，objc_msgSend也就返回nil(0).</p>
<p>另外附上objc的一个结构定义</p>
<pre><code>// runtime.h（类在runtime中的定义）
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong

struct objc_class {
  Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object
  #if !__OBJC2__
  Class super_class OBJC2_UNAVAILABLE; // 父类
  const char *name OBJC2_UNAVAILABLE; // 类名
  long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0
  long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识
  long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小
  struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表
  struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表
  struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。
  struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表
  #endif
  } OBJC2_UNAVAILABLE;
</code></pre><h3 id="※※※-objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？"><a href="#※※※-objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？" class="headerlink" title="[※※※]objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？"></a>[※※※]objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</h3><p>Runtime运行原理就如上描述一致，消息发生会被转发objc_msgSend((id)obj,@selecter(foo));除此之外对于“边界情况”，如果消息是发给父类的例如：[super foo]那么消息会被转发objc_msgSendSuper((id)obj,@selecter(foo));如果foo消息返回的是结构体，那么消息转换会变成objc_msgSend_stret((id)obj,@selecter(foo));如果foo消息返回的是浮点型数据，那么消息转换成objc_msgSend_fpret((id)obj,@selecter(foo));<br>这些转换都是在动态编译的时候进行转换的。</p>
<h3 id="※※※-什么时候会报unrecognized-selector的异常？"><a href="#※※※-什么时候会报unrecognized-selector的异常？" class="headerlink" title="[※※※]什么时候会报unrecognized selector的异常？"></a>[※※※]什么时候会报unrecognized selector的异常？</h3><p>“unrecognized selecter”中文翻译就是无法识别的方法，当实例对象或者类对象发送一个该对象objc_method_list/objc_protocol_list没有对应方法的时候，NSObject就是抛出异常。<br><br>在Runtime抛出异常之间还可做很多事情来处理这种异常，这要依赖于NSObject的消息转发机制。<br><br>首先在Class中的缓存查找IMP（没缓存则初始化缓存），如果没找到，则向父类的Class查找。如果一直查找到根类仍旧没有实现，则用_objc_msgForward函数指针代替IMP。最后，执行这个IMP。<br><br>_objc_msgForward是用于消息转发的。这个函数的实现并没有在objc-runtime的开源代码里面，而是在Foundation框架里面实现的。__CFInitialize这个方法会调用objc_setForwardHandler函数来注册一个实现。<br><br>_objc_msgForward消息转发做了如下几件事：</p>
<p>征询接受者看其是否能动态添加方法，以处理当前这个“未知的选择子”（这叫动态方法解析）即调用：</p>
<pre><code>+ (BOOL)resolveInstanceMethod:(SEL)selecter;//实例对象的处理方法
+ (BOOL)resolveClassMethod:(SEL)selecter;//类对象的处理方法    
</code></pre><p>该方法的参数就是哪个未知的选择子，我们可以在这里处理哪些没有被objc_msgSend找到的方法。<br><br>假如在这个阶段还是没有处理这个未知的SEL，那么该SEL会被转发到备用接受者</p>
<pre><code>- (id)forwardingTargetForSelecter:(SEL)selecter;
</code></pre><p>这个方法返回指定的能够处理该消息的实例对象或者类对象。<br><br>如果没有备用接收者，那么就启用完整的转发机制，就是把尚未处理的那条消息的全部信息（选择子，目标，参数）封装成NSInvocation对象，并触发NSinvocation对象，让“消息派发系统”把消息指派给目标对象。即调用:</p>
<pre><code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;//获取方法签名信息
- (void)forwardInvocation:(NSInvocation*)invocaton;
</code></pre><p>消息派发系统依照类的继承关系逐一寻找能够处理该NSInvacation的对象，直到NSObject，如果最后调用了NSObject类方法，那么该方法还会继续调用<code>doesNotRecognizeSelecter:</code>以抛出异常。</p>
<p>最后陪一个能够理解的图：<br><img src="http://7xoo3c.com1.z0.glb.clouddn.com/blogmethod_forwarding.png" alt="消息转发机制流程图" title="消息转发机制流程图"></p>
<h3 id="※※※※-一个objc对象如何进行内存布局？（考虑有父类的情况）"><a href="#※※※※-一个objc对象如何进行内存布局？（考虑有父类的情况）" class="headerlink" title="[※※※※]一个objc对象如何进行内存布局？（考虑有父类的情况）"></a>[※※※※]一个objc对象如何进行内存布局？（考虑有父类的情况）</h3><h3 id="※※※※-一个objc对象的isa的指针指向什么？有什么作用？"><a href="#※※※※-一个objc对象的isa的指针指向什么？有什么作用？" class="headerlink" title="[※※※※]一个objc对象的isa的指针指向什么？有什么作用？"></a>[※※※※]一个objc对象的isa的指针指向什么？有什么作用？</h3><h3 id="※※※※-下面的代码输出什么？"><a href="#※※※※-下面的代码输出什么？" class="headerlink" title="[※※※※]下面的代码输出什么？"></a>[※※※※]下面的代码输出什么？</h3><pre><code>@implementation Son : Father
- (id)init
{
    self = [super init];
    if (self) {
        NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));
        NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));
    }
    return self;
}
@end
</code></pre><h3 id="runtime-如何实现-weak-属性"><a href="#runtime-如何实现-weak-属性" class="headerlink" title="[*]runtime 如何实现 weak 属性?"></a>[*]runtime 如何实现 weak 属性?</h3><h3 id="※※※※-runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）"><a href="#※※※※-runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）" class="headerlink" title="[※※※※]runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）"></a>[※※※※]runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</h3><h3 id="※※※※-使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？"><a href="#※※※※-使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？" class="headerlink" title="[※※※※]使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？"></a>[※※※※]使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</h3><h3 id="※※※※※-objc中的类方法和实例方法有什么本质区别和联系？"><a href="#※※※※※-objc中的类方法和实例方法有什么本质区别和联系？" class="headerlink" title="[※※※※※]objc中的类方法和实例方法有什么本质区别和联系？"></a>[※※※※※]objc中的类方法和实例方法有什么本质区别和联系？</h3><h3 id="※※※※※-objc-msgForward函数是做什么的，直接调用它将会发生什么？"><a href="#※※※※※-objc-msgForward函数是做什么的，直接调用它将会发生什么？" class="headerlink" title="[※※※※※]_objc_msgForward函数是做什么的，直接调用它将会发生什么？"></a>[※※※※※]_objc_msgForward函数是做什么的，直接调用它将会发生什么？</h3><h3 id="※※※※※-runtime如何实现weak变量的自动置nil？"><a href="#※※※※※-runtime如何实现weak变量的自动置nil？" class="headerlink" title="[※※※※※]runtime如何实现weak变量的自动置nil？"></a>[※※※※※]runtime如何实现weak变量的自动置nil？</h3><h3 id="※※※※※-能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？"><a href="#※※※※※-能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？" class="headerlink" title="[※※※※※]能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？"></a>[※※※※※]能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h3><h3 id="※※※-runloop和线程有什么关系？"><a href="#※※※-runloop和线程有什么关系？" class="headerlink" title="[※※※]runloop和线程有什么关系？"></a>[※※※]runloop和线程有什么关系？</h3><h3 id="※※※-runloop的mode作用是什么？"><a href="#※※※-runloop的mode作用是什么？" class="headerlink" title="[※※※]runloop的mode作用是什么？"></a>[※※※]runloop的mode作用是什么？</h3><h3 id="※※※※-以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？"><a href="#※※※※-以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？" class="headerlink" title="[※※※※]以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？"></a>[※※※※]以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</h3><h3 id="※※※※※-猜想runloop内部是如何实现的？"><a href="#※※※※※-猜想runloop内部是如何实现的？" class="headerlink" title="[※※※※※]猜想runloop内部是如何实现的？"></a>[※※※※※]猜想runloop内部是如何实现的？</h3><h3 id="※-objc使用什么机制管理对象内存？"><a href="#※-objc使用什么机制管理对象内存？" class="headerlink" title="[※]objc使用什么机制管理对象内存？"></a>[※]objc使用什么机制管理对象内存？</h3><h3 id="※※※※-ARC通过什么方式帮助开发者管理内存？"><a href="#※※※※-ARC通过什么方式帮助开发者管理内存？" class="headerlink" title="[※※※※]ARC通过什么方式帮助开发者管理内存？"></a>[※※※※]ARC通过什么方式帮助开发者管理内存？</h3><h3 id="※※※※-不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）"><a href="#※※※※-不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）" class="headerlink" title="[※※※※]不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）"></a>[※※※※]不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</h3><h3 id="※※※※-BAD-ACCESS在什么情况下出现？"><a href="#※※※※-BAD-ACCESS在什么情况下出现？" class="headerlink" title="[※※※※]BAD_ACCESS在什么情况下出现？"></a>[※※※※]BAD_ACCESS在什么情况下出现？</h3><h3 id="※※※※※-苹果是如何实现autoreleasepool的？"><a href="#※※※※※-苹果是如何实现autoreleasepool的？" class="headerlink" title="[※※※※※]苹果是如何实现autoreleasepool的？"></a>[※※※※※]苹果是如何实现autoreleasepool的？</h3><h3 id="※※-使用block时什么情况会发生引用循环，如何解决？"><a href="#※※-使用block时什么情况会发生引用循环，如何解决？" class="headerlink" title="[※※]使用block时什么情况会发生引用循环，如何解决？"></a>[※※]使用block时什么情况会发生引用循环，如何解决？</h3><h3 id="※※-在block内如何修改block外部变量？"><a href="#※※-在block内如何修改block外部变量？" class="headerlink" title="[※※]在block内如何修改block外部变量？"></a>[※※]在block内如何修改block外部变量？</h3><h3 id="※※※-使用系统的某些block-api（如UIView的block版本写动画时），是否也考虑引用循环问题？"><a href="#※※※-使用系统的某些block-api（如UIView的block版本写动画时），是否也考虑引用循环问题？" class="headerlink" title="[※※※]使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？"></a>[※※※]使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</h3><h3 id="※※-GCD的队列（dispatch-queue-t）分哪两种类型？"><a href="#※※-GCD的队列（dispatch-queue-t）分哪两种类型？" class="headerlink" title="[※※]GCD的队列（dispatch_queue_t）分哪两种类型？"></a>[※※]GCD的队列（dispatch_queue_t）分哪两种类型？</h3><h3 id="※※※※-如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）"><a href="#※※※※-如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）" class="headerlink" title="[※※※※]如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）"></a>[※※※※]如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</h3><h3 id="※※※※-dispatch-barrier-async的作用是什么？"><a href="#※※※※-dispatch-barrier-async的作用是什么？" class="headerlink" title="[※※※※]dispatch_barrier_async的作用是什么？"></a>[※※※※]dispatch_barrier_async的作用是什么？</h3><h3 id="※※※※※-苹果为什么要废弃dispatch-get-current-queue？"><a href="#※※※※※-苹果为什么要废弃dispatch-get-current-queue？" class="headerlink" title="[※※※※※]苹果为什么要废弃dispatch_get_current_queue？"></a>[※※※※※]苹果为什么要废弃dispatch_get_current_queue？</h3><h3 id="※※※※※-以下代码运行结果如何？"><a href="#※※※※※-以下代码运行结果如何？" class="headerlink" title="[※※※※※]以下代码运行结果如何？"></a>[※※※※※]以下代码运行结果如何？</h3><pre><code>- (void)viewDidLoad
{
    [super viewDidLoad];
    NSLog(@&quot;1&quot;);
    dispatch_sync(dispatch_get_main_queue(), ^{
        NSLog(@&quot;2&quot;);
    });
    NSLog(@&quot;3&quot;);
}
</code></pre><h3 id="※※-addObserver-forKeyPath-options-context-各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？"><a href="#※※-addObserver-forKeyPath-options-context-各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？" class="headerlink" title="[※※]addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？"></a>[※※]addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</h3><h3 id="※※※-如何手动触发一个value的KVO"><a href="#※※※-如何手动触发一个value的KVO" class="headerlink" title="[※※※]如何手动触发一个value的KVO"></a>[※※※]如何手动触发一个value的KVO</h3><h3 id="※※※-若一个类有实例变量NSString-foo，调用setValue-forKey-时，可以以foo还是-foo作为key？"><a href="#※※※-若一个类有实例变量NSString-foo，调用setValue-forKey-时，可以以foo还是-foo作为key？" class="headerlink" title="[※※※]若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？"></a>[※※※]若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？</h3><h3 id="※※※※-KVC的keyPath中的集合运算符如何使用？"><a href="#※※※※-KVC的keyPath中的集合运算符如何使用？" class="headerlink" title="[※※※※]KVC的keyPath中的集合运算符如何使用？"></a>[※※※※]KVC的keyPath中的集合运算符如何使用？</h3><h3 id="※※※※-KVC和KVO的keyPath一定是属性么？"><a href="#※※※※-KVC和KVO的keyPath一定是属性么？" class="headerlink" title="[※※※※]KVC和KVO的keyPath一定是属性么？"></a>[※※※※]KVC和KVO的keyPath一定是属性么？</h3><h3 id="※※※※※-如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？"><a href="#※※※※※-如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？" class="headerlink" title="[※※※※※]如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？"></a>[※※※※※]如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</h3><h3 id="※※※※※-apple用什么方式实现对一个对象的KVO？"><a href="#※※※※※-apple用什么方式实现对一个对象的KVO？" class="headerlink" title="[※※※※※]apple用什么方式实现对一个对象的KVO？"></a>[※※※※※]apple用什么方式实现对一个对象的KVO？</h3><h3 id="※※-IBOutlet连出来的视图属性为什么可以被设置成weak"><a href="#※※-IBOutlet连出来的视图属性为什么可以被设置成weak" class="headerlink" title="[※※]IBOutlet连出来的视图属性为什么可以被设置成weak?"></a>[※※]IBOutlet连出来的视图属性为什么可以被设置成weak?</h3><h3 id="※※※※※-IB中User-Defined-Runtime-Attributes如何使用？"><a href="#※※※※※-IB中User-Defined-Runtime-Attributes如何使用？" class="headerlink" title="[※※※※※]IB中User Defined Runtime Attributes如何使用？"></a>[※※※※※]IB中User Defined Runtime Attributes如何使用？</h3><h3 id="※※※-如何调试BAD-ACCESS错误"><a href="#※※※-如何调试BAD-ACCESS错误" class="headerlink" title="[※※※]如何调试BAD_ACCESS错误"></a>[※※※]如何调试BAD_ACCESS错误</h3><h3 id="※※※-lldb（gdb）常用的调试命令？"><a href="#※※※-lldb（gdb）常用的调试命令？" class="headerlink" title="[※※※]lldb（gdb）常用的调试命令？"></a>[※※※]lldb（gdb）常用的调试命令？</h3>  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/面试/">面试</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/日常记事/">日常记事</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://blog.khzliu.net/2016/06/23/interview-checklist/" data-title="iOS面试题总结 | khzliu&#39;s blog" data-tsina="undefined" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/06/27/oc-struct/" title="Objective-C底层数据结构">
  <strong>PREVIOUS:</strong><br/>
  <span>
  Objective-C底层数据结构</span>
</a>
</div>


<div class="next">
<a href="/2016/06/22/MVVM/"  title="我对MVVM的理解">
 <strong>NEXT:</strong><br/> 
 <span>我对MVVM的理解
</span>
</a>
</div>

</nav>

	
</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#常见的iOS面试题"><span class="toc-number">1.</span> <span class="toc-text">常见的iOS面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#※-property中有哪些属性关键字？"><span class="toc-number">1.0.1.</span> <span class="toc-text">[※]@property中有哪些属性关键字？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RC语意修饰符"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">RC语意修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程安全修饰符"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">线程安全修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读写属性修饰符"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">读写属性修饰符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#怎么用-copy-关键字？"><span class="toc-number">1.0.2.</span> <span class="toc-text">[*]怎么用 copy 关键字？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#这个写法会出什么问题：-property-copy-NSMutableArray-array"><span class="toc-number">1.0.3.</span> <span class="toc-text">[]这个写法会出什么问题： @property (copy) NSMutableArray array;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？"><span class="toc-number">1.0.4.</span> <span class="toc-text">[*]如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的"><span class="toc-number">1.0.5.</span> <span class="toc-text">[*]@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#property-的本质是什么？"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">@property 的本质是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ivar、getter、setter-是如何生成并添加到这个类中的"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">ivar、getter、setter 是如何生成并添加到这个类中的?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#protocol-和-category-中如何使用-property"><span class="toc-number">1.0.6.</span> <span class="toc-text">[*]@protocol 和 category 中如何使用 @property ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※-weak属性需要在dealloc中置nil么？"><span class="toc-number">1.0.7.</span> <span class="toc-text">[※]weak属性需要在dealloc中置nil么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※-synthesize和-dynamic分别有什么作用？"><span class="toc-number">1.0.8.</span> <span class="toc-text">[※※]@synthesize和@dynamic分别有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※-ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"><span class="toc-number">1.0.9.</span> <span class="toc-text">[※※※]ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※-用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？"><span class="toc-number">1.0.10.</span> <span class="toc-text">[※※※]用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※-synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为-foo的实例变量，那么还会自动合成新变量么？"><span class="toc-number">1.0.11.</span> <span class="toc-text">[※※※]@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※-什么情况下不会autosynthesis（自动合成）"><span class="toc-number">1.0.12.</span> <span class="toc-text">[※※]什么情况下不会autosynthesis（自动合成）?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※※-在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？"><span class="toc-number">1.0.13.</span> <span class="toc-text">[※※※※※]在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※-objc中向一个nil对象发送消息将会发生什么？"><span class="toc-number">1.0.14.</span> <span class="toc-text">[※※]objc中向一个nil对象发送消息将会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※-objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？"><span class="toc-number">1.0.15.</span> <span class="toc-text">[※※※]objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※-什么时候会报unrecognized-selector的异常？"><span class="toc-number">1.0.16.</span> <span class="toc-text">[※※※]什么时候会报unrecognized selector的异常？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-一个objc对象如何进行内存布局？（考虑有父类的情况）"><span class="toc-number">1.0.17.</span> <span class="toc-text">[※※※※]一个objc对象如何进行内存布局？（考虑有父类的情况）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-一个objc对象的isa的指针指向什么？有什么作用？"><span class="toc-number">1.0.18.</span> <span class="toc-text">[※※※※]一个objc对象的isa的指针指向什么？有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-下面的代码输出什么？"><span class="toc-number">1.0.19.</span> <span class="toc-text">[※※※※]下面的代码输出什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runtime-如何实现-weak-属性"><span class="toc-number">1.0.20.</span> <span class="toc-text">[*]runtime 如何实现 weak 属性?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）"><span class="toc-number">1.0.21.</span> <span class="toc-text">[※※※※]runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？"><span class="toc-number">1.0.22.</span> <span class="toc-text">[※※※※]使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※※-objc中的类方法和实例方法有什么本质区别和联系？"><span class="toc-number">1.0.23.</span> <span class="toc-text">[※※※※※]objc中的类方法和实例方法有什么本质区别和联系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※※-objc-msgForward函数是做什么的，直接调用它将会发生什么？"><span class="toc-number">1.0.24.</span> <span class="toc-text">[※※※※※]_objc_msgForward函数是做什么的，直接调用它将会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※※-runtime如何实现weak变量的自动置nil？"><span class="toc-number">1.0.25.</span> <span class="toc-text">[※※※※※]runtime如何实现weak变量的自动置nil？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※※-能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？"><span class="toc-number">1.0.26.</span> <span class="toc-text">[※※※※※]能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※-runloop和线程有什么关系？"><span class="toc-number">1.0.27.</span> <span class="toc-text">[※※※]runloop和线程有什么关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※-runloop的mode作用是什么？"><span class="toc-number">1.0.28.</span> <span class="toc-text">[※※※]runloop的mode作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？"><span class="toc-number">1.0.29.</span> <span class="toc-text">[※※※※]以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※※-猜想runloop内部是如何实现的？"><span class="toc-number">1.0.30.</span> <span class="toc-text">[※※※※※]猜想runloop内部是如何实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※-objc使用什么机制管理对象内存？"><span class="toc-number">1.0.31.</span> <span class="toc-text">[※]objc使用什么机制管理对象内存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-ARC通过什么方式帮助开发者管理内存？"><span class="toc-number">1.0.32.</span> <span class="toc-text">[※※※※]ARC通过什么方式帮助开发者管理内存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）"><span class="toc-number">1.0.33.</span> <span class="toc-text">[※※※※]不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-BAD-ACCESS在什么情况下出现？"><span class="toc-number">1.0.34.</span> <span class="toc-text">[※※※※]BAD_ACCESS在什么情况下出现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※※-苹果是如何实现autoreleasepool的？"><span class="toc-number">1.0.35.</span> <span class="toc-text">[※※※※※]苹果是如何实现autoreleasepool的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※-使用block时什么情况会发生引用循环，如何解决？"><span class="toc-number">1.0.36.</span> <span class="toc-text">[※※]使用block时什么情况会发生引用循环，如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※-在block内如何修改block外部变量？"><span class="toc-number">1.0.37.</span> <span class="toc-text">[※※]在block内如何修改block外部变量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※-使用系统的某些block-api（如UIView的block版本写动画时），是否也考虑引用循环问题？"><span class="toc-number">1.0.38.</span> <span class="toc-text">[※※※]使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※-GCD的队列（dispatch-queue-t）分哪两种类型？"><span class="toc-number">1.0.39.</span> <span class="toc-text">[※※]GCD的队列（dispatch_queue_t）分哪两种类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）"><span class="toc-number">1.0.40.</span> <span class="toc-text">[※※※※]如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-dispatch-barrier-async的作用是什么？"><span class="toc-number">1.0.41.</span> <span class="toc-text">[※※※※]dispatch_barrier_async的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※※-苹果为什么要废弃dispatch-get-current-queue？"><span class="toc-number">1.0.42.</span> <span class="toc-text">[※※※※※]苹果为什么要废弃dispatch_get_current_queue？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※※-以下代码运行结果如何？"><span class="toc-number">1.0.43.</span> <span class="toc-text">[※※※※※]以下代码运行结果如何？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※-addObserver-forKeyPath-options-context-各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？"><span class="toc-number">1.0.44.</span> <span class="toc-text">[※※]addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※-如何手动触发一个value的KVO"><span class="toc-number">1.0.45.</span> <span class="toc-text">[※※※]如何手动触发一个value的KVO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※-若一个类有实例变量NSString-foo，调用setValue-forKey-时，可以以foo还是-foo作为key？"><span class="toc-number">1.0.46.</span> <span class="toc-text">[※※※]若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-KVC的keyPath中的集合运算符如何使用？"><span class="toc-number">1.0.47.</span> <span class="toc-text">[※※※※]KVC的keyPath中的集合运算符如何使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※-KVC和KVO的keyPath一定是属性么？"><span class="toc-number">1.0.48.</span> <span class="toc-text">[※※※※]KVC和KVO的keyPath一定是属性么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※※-如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？"><span class="toc-number">1.0.49.</span> <span class="toc-text">[※※※※※]如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※※-apple用什么方式实现对一个对象的KVO？"><span class="toc-number">1.0.50.</span> <span class="toc-text">[※※※※※]apple用什么方式实现对一个对象的KVO？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※-IBOutlet连出来的视图属性为什么可以被设置成weak"><span class="toc-number">1.0.51.</span> <span class="toc-text">[※※]IBOutlet连出来的视图属性为什么可以被设置成weak?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※※※-IB中User-Defined-Runtime-Attributes如何使用？"><span class="toc-number">1.0.52.</span> <span class="toc-text">[※※※※※]IB中User Defined Runtime Attributes如何使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※-如何调试BAD-ACCESS错误"><span class="toc-number">1.0.53.</span> <span class="toc-text">[※※※]如何调试BAD_ACCESS错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#※※※-lldb（gdb）常用的调试命令？"><span class="toc-number">1.0.54.</span> <span class="toc-text">[※※※]lldb（gdb）常用的调试命令？</span></a></li></ol></li></ol></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
			<li><a href="/categories/Objective-C语言/" title="Objective-C语言">Objective-C语言<sup>1</sup></a></li>
		
			<li><a href="/categories/Xcode基础/" title="Xcode基础">Xcode基础<sup>1</sup></a></li>
		
			<li><a href="/categories/iOS/" title="iOS">iOS<sup>1</sup></a></li>
		
			<li><a href="/categories/日常记事/" title="日常记事">日常记事<sup>1</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Hexo/" title="Hexo">Hexo<sup>1</sup></a></li>
		
			<li><a href="/tags/HybridApp/" title="HybridApp">HybridApp<sup>0</sup></a></li>
		
			<li><a href="/tags/Javascript/" title="Javascript">Javascript<sup>0</sup></a></li>
		
			<li><a href="/tags/Objective-C/" title="Objective-C">Objective-C<sup>1</sup></a></li>
		
			<li><a href="/tags/Webview/" title="Webview">Webview<sup>0</sup></a></li>
		
			<li><a href="/tags/Xcode/" title="Xcode">Xcode<sup>1</sup></a></li>
		
			<li><a href="/tags/iOS/" title="iOS">iOS<sup>1</sup></a></li>
		
			<li><a href="/tags/设计模式/" title="设计模式">设计模式<sup>1</sup></a></li>
		
			<li><a href="/tags/面试/" title="面试">面试<sup>1</sup></a></li>
		
		</ul>
</div>


  
  <div class="archiveslist">
    <p class="asidetitle"><a href="/archives">Archives</a></p>
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">1</span></li></ul>
  </div>


  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Objective-C/" style="font-size: 10px;">Objective-C</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/面试/" style="font-size: 10px;">面试</a>
    </div>
  </div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
      <li><a href="http://yangjian.me" target="_blank" title="YangJian">Alimon's Blog</a></li>
      <li><a href="http://hexo.io" target="_blank" title="Hexo">Hexo</a></li>
    </ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m khzliu. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font clearfix">
		
		<a href="http://weibo.com/1819020590" target="_blank" title="weibo"></a>
		
		
		
		<a href="https://github.com/khzliu" target="_blank" title="github"></a>
		
		
		<a href="https://www.facebook.com/khzliu" target="_blank" title="facebook"></a>
		
		
        <a href="https://www.linkedin.com//in/khzliu" target="_blank" title="linkedin"></a>
        
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2016 
		
		<a href="http://blog.khzliu.net" target="_blank" title="khzliu">khzliu</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






  </body>
</html>
